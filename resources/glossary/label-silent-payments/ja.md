---
term: LABEL (SILENT PAYMENTS)
---

Silent Paymentsプロトコル内では、ラベルは初期の静的アドレスを変更して多くの他の静的アドレスを作成するために使用される整数です。これらのラベルの使用により、Silent Payments経由で送信される支払いを、各使用ごとに異なる静的アドレスを採用することで区別し、これらの支払いを検出するための運用負担（スキャン）を過度に増加させることなく行うことができます。Bobは、スキャン用の公開鍵$B_{\text{scan}}$と支出用の公開鍵$B_{\text{spend}}$から構成される静的アドレス$B$を使用します。$b_{\text{scan}}$のハッシュと整数$m$が生成点$G$にスカラー乗算され、支出用公開鍵$B_{\text{spend}}$に加えられることで、新しい種類の支出用公開鍵$B_m$が作成されます：

$$  B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m) \cdot G  $$

例えば、最初の鍵$B_1$はこの方法で得られます：

$$  B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G  $$

Bobが公開する静的アドレスは、$B_{\text{scan}}$と$B_m$で構成されるようになります。例えば、ラベル$1$を持つ最初の静的アドレスは以下のようになります：

$$ B = B_{\text{scan}} \text{ ‖ } B_1 $$

ラベル$0$はお釣り用に予約されているため、ラベル$1$から開始します。Bobが提供したラベル付き静的アドレスにビットコインを送りたいAliceは、$B_{\text{spend}}$の代わりに新しい$B_1$を使用して、ユニークな支払いアドレス$P_0$を導出します：

$$  P_0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G  $$

実際には、AliceはBobがラベル付きアドレスを持っていることを知らないかもしれません。彼女は単に彼が提供した静的アドレスの第二部分、この場合は$B_{\text{spend}}$ではなく$B_1$の値を使用します。支払いをスキャンするために、Bobは常にこの方法で初期の静的アドレスの値と$B_{\text{spend}}$を使用します：

$$   P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G  $$

その後、彼は見つけた$P_0$の値を一つずつ出力から引きます。そして、これらの引き算の結果のいずれかが彼のウォレットで使用しているラベルの値と一致するかどうかを確認します。例えば、出力#4がラベル$1$で、これが彼のラベル付き静的アドレス$B_1$に関連するSilent Paymentであることを意味する場合、この方法が機能します：
$$ Out_4 - P_0 = \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$
この方法のおかげで、Bobは基本的な静的アドレス($B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}}$)から派生した多数の静的アドレス($B_1$, $B_2$, $B_3$...)を使用して、用途を適切に分離することができます。

しかし、この静的アドレスの分離は個人のウォレット管理の観点からは有効ですが、身元の分離を可能にするものではありません。すべてが同じ$B_{\text{scan}}$を持っているため、すべての静的アドレスを簡単に関連付けて、それらが単一のエンティティに属していると推測することができます。