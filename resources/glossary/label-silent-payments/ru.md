---
term: LABEL (SILENT PAYMENTS)
---

В протоколе Silent Payments метки являются целыми числами, используемыми для модификации исходного статического адреса с целью создания множества других статических адресов. Использование этих меток позволяет сегментировать платежи, отправленные через Silent Payments, путем применения различных статических адресов для каждого использования, не увеличивая при этом операционную нагрузку на обнаружение этих платежей (сканирование). Боб использует статический адрес $B$, состоящий из двух публичных ключей: $B_{\text{scan}}$ для сканирования и $B_{\text{spend}}$ для расходования. Хеш от $b_{\text{scan}}$ и целого числа $m$, умноженный на скалярно на точку генератора $G$, добавляется к публичному ключу для расходования $B_{\text{spend}}$, чтобы создать своего рода новый публичный ключ для расходования $B_m$:

$$  B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m) \cdot G  $$

Например, первый ключ $B_1$ получается следующим образом:

$$  B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G  $$

Статический адрес, опубликованный Бобом, теперь будет состоять из $B_{\text{scan}}$ и $B_m$. Например, первый статический адрес с меткой $1$ будет:

$$ B = B_{\text{scan}} \text{ ‖ } B_1 $$

Мы начинаем с метки $1$, потому что метка $0$ зарезервирована для сдачи. Алиса, которая хочет отправить биткоины на предоставленный Бобом статический адрес с меткой, будет выводить уникальный платежный адрес $P_0$, используя новый $B_1$ вместо $B_{\text{spend}}$:

$$  P_0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G  $$

На самом деле, Алиса может даже не знать, что у Боба есть адрес с меткой, поскольку она просто использует вторую часть статического адреса, который он предоставил, что в данном случае является значением $B_1$, а не $B_{\text{spend}}$. Для сканирования платежей Боб всегда будет использовать значение своего исходного статического адреса с $B_{\text{spend}}$ следующим образом:

$$   P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G  $$

Затем он просто вычитает найденное значение для $P_0$ из каждого вывода по очереди. После этого он проверяет, соответствует ли один из результатов этих вычитаний значению одной из меток, которые он использует в своем кошельке. Если это соответствует, например, для вывода №4 с меткой $1$, это означает, что этот вывод является Silent Payment, ассоциированным с его статическим адресом с меткой $B_1$:
$$ Out_4 - P_0 = \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$

Это работает потому что:
$$  B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G  $$
Благодаря этому методу, Боб может использовать множество статических адресов (с $B_1$, $B_2$, $B_3$...), все они производные от его базового статического адреса ($B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}}$), чтобы корректно разделять использования.

Однако, это разделение статических адресов действительно только с точки зрения управления личным кошельком, но не позволяет разделить идентичности. Поскольку у всех них одинаковый $B_{\text{scan}}$, очень легко ассоциировать все статические адреса вместе и сделать вывод, что они принадлежат одной сущности.