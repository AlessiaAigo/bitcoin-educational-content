---
name: 形式密码学导论
goal: 对密码学的科学与实践进行深入介绍。
objectives:
  - 探索贝尔密码和现代加密方法，以理解密码学的基本和历史概念。
  - 深入研究数论、群和域，以掌握密码学底层的关键数学概念。
  - 学习RC4流密码和128位密钥的AES，了解对称加密算法。
  - 调查RSA密码系统、密钥分发和哈希函数，以探索非对称加密。

---
# 深入探索密码学

在密码学教育中，很难找到既不过于深奥也不过于浅显的材料。

一方面，有的是冗长、正式的论述，真正只适合那些在数学、逻辑或其他形式学科有强大背景的人。另一方面，有的是非常高层次的介绍，实在是对于至少有一点好奇心的人隐藏了太多细节。

这本对密码学的介绍旨在抓住中间地带。虽然对于密码学新手来说应该是相对具有挑战性和详细性的，但它不是典型的基础论述中的兔子洞。

+++

# 密码学导论
<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## 简短描述
<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

本书提供了对密码学的科学与实践的深入介绍。在可能的情况下，它侧重于概念性而非形式性的材料阐述。

> 本课程基于[JWBurgers的仓库](https://github.com/JWBurgers/An_Introduction_to_Cryptography)。所有权利归他所有。内容尚未完成，仅用于展示如果JWburger同意，我们如何能够整合它。

### 动机与目标

在密码学教育中，很难找到既不过于深奥也不过于浅显的材料。

一方面，有的是冗长、正式的论述，真正只适合那些在数学、逻辑或其他形式学科有强大背景的人。另一方面，有的是非常高层次的介绍，实在是对于至少有一点好奇心的人隐藏了太多细节。

这本对密码学的介绍旨在抓住中间地带。虽然对于密码学新手来说应该是相对具有挑战性和详细性的，但它不是典型的基础论述中的兔子洞。

### 目标受众

从开发者到求知欲强的人，这本书对任何想要对密码学有超过肤浅理解的人都有用。如果你的目标是掌握密码学领域，那么这本书也是一个很好的起点。

### 阅读指南

目前书中包含七个章节：“什么是密码学？”（第1章）、 “密码学的数学基础I”（第2章）、 “密码学的数学基础II”（第3章）、 “对称密码学”（第4章）、 “RC4和AES”（第5章）、 “非对称密码学”（第6章）和“RSA密码系统”（第7章）。最后一个章节，“密码学实践”，将会被添加。它聚焦于各种密码学应用，包括传输层安全、洋葱路由和比特币的价值交换系统。
除非你在数学方面有很强的背景，否则数论可能是这本书中最难的主题。我在第3章提供了一个概述，并且在第5章介绍AES以及第7章介绍RSA密码系统时也提到了数论。
如果你真的在这本书的这些部分中对形式细节感到挣扎，我建议你首次阅读时选择高层次的阅读方式。

### 致谢

在塑造这本书方面最有影响力的书籍是Jonathan Katz和Yehuda Lindell的《现代密码学导论》，CRC出版社（佛罗里达州博卡拉顿），2015年。Coursera上有一个伴随课程叫做“密码学”。

在创建这本书的概述时，其他一些有帮助的主要资源包括Simon Singh的《密码书》，Fourth Estate（伦敦，1999年）；Christof Paar和Jan Pelzl的《理解密码学》，Springer（海德堡，2010年）以及基于Paar书籍的课程叫做“密码学导论”（可在https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg查看）；以及Bruce Schneier的《应用密码学》，第二版，2015年（印第安纳波利斯，IN：John Wiley & Sons）。

我只会引用从这些资源中获取的非常具体的信息和结果，但在这里要对它们的一般贡献表示感谢。

对于那些在这个介绍之后希望寻求更高级密码学知识的读者，我强烈推荐Katz和Lindell的书。Katz在Coursera上的课程比书本更容易理解。

### 贡献

请查看仓库中的贡献文件，了解如何支持该项目的一些指南。

# 什么是密码学？
<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

让我们从密码学历史中一个更加迷人和娱乐性的章节开始我们对该领域的探索：贝尔密码。<sup>[1](#footnote1)</sup>

在我看来，贝尔密码的故事更可能是虚构而非现实。但据说情况如下。

## 贝尔密码
<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>

在1820年和1822年的冬季，一个名叫Thomas J. Beale的人在弗吉尼亚州林奇堡的Robert Morriss拥有的旅馆住宿。在Beale第二次住宿结束时，他交给Morriss一个装有珍贵文件的铁盒以供保管。

几个月后，Morriss收到了Beale在1822年5月9日写的一封信。信中强调了铁盒内容的巨大价值，并向Morriss说明了一些指示：如果Beale或他的任何伙伴都没有来领取这个盒子，他应该在信件日期的十年后（即1832年5月9日）准确地打开它。盒子里的一些文件将会是用普通文本写的。然而，其他一些文件则“在没有密钥的帮助下无法理解”。这个“密钥”将会在1832年6月由Beale的一个未命名的朋友交给Morriss。
尽管指示明确，但莫里斯在1832年5月并未打开那个盒子，贝尔的神秘朋友也未在那年的6月出现。直到1845年，旅馆老板最终决定打开盒子。在盒子里，莫里斯发现了一张便条，上面解释了贝尔和他的同伴如何在西部发现了金银，并将其连同一些珠宝埋藏起来以保管。此外，盒子中还包含了三个**密文**：即，用代码书写的文本，需要一个**密码钥匙**或一个秘密以及一个伴随的算法来解锁。这个解锁密文的过程被称为**解密**，而加锁过程被称为**加密**。（如第3章所解释，密码这个词可以有不同的含义。在“贝尔密码”这个名字中，它是密文的简称。）
莫里斯在铁盒中发现的三个密文，每个都由逗号分隔的一系列数字组成。根据贝尔的便条，这些密文分别提供了宝藏的位置、宝藏的内容以及有权继承宝藏及其份额的名单（后者信息在贝尔及其同伴若未来认领盒子的情况下相关）。

莫里斯试图解密这三个密文长达二十年。如果有钥匙，这本来是容易的。但莫里斯没有钥匙，并且未能成功恢复原始文本，或者在密码学中通常称为的**明文**。

临近生命终点，莫里斯在1862年将盒子传给了一个朋友。这位朋友随后在1885年以化名J.B. Ward出版了一本小册子。它包括了盒子的（据称的）历史、三个密文以及他为第二个密文找到的解决方案。（显然，每个密文有一个钥匙，而不是贝尔在给莫里斯的信中最初似乎提议的一个钥匙可以解开所有三个密文。）

你可以在下面的*图1*中看到第二个密文。<sup>[2](#footnote2)</sup> 这个密文的钥匙是美国独立宣言。解密程序归结为应用以下两条规则：

* 对于密文中的任何数字n，定位到美国独立宣言中的第n个单词
* 用你找到的单词的第一个字母替换数字n


*图1：贝尔密码第2号*

![图1：贝尔密码第2号](assets/Figure1-1.webp "图1：贝尔密码第2号")


例如，第二个密文的第一个数字是115。独立宣言的第115个单词是“instituted”，所以明文的第一个字母是“i”。密文并未直接指示单词间隔和大写。但在解密了前几个单词后，你可以逻辑推断出明文的第一个单词就是简单的“I”（明文以短语“I have deposited in the county of Bedford.”开始）。
在解密之后，第二条信息提供了宝藏（黄金、白银和珠宝）的详细内容，并暗示它被埋在铁罐中并用石头覆盖在弗吉尼亚州的贝德福德县。人们喜欢一个好的谜团，因此人们在解密其他两个贝尔密码上投入了巨大的努力，特别是描述宝藏位置的那一个。即便是各种著名的密码学家也尝试过。然而，到目前为止，还没有人能够解密其他两个密文。

## 现代密码学
<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

像贝尔密码这样的多彩故事是我们大多数人与密码学联系在一起的。然而，现代密码学至少在四个重要方面与这些历史例子不同。

首先，从历史上看，密码学只关注**保密性**（或机密性）。<sup>[3](#footnote3)</sup> 会创建密文，以确保只有特定的当事人能够了解明文中的信息，就像贝尔密码的情况一样。为了使加密方案能够很好地服务于这一目的，只有拥有密钥的人才能够解密密文。

现代密码学关注的主题比仅仅是保密性更广泛。这些主题主要包括（1）**消息完整性**——即，确保消息未被更改；（2）**消息真实性**——即，确保消息确实来自特定的发送者；以及（3）**不可否认性**——即，确保发送者无法在之后虚假地否认她发送了消息。<sup>[4](#footnote4)</sup>

因此，需要记住的一个重要区别是，**加密方案**与**密码学方案**之间的区别。加密方案只关注保密性。虽然加密方案是密码学方案，但反之则不成立。密码学方案还可以服务于密码学的其他主要主题，包括完整性、真实性和不可否认性。

完整性和真实性的主题与保密性一样重要。我们的现代通信系统如果没有关于通信的完整性和真实性的保证，就无法运作。不可否认性也是一个重要的考虑因素，例如对于数字合同，但在密码学应用中的普遍需求不如保密性、完整性和真实性那么高。

其次，像贝尔密码这样的经典加密方案总是涉及一个在所有相关方之间共享的密钥。然而，许多现代密码学方案不仅涉及一个密钥，而且涉及两个密钥：一个**私钥**和一个**公钥**。前者在任何应用中都应保持私密，而后者通常是公开知识（因此得名）。在加密领域内，公钥可以用来加密消息，而私钥可以用于解密。

处理所有方共享一个密钥的方案的密码学分支被称为**对称密码学**。这样的方案中的单一密钥通常被称为**私钥**（或秘密密钥）。处理需要私钥-公钥对的方案的密码学分支被称为**非对称密码学**。这些分支有时也被称为**私钥密码学**和**公钥密码学**，分别（尽管这可能引起混淆，因为公钥密码学方案也有私钥）。
20世纪70年代末期非对称密码学的出现是密码学历史上最重要的事件之一。没有它，我们大多数的现代通信系统，包括比特币，都不可能存在，或者至少非常不切实际。
重要的是，现代密码学不仅仅是对称和非对称密钥密码方案的研究（尽管这占据了该领域的大部分）。例如，密码学还涉及哈希函数和伪随机数生成器，你可以在这些原语上构建与对称或非对称密钥密码学无关的应用程序。

第三，像Beale密码那样的古典加密方案，更多的是艺术而非科学。它们的安全性主要基于对其复杂性的直觉。当学习到对它们的新攻击时，它们通常会被修补，或者如果攻击特别严重，则完全放弃。然而，现代密码学是一门严谨的科学，它采用正式的、数学的方法来开发和分析密码方案。<sup>[5](#footnote5)</sup>

具体来说，现代密码学侧重于**安全性证明**的正式证明。对于密码方案的安全性证明分为三个步骤：

1.	陈述一个**密码学定义的安全性**，即一组安全目标和攻击者构成的威胁。
2.	就方案的计算复杂性提出任何数学假设。例如，一个密码方案可能包含一个伪随机数生成器。尽管我们不能证明这些存在，但我们可以假设它们确实存在。
3.	基于正式的安全性概念和任何数学假设，展示方案的数学**安全性证明**。

第四，历史上密码学主要在军事设置中使用，但在数字时代，它已经渗透到我们日常活动中。无论你是在线银行操作、在社交媒体上发布、使用信用卡从亚马逊购买产品，还是给朋友小费比特币，密码学都是我们数字时代不可或缺的。

鉴于现代密码学的这四个方面，我们可能将现代**密码学**描述为一门科学，关注于正式开发和分析密码方案，以保护数字信息免受敌对攻击。<sup>[6](#footnote6)</sup> 这里的安全应广泛理解为防止破坏通信中的秘密性、完整性、认证和/或不可否认性的攻击。

密码学最好被视为**网络安全**的一个子学科，网络安全关注于防止计算机系统的盗窃、损坏和误用。注意，许多网络安全问题与密码学关系不大或只有部分关系。

例如，如果一家公司在本地存放昂贵的服务器，他们可能会关注如何保护这些硬件免受盗窃和损坏。虽然这是一个网络安全问题，但它与密码学关系不大。

再举一个例子，**网络钓鱼攻击**是我们现代社会的一个常见问题。这些攻击尝试通过电子邮件或其他消息媒介欺骗人们放弃敏感信息，如密码或信用卡号码。虽然密码学在一定程度上可以帮助解决网络钓鱼攻击，但全面的方法需要不仅仅是使用一些密码学。


## 开放通信
<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

现代密码学旨在为**开放通信**环境提供安全保障。如果我们的通信渠道受到如此良好的保护，以至于窃听者没有机会操纵甚至仅仅是观察我们的消息，那么密码学就是多余的。然而，我们的大多数通信渠道远非如此安全。
在现代世界中，通信的支柱是一个庞大的光纤网络。在现代家庭中打电话、看电视和浏览网页通常依赖于这个光纤网络（一小部分可能完全依赖于卫星）。确实，你的家中可能有不同的数据连接，如同轴电缆、（非对称）数字用户线路和光纤电缆。但是，至少在发达世界，这些不同的数据传输介质很快就会在你家外面的某个节点与一个连接全球的庞大光纤网络相连。例外是发达世界的一些偏远地区，比如在美国和澳大利亚，数据流量可能仍然会通过传统的铜质电话线路传输相当长的距离。

阻止潜在攻击者物理接触这些网络和其支持基础设施是不可能的。实际上，我们已经知道，我们的大部分数据在互联网的关键交叉点被各国情报机构截获。这包括从Facebook消息到你访问的网站地址的一切。

虽然在大规模监视数据上需要强大的对手，如国家情报机构，但只有少量资源的攻击者可以轻松尝试在更局部的范围内窃听。尽管这可能发生在接线水平上，但拦截无线通信要容易得多。

我们的大部分本地网络数据——无论是在我们的家中、办公室还是咖啡馆——现在通过无线电波传输到一体式路由器上的无线接入点，而不是通过物理电缆。因此，攻击者只需要很少的资源就可以拦截你的任何本地流量。这尤其令人担忧，因为大多数人几乎不采取任何措施来保护他们的本地网络上的数据传输。此外，潜在的攻击者还可以针对我们的移动宽带连接，如3G、4G和5G。所有这些无线通信都是攻击者的易攻目标。

因此，通过保护通信渠道来保密通信的想法，在现代世界中是一个绝望的幻想。我们所知的一切都证明了需要极度的偏执：你应该始终假设有人在监听。而密码学是我们在这个现代环境中获得任何形式的安全的主要工具。

### 注释
[^1]: 关于这个故事的一个好的总结，参见Simon Singh的*密码书*，第四版（伦敦，1999年），第82-99页。Andrew Allen在2010年制作了这个故事的短片。你可以在其网站上找到这部电影，“The Thomas Beale Cipher” [^1]。

[^2]: 这张图片可以在维基百科的Beale密码页面上找到 [^2]。

[^3]: 准确地说，密码学方案的重要应用一直关注于保密。例如，孩子们经常使用简单的密码学方案来“玩乐”。在这些情况下，保密并不是真正的关注点 [^3]。

[^4]: Bruce Schneier, *应用密码学*，第二版，2015年（印第安纳波利斯，IN: John Wiley & Sons），第2页 [^4]。

[^5]: 参见Jonathan Katz和Yehuda Lindell的*现代密码学导论*，CRC出版社（佛罗里达州博卡拉顿：2015年），尤其是第16-23页，对此有很好的描述 [^5]。

[^6]: 参照Katz和Lindell，同上，第3页。我认为他们的表述有一些问题，所以在这里提出了他们声明的略有不同的版本 [^6]。
[^7]: 参见，例如，Olga Khazan，“海底电缆窃听的令人毛骨悚然的长期实践”，*大西洋月刊*，2013年7月16日（可在[大西洋](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)获取）[^7]。

# 密码学的数学基础 I
<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

密码学依赖于数学。如果你想对密码学有一个超越表面的理解，你需要对这些数学内容感到舒适。

本章介绍了你在学习密码学时会遇到的大部分基础数学知识。这些主题包括随机变量、模运算、异或运算和伪随机性。你应该掌握这些部分的材料，以便对密码学有一个非表面的理解。

下一章将处理数论，这是一个更具挑战性的主题。

## 随机变量
<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

随机变量通常用非粗体的大写字母表示。因此，例如，我们可能谈论一个随机变量X、一个随机变量Y或一个随机变量Z。这也是我从现在开始将要使用的表示法。

**随机变量**可以取两个或更多可能的值，每个值都有一定的正概率。可能的值列在**结果集**中。

每次你**抽样**一个随机变量时，你根据定义的概率从其结果集中抽取一个特定的值。

让我们来看一个简单的例子。假设有一个变量X，定义如下：

* X的结果集为{1,2}
* Pr [X = 1] = 0.5
* Pr [X = 2] = 0.5

很容易看出X是一个随机变量。首先，X可以取两个或更多可能的值，即1和2。其次，每次你抽样X时，每个可能的值发生的概率都是正的，即0.5。

随机变量所需的一切就是一个具有两个或更多可能性的结果集，其中每个可能性在抽样时都有正概率发生。因此，从原理上讲，随机变量可以抽象地定义，不涉及任何上下文。在这种情况下，你可能会认为“抽样”是进行某种自然实验以确定随机变量的值。

上面定义的变量X是抽象定义的。因此，你可能会认为抽样变量X就像抛一个公平的硬币，并在正面的情况下分配“2”，在反面的情况下分配“1”。每次抽样X，你再次抛硬币。

或者，你也可以认为抽样X，就像掷一个公平的骰子，并在骰子落在1、3或4的情况下分配“2”，在骰子落在2、5或6的情况下分配“1”。每次你抽样X，你再次掷骰子。

实际上，任何能让你定义上述X的可能值的概率的自然实验都可以想象成与抽取有关。
然而，随机变量通常不是抽象地引入的。相反，可能的结果值集合具有明确的现实世界意义（而不仅仅是作为数字）。此外，这些结果值可能是针对某种特定类型的实验定义的（而不是作为具有这些值的任何自然实验）。
现在让我们考虑一个不是抽象定义的变量X的例子。为了确定两个足球队中哪一个开始比赛，X被如下定义：

* X的结果集为{红队开球, 蓝队开球}
* 投掷特定的硬币C：反面 = “红队开球”；正面 = “蓝队开球”
* Pr [X = 红队开球] = 0.5
* Pr [X = 蓝队开球] = 0.5

在这种情况下，X的结果集提供了一个具体的含义，即哪个队伍在足球比赛中开始。此外，可能的结果及其相关概率是由一个具体的实验决定的，即投掷特定的硬币C。

在密码学讨论中，通常会针对具有现实世界意义的结果集引入随机变量。这可能是所有可能被加密的消息的集合，称为消息空间，或者是使用加密的各方可以选择的所有密钥的集合，称为密钥空间。

然而，在密码学讨论中的随机变量，通常不是针对某个特定的自然实验定义的，而是针对可能产生正确概率分布的任何实验。

随机变量可以具有离散或连续的概率分布。具有**离散概率分布**的随机变量——即离散随机变量——有有限数量的可能结果。到目前为止给出的两个例子中的随机变量X都是离散的。

**连续随机变量**可以取一个或多个区间内的值。例如，你可能会说，一个随机变量在抽样时，将取0到1之间的任何实数值，并且这个区间内的每个实数值都同样可能。在这个区间内，有无限多的可能值。

对于密码学讨论，你只需要理解离散随机变量。因此，从现在开始的任何关于随机变量的讨论都应该被理解为指的是离散随机变量，除非特别指明。

### 绘制随机变量图

随机变量的可能值和相关概率可以通过图形轻松可视化。例如，考虑前一节中的随机变量X，其结果集为{1,2}，且Pr [X = 1] = 0.5和Pr [X = 2] = 0.5。我们通常会以条形图的形式展示这样的随机变量，如*图1*所示。

*图1：随机变量X*

![图1：随机变量X。](assets/Figure2-1.webp)

*图1*中的宽条显然并不意味着随机变量X实际上是连续的。相反，条形被制作得宽一些是为了更具视觉吸引力（仅仅一条直线向上提供的视觉化效果不够直观）。

### 均匀变量

在“随机变量”这个表达中，“随机”仅仅意味着“概率性的”。换句话说，它仅仅意味着变量的两个或多个可能结果发生具有某些概率。然而，这些结果并*不必然*都同样可能（尽管在其他上下文中“随机”确实可以有这个意义）。
一个**均匀变量**是随机变量的一个特殊情况。它可以取两个或多个值，这些值出现的概率都相等。在*图1*中描述的随机变量X显然是一个均匀变量，因为两种可能的结果发生的概率都是0.5。然而，有许多随机变量并不是均匀变量的实例。
例如，考虑随机变量Y。它有一个结果集{1,2,3,8,10}和以下概率分布：Pr [Y = 1] = 0.25; Pr [Y = 2] = 0.35; Pr [Y = 3] = 0.1; Pr [Y = 8] = 0.25; Pr [Y = 10] = 0.05。

虽然确实有两个可能的结果发生的概率相等，即1和8，但Y在抽样时也可以取某些与0.25不同的概率值。因此，虽然Y确实是一个随机变量，但它不是一个均匀变量。

随机变量Y的图形描述提供在*图2*中。

*图2：随机变量Y*

![图2：随机变量Y。](assets/Figure2-2.webp "图2：随机变量Y")

最后一个例子，考虑随机变量Z。它有一个结果集{1,3,7,11,12}和以下概率分布：Pr (2) = 0.2; Pr (3) = 0.2; Pr (9) = 0.2; Pr (11) = 0.2; Pr (12) = 0.2。你可以在图3中看到它的描述。与Y相反，随机变量Z确实是一个均匀变量，因为抽样时可能值的所有概率都相等。

*图3：随机变量Z*

![图3：随机变量Z。](assets/Figure2-3.webp "图3：随机变量Z")

### 条件概率

假设Bob打算从上一个日历年中均匀选择一天。我们应该如何得出Bob选择的那天是夏天的概率是多少？

只要我们认为Bob的过程确实是真正均匀的，我们应该得出Bob选择夏天的一天的概率是1/4。这是随机选择的那天是夏天的**无条件概率**。

现在假设，与其均匀地抽取一个日历日，Bob只从那些在Crystal Lake（新泽西州）中午温度达到或超过21摄氏度的日子中均匀选择。鉴于这一额外信息，我们可以得出什么结论，关于Bob将选择夏天的一天的概率？

即使没有任何进一步的具体信息（例如，去年日历年每天中午的温度），我们确实应该得出与之前不同的结论。

知道Crystal Lake位于新泽西州，我们肯定不会期望冬天中午的温度达到或超过21摄氏度。相反，更有可能是春天或秋天的一个温暖日子，或者是夏天的某一天。因此，知道Bob选择的那天在Crystal Lake中午的温度达到或超过21摄氏度，Bob选择的那天是夏天的概率变得更高。这是随机选择的那天是夏天的**条件概率**，鉴于Crystal Lake中午的温度达到或超过21摄氏度。
与前一个例子不同，两个事件的概率也可以完全无关。在这种情况下，我们说它们是**独立的**。
例如，假设一个公平的硬币已经落地朝上。鉴于这个事实，那么明天下雨的概率是多少呢？在这种情况下，条件概率应该与明天下雨的无条件概率相同，因为硬币翻转通常不会对天气有任何影响。

我们使用“|”符号来书写条件概率陈述。例如，给定事件B已经发生的情况下，事件A的概率可以这样写：Pr[A|B]。所以，当两个事件A和B是独立的时，那么Pr[A|B] = Pr[A]且Pr[B|A] = Pr[B]。独立性的条件可以简化如下：Pr[A,B] = Pr[A]*Pr[B]。

概率论中的一个关键结果被称为**贝叶斯定理**。它基本上表明Pr[A|B]可以重写为：

Pr[A|B] = (Pr[B|A] • Pr[A]) / Pr[B]

我们也可以考虑涉及两个或多个随机变量在一组可能事件上的条件概率，而不是使用具体事件的条件概率。假设有两个随机变量X和Y。我们可以用x表示X的任何可能值，用y表示Y的任何可能值。那么，我们可能会说，如果以下陈述成立，则两个随机变量是独立的：

对于所有的x和y，Pr[X = x,Y = y] = Pr[X = x] • Pr[Y = y]

让我们更明确地说明这个陈述的含义。

假设X和Y的结果集定义如下：**X** = {x<sub>1</sub>,x<sub>2</sub>….,x<sub>i</sub>,….x<sub>n</sub>} 和 **Y** = {y<sub>1</sub>,y<sub>2</sub>….,y<sub>i</sub>,….y<sub>m</sub>}。（通常用粗体大写字母表示值的集合。）

现在假设你抽样Y并观察到y<sub>1</sub>。上述陈述告诉我们，现在从X抽样获得x<sub>1</sub>的概率与我们从未观察到y<sub>1</sub>时完全相同。这对于我们可能从Y的初始抽样中抽取的任何y<sub>i</sub>都是真实的。最后，这不仅适用于x<sub>1</sub>。对于任何x<sub>i</sub>，发生的概率不受Y抽样结果的影响。所有这些也适用于首先抽样X的情况。

让我们以一个稍微哲学性的观点结束我们的讨论。在任何现实世界的情况下，某个事件的概率总是针对一组特定的信息来评估的。在非常严格的意义上，没有“无条件概率”。

例如，假设我问你到2030年猪会飞的概率。虽然我没有给你更多信息，但你显然知道很多关于世界的信息，这些信息可以影响你的判断。你从未见过猪飞。你知道大多数人不会期望它们飞。你知道它们实际上并不是为了飞而构建的。等等。
因此，当我们谈论某个事件在现实世界背景下的“无条件概率”时，这个术语真正的含义只有在我们将其理解为“没有任何进一步明确信息的概率”时才有意义。那么，任何对“条件概率”的理解，都应该总是针对某个具体的信息。例如，我可能会在告诉你一些新西兰的山羊在几年的训练后学会了飞行的证据后，问你到2030年猪会飞的概率。在这种情况下，你可能会调整你对2030年猪会飞的概率的判断。所以，到2030年猪会飞的概率是基于关于新西兰山羊的这个证据的条件概率。

## 模运算
<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

最基本的**模运算**表达式形式如下：x mod y。

变量x称为被除数，变量y称为除数。要用正的被除数和正的除数进行模运算，你只需确定除法的余数。

例如，考虑表达式 25 mod 4。数字4进入数字25共6次。该除法的余数是1。因此，25 mod 4等于1。以类似的方式，我们可以评估下面的表达式：

* 29 mod 30 = 29（因为30进入29共0次，余数是29）
* 42 mod 2 = 0（因为2进入42共21次，余数是0）
* 12 mod 5 = 2（因为5进入12共2次，余数是2）
* 20 mod 8 = 4（因为8进入20共2次，余数是4）

当被除数或除数为负数时，编程语言可能会以不同方式处理模运算。

在密码学中，你肯定会遇到负的被除数的情况。在这些情况下，典型的方法如下：

* 首先确定最接近的值，该值*小于或等于*被除数，其中除数可以除以余数为零。称该值为p。
* 如果被除数是x，那么模运算的结果是x – p的值。

例如，假设被除数是-20，除数是3。最接近小于或等于-20的值，其中3可以整除的是-21。在这种情况下，x – p的值是-20 - (-21)。这等于1，因此，-20 mod 3等于1。以类似的方式，我们可以评估下面的表达式：

* -8 mod 5 = 2
* -19 mod 16 = 13
* -14 mod 6 = 4

关于符号，你通常会看到以下类型的表达式：x = [y mod z]。由于括号的存在，模运算在这种情况下只适用于表达式的右侧。例如，如果y等于25且z等于4，那么x计算为1。
在没有括号的情况下，模运算作用于表达式的*两侧*。例如，考虑以下表达式：x = y mod z。如果y等于25且z等于4，那么我们只知道x mod 4的结果为1。这与x来自集合{….– 7, – 3, 1, 5, 9….}的任何值都是一致的。
涉及对数字和表达式进行模运算的数学分支被称为**模运算算术**。你可以将这个分支视为在数字线不是无限长的情况下的算术。尽管我们通常在密码学中遇到对（正）整数的模运算，但你也可以使用任何实数进行模运算。

### 移位密码

模运算在密码学中经常遇到。为了说明这一点，让我们考虑一个最著名的历史加密方案：移位密码。

首先定义它。假设一个字典*D*，它按顺序将英文字母表的所有字母与数字集{0,1,2…,25}等同起来。假设一个消息空间**M**。那么，**移位密码**是这样定义的加密方案：

- 从密钥空间**K**中均匀选择一个密钥k，其中**K** = {0,1,2,…,25}<sup>[1](#footnote1)</sup>
- 按如下方式加密消息m є **M**：
    - 将m分解为其各个字母m<sub>0</sub>, m<sub>1</sub>,….m<sub>i</sub>….,m<sub>l</sub>
    - 根据*D*将每个m<sub>i</sub>转换为一个数字
    - 对于每个m<sub>i</sub>，c<sub>i</sub> = [(m<sub>i</sub> + k) mod 26]
    - 根据*D*将每个c<sub>i</sub>转换为一个字母
    - 然后组合c<sub>0</sub>, c<sub>1</sub>,….,c<sub>l</sub>以产生密文c
- 按如下方式解密密文c：
    - 根据*D*将每个c<sub>i</sub>转换为一个数字
    - 对于每个c<sub>i</sub>，m<sub>i</sub> = [(c<sub>i</sub> – k) mod 26]
    - 根据*D*将每个m<sub>i</sub>转换为一个字母
    - 然后组合m<sub>0</sub>, m<sub>1</sub>,….,m<sub>l</sub>以产生原始消息m

移位密码中的模运算符确保了字母的循环，以便所有密文字母都被定义。为了说明这一点，考虑对单词“DOG”应用移位密码。

假设你均匀地选择了一个密钥值为17。字母“O”等于15。如果没有模运算，这个明文数字与密钥的加和将是一个密文数字32。然而，这个密文数字不能转换为一个密文字母，因为英文字母表只有26个字母。模运算确保了密文数字实际上是6（32 mod 26的结果），这等同于密文字母“G”。

使用密钥值为17加密单词“DOG”的整个过程如下：
* 消息 = DOG = D,O,G = 3,15,6* c<sub>0</sub> = [(3 + 17) 模 26] = [(20) 模 26] = 20 = U
* c<sub>1</sub> = [(15 + 17) 模 26] = [(32) 模 26] = 6 = G
* c<sub>2</sub> = [(6 + 17) 模 26] = [(23) 模 26] = 23 = X
* c = UGX

每个人都可以直观地理解移位密码是如何工作的，并且可能自己也会使用它。然而，为了提高你对密码学的了解，开始变得更加适应形式化是很重要的，因为方案将变得更加复杂。因此，移位密码的步骤被形式化了。

## 异或运算
<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

所有计算机数据在处理、存储和跨网络传输时都是以位为单位。应用于计算机数据的任何密码学方案也都是在位级别上操作的。

例如，假设你在电子邮件应用程序中输入了一封电子邮件。你应用的任何加密都不会直接作用于电子邮件的ASCII字符。相反，它是应用于电子邮件中的字母和其他符号的位表示。

对现代密码学来说，除了模运算外，需要理解的一个关键数学运算是**异或运算**，或者说“排他性或”运算。这个运算接受两个位作为输入，并产生另一个位作为输出。异或运算将简单地表示为"XOR"。如果两个位相同，则产生0；如果两个位不同，则产生1。你可以在下面看到四种可能性。

* 0 XOR 0 = 0
* 0 XOR 1 = 1
* 1 XOR 0 = 1
* 1 XOR 1 = 0

你可以通过将这两条消息的位对齐，并对每一对位进行异或运算，来对长度超过单个位的两条消息执行异或运算。

举例来说，假设你有一条消息 m<sub>1</sub> (01111001) 和一条消息 m<sub>2</sub> (01011001)。这两条消息的异或运算如下所示。

* m<sub>1</sub> XOR m<sub>2</sub> = 01111001 XOR 01011001 = 00100000

这个过程很直接。你首先对 m<sub>1</sub> 和 m<sub>2</sub> 的最左边的位进行异或运算。在这个例子中，那就是 0 XOR 0 = 0。然后你对从左边数的第二对位进行异或运算。在这个例子中，那就是 1 XOR 1 = 0。你继续这个过程，直到你对最右边的位进行了异或运算。
很容易看出，XOR（异或）操作是可交换的，即 m<sub>1</sub> XOR m<sub>2</sub> = m<sub>2</sub> XOR m<sub>1</sub>。此外，XOR操作也是可结合的。也就是说，(m<sub>1</sub> XOR m<sub>2</sub>) XOR m<sub>3</sub> = m<sub>1</sub> XOR (m<sub>2</sub> XOR m<sub>3</sub>)。
对于长度不同的两个字符串进行XOR操作，根据上下文，可能有不同的解释。我们在这里不涉及对不同长度字符串的XOR操作。

XOR操作等同于在除数为2时，对位加法执行模运算的特殊情况。以下结果可以看出等价性：

* (0 + 0) mod 2 = 0 XOR 0 = 0
* (1 + 0) mod 2 = 1 XOR 0 = 1
* (0 + 1) mod 2 = 0 XOR 1 = 1
* (1 + 1) mod 2 = 1 XOR 1 = 0

## 伪随机性
<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

在我们讨论随机和均匀变量时，我们在“随机”和“均匀”之间做了特定的区分。这种区分在实践中通常是保持的，当描述随机变量时。然而，在我们当前的上下文中，这种区分需要被放弃，“随机”和“均匀”被同义使用。我将在本节末尾解释原因。

首先，我们可以称长度为n的二进制字符串为**随机**（或**均匀**），如果它是由一个均匀变量S采样的结果，该变量给予这样长度n的每个二进制字符串相同的选择概率。

假设，例如，所有长度为8的二进制字符串的集合：{0000 0000,0000 0001,….,1111 1111}。（通常将8位字符串写成两个四位组，每个称为一个**半字节**。）让我们称这组字符串为**S<sub>8</sub>**。

根据上述定义，我们可以称长度为8的特定二进制字符串为随机（或均匀），如果它是由一个均匀变量S采样的结果，该变量给予**S<sub>8</sub>**中每个字符串相同的选择概率。鉴于集合**S<sub>8</sub>**包括2<sup>8</sup>个元素，采样时的选择概率必须是1/2<sup>8</sup>对集合中的每个字符串。

二进制字符串的随机性的一个关键方面是，它是根据选择它的过程来定义的。因此，任何特定二进制字符串的形式本身，不揭示其在选择上的随机性。

例如，许多人直观地认为像1111 1111这样的字符串不可能被随机选择。但这显然是错误的。
定义一个在所有长度为8的二进制字符串上的统一变量S，从集合**S<sub>8</sub>**中选择1111 1111的可能性与选择如0111 01001这样的字符串的可能性相同。因此，仅通过分析字符串本身，你无法判断一个字符串的随机性。

我们也可以谈论随机字符串，而不特指二进制字符串。例如，我们可能会谈到一个随机的十六进制字符串AF 02 82。在这种情况下，该字符串将从所有长度为6的十六进制字符串集合中随机选择。这等同于随机选择一个长度为24的二进制字符串，因为每个十六进制数字代表4位。

通常，“一个随机字符串”这个表达，没有特别的限定，指的是从所有长度相同的字符串集合中随机选择的一个字符串。这就是我上面所描述的。当然，一个长度为n的字符串也可以从一个不同的集合中随机选择。例如，一个只包含所有长度为n的字符串的子集，或者可能包含不同长度字符串的集合。然而，在这些情况下，我们不会称之为“随机字符串”，而是“从某个集合**S**中随机选择的一个字符串”。

在密码学中的一个关键概念是伪随机性。一个长度为n的**伪随机字符串**看起来*好像*是从一个统一变量S中抽样的结果，这个变量给**S<sub>n</sub>**中的每个字符串一个相等的选择概率。然而，实际上，这个字符串是从一个统一变量S'中抽样的结果，这个变量只在**S<sub>n</sub>**的一个子集上定义了一个概率分布——不一定是对所有可能结果都有相等概率的分布。这里的关键点是，即使你取了很多样本，也没有人能真正区分出样本是来自S还是S'。

假设，例如，一个随机变量S。它的结果集是**S<sub>256</sub>**，这是所有长度为256的二进制字符串的集合。这个集合有2<sup>256</sup>个元素。每个元素在抽样时都有相等的选择概率，1/2<sup>256</sup>。

另外假设一个随机变量S'。它的结果集只包括2<sup>128</sup>个长度为256的二进制字符串。它对这些字符串有一些概率分布，但这个分布不一定是均匀的。

假设我现在从S和S'中各取了1000个样本，并将两组结果给你。我告诉你哪组结果与哪个随机变量相关联。接下来，我从这两个随机变量中的一个取一个样本。但这次我不告诉你我抽样的是哪个随机变量。如果S'是伪随机的，那么理念是你猜对我抽样的随机变量的概率实际上并不比1/2更好。

通常，一个长度为n的伪随机字符串是通过随机选择一个大小为n - x的字符串产生的，其中x是一个正整数，并使用它作为扩展算法的输入。这个大小为n - x的随机字符串被称为**种子**。
伪随机字符串是使密码学实用化的关键概念。以流密码为例。在流密码中，一个随机选定的密钥被输入到一个扩展算法中，以产生一个更大的伪随机字符串。然后，这个伪随机字符串通过XOR操作与明文结合，产生密文。
如果我们无法为流密码产生这种类型的伪随机字符串，那么我们就需要一个与消息一样长的密钥来保证其安全性。在大多数情况下，这不是一个非常实用的选项。

本节讨论的伪随机性概念可以更正式地定义。它也扩展到其他上下文。但我们不需要在这里深入讨论。对于密码学的大部分内容，你真正需要直观理解的是随机字符串和伪随机字符串之间的区别。<sup>[2](#footnote2)</sup>

现在应该清楚为什么在我们的讨论中不再区分“随机”和“均匀”了。在实践中，每个人都使用伪随机这个术语来指示一个字符串，看起来**好像**它是从一个均匀变量S中抽样得到的结果。严格来说，我们应该称这样的字符串为“伪均匀”，采用我们之前的语言。由于“伪均匀”这个术语既笨拙又没有人使用，我们在这里为了清晰起见不引入它。相反，我们只是在当前上下文中不再区分“随机”和“均匀”。

## 注释
<chapterId>7cccd92c-15bc-5394-9024-af126988ecd7</chapterId>

[^1]: 我们可以使用前一节的术语准确定义这个声明。设一个均匀变量K有**K**作为其可能结果的集合。所以 Pr [K = 0] = 1/26, Pr [K = 1] = 1/26，依此类推。抽样一次均匀变量K以产生一个特定的密钥 [^1]。

[^2]: 如果对这些问题的更正式阐述感兴趣，你可以参考Katz和Lindell的*现代密码学导论*，特别是第3章 [^2]。

# 密码学的数学基础 II
<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

本章涵盖了密码学数学基础的一个更高级主题：数论。尽管数论对于对称密码学（如Rijndael Cipher）很重要，但它在公钥密码学设置中尤其重要。

如果你发现数论的细节繁琐，我建议首次阅读时进行高层次的阅读。你总是可以在以后的某个时候回来再看。

## 什么是数论？
<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>

你可能会将**数论**描述为研究整数和与整数工作的数学函数的性质的学科。

例如，考虑任意两个数a和N是**互质数**（或**相对质数**），如果它们的最大公约数等于1。假设现在有一个特定的整数N。有多少个小于N的整数与N互质？我们能对这个问题的答案做出一般性的陈述吗？这些是数论试图回答的典型类型的问题。
现代数论依赖于抽象代数的工具。**抽象代数**是数学的一个子学科，其主要分析对象是被称为代数结构的抽象对象。一个**代数结构**是一组元素，与一个或多个操作相结合，满足某些公理。通过代数结构，数学家可以通过抽象化细节来洞察特定数学问题。

抽象代数领域有时也被称为现代代数。你可能还会遇到**抽象数学**（或**纯数学**）的概念。这个后者术语并不是指抽象代数，而是指为了数学本身而进行的研究，而不仅仅是着眼于潜在的应用。

抽象代数中的集合可以处理许多类型的对象，从等边三角形上的保形变换到墙纸图案。对于数论，我们只考虑包含整数或与整数工作的函数的元素集合。

## 群
<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

数学中的一个基本概念是元素集合。集合通常由大括号表示，元素之间用逗号分隔。

例如，所有整数的集合是{…,-2,-1,0,1,2,…}。这里的省略号意味着某种模式在特定方向上继续。因此，所有整数的集合也包括3,4,5,6等，以及-3,-4,-5,-6等。所有整数的这个集合通常表示为ℤ。

另一个集合的例子是ℤ mod 11，或所有整数模11的集合。与整个集合ℤ相比，这个集合只包含有限数量的元素，即{0,1,…,9,10}。

一个常见的错误是认为集合ℤ mod 11实际上是{-10,-9,….,0,….,9,10}。但实际上不是这样，考虑到我们之前定义的模运算方式。任何通过模11减少的负整数都会映射到{0,1,….,9,10}。例如，表达式-2 mod 11映射到9，而表达式-27 mod 11映射到5。

数学中的另一个基本概念是二元运算。这是任何接受两个元素产生第三个元素的运算。例如，从基本算术和代数中，你会熟悉四个基本的二元运算：加法、减法、乘法和除法。

这两个基本数学概念，集合和二元运算，用于定义群的概念，这是抽象代数中最基本的结构。

具体来说，假设某个二元运算◌。此外，假设装备了该运算的某个元素集合**S**。这里的“装备”意味着可以在集合**S**中的任意两个元素之间执行操作◌。

那么，组合〈**S**, ◌〉就是一个**群**，如果它满足四个特定条件，被称为群公理。

1. 对于**S**中的任何元素a和b，a ◌ b也是**S**的一个元素。这被称为**封闭性条件**。
2. 对于任何属于**S**的元素a、b和c，都有(a ◌ b) ◌ c = a ◌ (b ◌ c)。这被称为**结合律**。
3. 在**S**中存在一个唯一的元素e，使得对于**S**中的每个元素a，以下等式成立：e ◌ a = a ◌ e = a。由于只有一个这样的元素e，它被称为**单位元**。这个条件被称为**单位律**。
4. 对于**S**中的每个元素a，存在一个元素b在**S**中，使得以下等式成立：a ◌ b = b ◌ a = e，其中e是单位元。这里的元素b被称为**逆元素**，通常表示为a<sup>-1</sup>。这个条件被称为**逆元律**或**可逆性条件**。

让我们进一步探索群的概念。用ℤ表示所有整数的集合。这个集合与标准加法结合，或〈ℤ, +〉，显然符合群的定义，因为它满足上述四个公理。

1. 对于任何属于ℤ的元素x和y，x + y也是ℤ的元素。所以〈ℤ, +〉满足封闭性条件。
2. 对于任何属于ℤ的元素x、y和z，(x + y) + z = x + (y + z)。所以〈ℤ, +〉满足结合律。
3. 在〈ℤ, +〉中存在一个单位元，即0。对于ℤ中的任何x，特别是满足：0 + x = x + 0 = x。所以〈ℤ, +〉满足单位律。
4. 最后，对于ℤ中的每个元素x，存在一个y使得x + y = y + x = 0。例如，如果x是10，那么y将是-10（如果x是0，y也是0）。所以〈ℤ, +〉满足逆元律。

重要的是，整数集合与加法构成群，并不意味着它与乘法构成群。你可以通过测试〈ℤ, •〉是否满足四个群公理来验证这一点（其中•表示标准乘法）。

前两个公理显然成立。此外，在乘法下，元素1可以作为单位元。任何整数x乘以1，特别是产生x。然而，〈ℤ, •〉不满足逆元律。也就是说，对于ℤ中的每个x，不存在一个唯一的元素y使得x • y = 1。

例如，假设x = 22。从集合ℤ中哪个值y与x相乘会产生单位元1？1/22的值可以，但这不在集合ℤ中。实际上，对于任何整数x，除了1和-1的值（其中y必须是1和-1），你都会遇到这个问题。
如果我们允许我们的集合包含实数，那么我们的问题大部分都会消失。对于集合中的任何元素x，乘以1/x会得到1。由于分数包含在实数集中，因此每个实数都可以找到一个逆元素。零是个例外，因为任何与零的乘法永远不会得到单位元素1。因此，非零实数集配备乘法确实是一个群。

有些群满足第五个一般条件，称为**交换律条件**。该条件如下：

* 假设有一个群G，它有一个集合**S**和一个二元运算符◌。假设a和b是**S**的元素。如果对于**S**中的任意两个元素a和b都有a ◌ b = b ◌ a，那么G满足交换律条件。

任何满足交换律条件的群被称为**交换群**，或**阿贝尔群**（以Niels Henrik Abel命名）。很容易验证，实数集合通过加法和整数集合通过加法都是阿贝尔群。整数集通过乘法不是群，因此根本不能是阿贝尔群。相比之下，非零实数集通过乘法也是一个阿贝尔群。

你应该注意两个关于符号的重要约定。首先，“+”或“x”符号经常被用来表示群运算，即使元素实际上不是数字。在这些情况下，你不应将这些符号解释为标准的算术加法或乘法。相反，它们是与这些算术运算仅有抽象相似性的操作。

除非你特指算术加法或乘法，使用如◌和◊这样的符号来表示群运算更为简单，因为这些符号没有很深的文化内涵。

其次，出于与“+”和“x”经常用于表示非算术运算相同的原因，群的单位元素经常用“0”和“1”来表示，即使这些群中的元素不是数字。除非你指的是带有数字的群的单位元素，使用更中性的符号如“e”来表示单位元素会更简单。

数学中许多不同且非常重要的值集合配备了某些二元运算是群。然而，密码学应用只与整数集合或至少由整数描述的元素一起工作，即在数论的领域内。因此，在密码学应用中不使用除整数以外的实数集。

最后，我们通过提供一个可以“由整数描述”的元素的例子来结束，尽管它们不是整数。一个好例子是椭圆曲线上的点。尽管椭圆曲线上的任何点显然不是整数，但这样的点确实由两个整数描述。

例如，椭圆曲线对于比特币至关重要。任何标准的比特币私钥和公钥对都是从以下椭圆曲线定义的点集中选取的：x<sup>3</sup> + 7 = y<sup>2</sup> mod 2<sup>256</sup> – 232 – 29 – 28 – 27 – 26 - 24 - 1（小于2<sup>256</sup>的最大质数）。x坐标是私钥，y坐标是你的公钥。
在比特币中的交易通常以某种方式锁定输出到一个或多个公钥。然后，可以通过使用相应的私钥制作数字签名来解锁这些交易的价值。

## 循环群
<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

我们可以区分的一个主要特点是**有限群**和**无限群**之间的区别。前者有有限数量的元素，而后者有无限数量的元素。任何有限群中的元素数量被称为**群的阶**。所有涉及使用群的实用密码学都依赖于有限（数论）群。

在公钥密码学中，一类特定的有限阿贝尔群，称为循环群，特别重要。为了理解循环群，我们首先需要理解群元素幂运算的概念。

假设有一个群G，带有群操作◌，并且a是G的一个元素。那么表达式a<sup>n</sup>应该被解释为元素a与其自身结合了总共n - 1次。例如，a<sup>2</sup>表示a ◌ a，a<sup>3</sup>表示a ◌ a ◌ a，依此类推。（注意，这里的幂运算不一定是标准算术意义上的幂运算。）

让我们来看一个例子。假设G = 〈ℤ mod 7,+〉，并且我们的a值等于4。在这种情况下，a<sup>2</sup> = [4 + 4 mod 7] = [8 mod 7] = 1 mod 7。另外，a<sup>4</sup>将表示[4 + 4 + 4 + 4 mod 7] = [16 mod 7] = 2 mod 7。

一些阿贝尔群有一个或多个元素，可以通过持续的幂运算产生所有其他群元素。这些元素被称为**生成元**或**原始元素**。

这类群的一个重要类别是〈ℤ* mod N, •〉，其中N是一个质数。这里的符号ℤ*意味着该群包含所有小于N的非零正整数。因此，这样的群总是有N - 1个元素。

例如，考虑G = 〈ℤ* mod 11, •〉。这个群有以下元素：{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}。这个群的阶是10（确实等于11 - 1）。

让我们探索从这个群中指数化元素2。下面显示了直到2<sup>12</sup>的计算。请注意，在等式的左侧，指数指的是群元素的幂运算。在我们特定的例子中，这确实涉及到等式右侧的算术幂运算（但它也可能涉及到例如加法）。为了澄清，我已经写出了重复操作，而不是等式右侧的指数形式。

* 2<sup>1</sup> = 2 mod 11
* 2<sup>2</sup> = 2 · 2 mod 11 = 4 mod 11
* 2<sup>3</sup> = 2 · 2 · 2 对 11 取模 = 8 对 11 取模
* 2<sup>4</sup> = 2 · 2 · 2 · 2 对 11 取模 = 16 对 11 取模 = 5 对 11 取模
* 2<sup>5</sup> = 2 · 2 · 2 · 2 · 2 对 11 取模 = 32 对 11 取模 = 10 对 11 取模
* 2<sup>6</sup> = 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 64 对 11 取模 = 9 对 11 取模
* 2<sup>7</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 128 对 11 取模 = 7 对 11 取模
* 2<sup>8</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 256 对 11 取模 = 3 对 11 取模
* 2<sup>9</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 512 对 11 取模 = 6 对 11 取模
* 2<sup>10</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 1024 对 11 取模 = 1 对 11 取模
* 2<sup>11</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 2048 对 11 取模 = 2 对 11 取模
* 2<sup>12</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 对 11 取模 = 4096 对 11 取模 = 4 对 11 取模

如果你仔细观察，可以看到对元素 2 进行指数运算会按照以下顺序循环通过所有 〈ℤ* 对 11 取模, •〉 的元素：2, 4, 8, 5, 10, 9, 7, 3, 6, 1。在 2<sup>10</sup> 之后，继续对元素 2 进行指数运算会再次循环通过所有元素，并且顺序相同。因此，元素 2 是 〈ℤ* 对 11 取模, •〉 中的一个生成元。

虽然 〈ℤ* 对 11 取模, •〉 有多个生成元，但并非该群的所有元素都是生成元。例如，考虑元素 3。运行前 10 次指数运算，不展示繁琐的计算，得到以下结果：

* 3<sup>1</sup> = 3 对 11 取模
* 3<sup>2</sup> = 9 对 11 取模
* 3<sup>3</sup> = 5 对 11 取模
* 3<sup>4</sup> = 4 对 11 取模
* 3<sup>5</sup> = 1 (mod 11)
* 3<sup>6</sup> = 3 (mod 11)
* 3<sup>7</sup> = 9 (mod 11)
* 3<sup>8</sup> = 5 (mod 11)
* 3<sup>9</sup> = 4 (mod 11)
* 3<sup>10</sup> = 1 (mod 11)

在遍历所有在 〈ℤ* mod 11, •〉 中的值时，3的指数运算仅产生了一部分值：3, 9, 5, 4, 和 1。在第五次指数运算后，这些值开始重复。

我们现在可以将**循环群**定义为至少有一个生成元的任何群。也就是说，至少有一个群元素，通过指数运算可以产生所有其他群元素。

您可能已经在上面的例子中注意到，2<sup>10</sup> 和 3<sup>10</sup> 都等于 1 (mod 11)。实际上，虽然我们不进行计算，但任何在群 〈ℤ* mod 11, •〉 中的元素的10次指数运算都将产生 1 (mod 11)。为什么会这样呢？

这是一个重要的问题，但解答它需要一些工作。

首先，假设有两个正整数 a 和 N。数论中的一个重要定理声明，a 有一个模 N 的乘法逆元（即，一个整数 b 使得 a • b = 1 (mod N)）当且仅当 a 和 N 之间的最大公约数等于 1。也就是说，如果 a 和 N 是互质的。

因此，对于任何装备了模 N 乘法的整数群，只有与 N 互质的较小整数被包含在集合中。我们可以用 ℤ<sup>c</sup> mod N 来表示这个集合。

例如，假设 N 是 10。只有整数 1,3,7, 和 9 与 10 互质。所以集合 ℤ<sup>c</sup> mod 10 只包括 {1,3,7,9}。使用 1 到 10 之间的任何其他整数，您无法创建一个模 10 的整数乘法群。对于这个特定的群，逆元是对 1 和 9，以及 3 和 7。

在 N 本身是质数的情况下，从 1 到 N - 1 的所有整数都与 N 互质。因此，这样的群的阶为 N - 1。使用我们之前的符号，ℤ<sup>c</sup> mod N 在 N 是质数时等于 ℤ* mod N。我们之前示例中选择的群，〈ℤ* mod 11, •〉，是这类群的一个特例。

接下来，函数 φ(N) 计算直到一个数 N 的互质数的数量，被称为**欧拉的 Phi 函数**。<sup>[1](#footnote1)</sup> 根据**欧拉定理**，每当两个整数 a 和 N 是互质的，以下成立：

* a<sup>φ(N)</sup> mod N = 1 (mod N)
这对于群类〈ℤ* mod N, •〉有一个重要的含义，其中N是一个质数。对于这些群，群元素的指数运算代表了算术指数运算。也就是说，a<sup>φ(N)</sup> mod N代表了算术操作a<sup>φ(N)</sup> mod N。由于这些乘法群中的任何元素a与N互质，这意味着a<sup>φ(N)</sup> mod N = a<sup>N – 1</sup> mod N = 1 mod N。
欧拉定理是一个非常重要的结果。首先，它意味着〈ℤ* mod N, •〉中的所有元素只能通过指数运算循环通过一个数值，该数值能被N – 1整除。在〈ℤ* mod 11, •〉的情况下，这意味着每个元素只能循环通过2、5或10个元素。任何元素通过指数运算循环通过的群值被称为**元素的阶**。一个阶等同于群阶的元素是一个生成元。

此外，欧拉定理意味着我们总是可以知道对于任何群〈ℤ* mod N, •〉其中N是质数的a<sup>N – 1</sup> mod N的结果。不管实际计算有多复杂，都是如此。

例如，假设我们的群是ℤ* mod 160,481,182（其中160,481,182确实是一个质数）。我们知道所有1到160,481,181的整数必须是这个群的元素，并且φ(n) = 160,481,181。尽管我们无法完成所有计算步骤，我们知道诸如514<sup>160,481,181</sup>、2,005<sup>160,481,181</sup>和256,212<sup>160,481,181</sup>的表达式必须都等于1 mod 160,481,182。

## 领域
<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

群是抽象代数中的基本代数结构，但还有更多。你需要熟悉的唯一其他代数结构是域的概念，特别是有限域的概念。这种代数结构经常用于密码学中，例如在高级加密标准中。后者是你在实践中会遇到的主要对称加密方案。

域是从群的概念派生出来的。具体来说，**域**是一个装备了两个二元运算符◌和◊的元素集合**S**，满足以下条件：

1. 装备了◌的集合**S**是一个阿贝尔群。
2. 对于“非零”元素，装备了◊的集合**S**是一个阿贝尔群。
3. 装备了这两个运算符的集合**S**满足所谓的分配条件：假设a、b和c是**S**的元素。那么当a ◌ (b ◊ c) = a ◌ b ◊ a ◌ c时，装备了这两个运算符的集合**S**满足分配律。
请注意，与群体一样，字段的定义非常抽象。它对**S**中元素的类型或操作◌和◊没有任何声明。它只是声明，字段是具有两种操作的元素集合，这两种操作满足上述三个条件。（第二个阿贝尔群中的“零”元素可以被抽象地解释。）

那么，一个字段的例子可能是什么呢？一个很好的例子是集合 ℤ mod 7，或者定义在标准加法（代替上面的◌）和标准乘法（代替上面的◊）之上的{0,1,…,7}。

首先，ℤ mod 7满足作为加法阿贝尔群的条件，如果你只考虑非零元素，它也满足作为乘法阿贝尔群的条件。其次，集合与两个操作符的组合满足分配条件。

通过使用一些特定的值来探索这些声明是有教育意义的。让我们取实验值5、2和3，一些从集合ℤ mod 7中随机选取的元素，来检查字段〈ℤ mod 7, +, •〉。我们将按顺序使用这三个值，根据需要探索特定条件。

让我们首先探索配备加法的ℤ mod 7是否是一个阿贝尔群。

1. 封闭性条件：让我们取5和2作为我们的值。在这种情况下，[5 + 2] mod 7 = 7 mod 7 = 0。这确实是ℤ mod 7的一个元素，所以结果与封闭性条件一致。
2. 结合性条件：让我们取5、2和3作为我们的值。在这种情况下，[(5 + 2) + 3] mod 7 = [5 + (2 + 3)] mod 7 = 10 mod 7 = 3。这与结合性条件一致。
3. 同一性条件：让我们取5作为我们的值。在这种情况下，[5 + 0] mod 7 = [0 + 5] mod 7 = 5。所以0看起来是加法的同一元素。
4. 逆元条件：考虑5的逆元。需要满足[5 + d] mod 7 = 0的条件，对于某个值d。在这种情况下，来自ℤ mod 7的唯一值满足这个条件是2。
5. 交换性条件：让我们取5和3作为我们的值。在这种情况下，[5 + 3] mod 7 = [3 + 5] mod 7 = 1。这与交换性条件一致。

配备加法的集合ℤ mod 7显然看起来是一个阿贝尔群。现在让我们探索配备乘法的ℤ mod 7对于所有非零元素是否是一个阿贝尔群。

1. 封闭性条件：让我们取5和2作为我们的值。在这种情况下，[5 • 2] mod 7 = 10 mod 7 = 3。这也是ℤ mod 7的一个元素，所以结果与封闭性条件一致。
2. 结合律条件：我们取5、2和3作为我们的值。在这种情况下，[(5 • 2) • 3] mod 7 = [5 • (2 • 3)] mod 7 = 30 mod 7 = 2。这与结合律条件一致。
3. 单位元条件：我们取5作为我们的值。在这种情况下，[5 • 1] mod 7 = [1 • 5] mod 7 = 5。所以1看起来是乘法的单位元。
4. 逆元条件：考虑5的逆元。需要满足[5 • d] mod 7 = 1，对某个值d来说。满足此条件的ℤ mod 7中的唯一值是3。这与逆元条件一致。
5. 交换律条件：我们取5和3作为我们的值。在这种情况下，[5 • 3] mod 7 = [3 • 5] mod 7 = 15 mod 7 = 1。这与交换律条件一致。

集合ℤ mod 7在与非零元素的加法或乘法结合时，显然似乎满足成为阿贝尔群的规则。

最后，这个集合与两种运算符结合似乎满足分配律条件。我们取5、2和3作为我们的值。我们可以看到[5 • (2 + 3)] mod 7 = [5 • 2 + 5 • 3] mod 7 = 25 mod 7 = 4。

我们现在已经看到，配备加法和乘法的ℤ mod 7在用特定值测试时满足有限域的公理。当然，我们也可以一般地展示，但在这里不会这样做。

一个关键区别是两种类型的域：有限域和无限域。

**无限域**涉及一个集合**S**无限大的域。实数集ℝ配备加法和乘法是无限域的一个例子。**有限域**，也称为**伽罗瓦域**，是一个集合**S**有限的域。我们上面的例子〈ℤ mod 7, +, •〉是一个有限域。

在密码学中，我们主要对有限域感兴趣。一般来说，可以证明，如果某个元素集合**S**有p<sup>m</sup>个元素，其中p是一个质数，m是大于或等于1的正整数，那么存在一个有限域。换句话说，如果某个集合**S**的阶是一个质数（p<sup>m</sup>其中m = 1）或某个质数的幂（p<sup>m</sup>其中m > 1），那么你可以找到两个运算符◌和◊，使得满足域的条件。

如果某个有限域的元素数量是一个质数，则称为**素域**。如果有限域中的元素数量是一个质数的幂，则该域称为**扩展域**。在密码学中，我们对素域和扩展域都感兴趣。<sup>[2](#footnote2)</sup>
在密码学中，我们感兴趣的主要素数领域是所有整数集通过某个素数调制，并且运算符是标准加法和乘法的领域。这类有限域包括 ℤ mod 2、ℤ mod 3、ℤ mod 5、ℤ mod 7、ℤ mod 11、ℤ mod 13 等等。对于任何素数域 ℤ mod p，该域的整数集合如下：{0,1,….,p – 2, p – 1}。
在密码学中，我们还对扩展域感兴趣，特别是具有 2<sup>m</sup> 元素的任何域，其中 m > 1。这些有限域例如在 Rijndael 密码中使用，该密码构成了高级加密标准的基础。虽然素数域相对直观，但这些基于 2 的扩展域对不熟悉抽象代数的人来说可能并不直观。

首先，确实任何具有 2<sup>m</sup> 元素的整数集都可以分配两个运算符，使它们的组合成为一个域（只要 m 是一个正整数）。然而，仅仅因为一个域存在并不一定意味着它易于发现或特别适用于某些应用。

事实证明，在密码学中特别适用的 2<sup>m</sup> 扩展域是那些定义在特定多项式表达式集合上的，而不是某些整数集合。

例如，假设我们想要一个具有 2<sup>3</sup>（即，8）元素的扩展域。虽然可能有许多不同的集合可以用于该大小的域，但其中一个集合包括所有形式为 a<sub>2</sub>x<sup>2</sup> + a<sub>1</sub>x + a<sub>0</sub> 的唯一多项式，其中每个系数 a<sub>i</sub> 要么是 0 要么是 1。因此，这个集合 **S** 包括以下元素：

1. 0：当 a<sub>2</sub> = 0, a<sub>1</sub> = 0, 且 a<sub>0</sub> = 0 的情况。
2. 1：当 a<sub>2</sub> = 0, a<sub>1</sub> = 0, 且 a<sub>0</sub> = 1 的情况。
3. x：当 a<sub>2</sub> = 0, a<sub>1</sub> = 1, 且 a<sub>0</sub> = 0 的情况。
4. x + 1：当 a<sub>2</sub> = 0, a<sub>1</sub> = 1, 且 a<sub>0</sub> = 1 的情况。
5. x<sup>2</sup>：当 a<sub>2</sub>= 1, a<sub>1</sub> = 0, 且 a<sub>0</sub> = 0 的情况。
6. x<sup>2</sup> + 1：当 a<sub>2</sub> = 1, a<sub>1</sub> = 0, 且 a<sub>0</sub> = 1 的情况。
7. x<sup>2</sup> + x：这种情况下，a<sub>2</sub> = 1，a<sub>1</sub> = 1，且 a<sub>0</sub> = 0。8. x<sup>2</sup> + x + 1：这种情况下，a<sub>2</sub> = 1，a<sub>1</sub> = 1，且 a<sub>0</sub> = 1。

因此 **S** 将是集合 {0,1,x,x + 1, x<sup>2</sup>,x<sup>2</sup> + 1, x<sup>2</sup> + x, x<sup>2</sup> + x + 1}。可以定义哪两种运算在这个元素集合上以确保它们的组合是一个域？

集合 S 上的第一种运算 (◌) 可以定义为标准的多项式加法模 2。你所要做的就是像平常一样加多项式，然后对结果多项式的每个系数应用模 2 运算。这里有一些例子：

* [(x<sup>2</sup>) + (x<sup>2</sup> + x + 1)] mod 2 = [2x<sup>2</sup> + x + 1] mod 2 = x + 1
* [(x<sup>2</sup> + x) + (x)] mod 2 = [x<sup>2</sup> + 2x] mod 2 = x<sup>2</sup>
* [(x + 1) + (x<sup>2</sup> + x + 1)] mod 2 = [x<sup>2</sup> + 2x + 2] mod 2 = x<sup>2</sup> + 1

集合 S 上需要创建域的第二种运算 (◌) 更为复杂。它是一种乘法，但不是算术中的标准乘法。相反，你必须将每个元素视为一个向量，并理解该运算为这两个向量模一个不可约多项式的乘法。

首先让我们来看看不可约多项式的概念。**不可约多项式**是指不能被分解的多项式（就像质数不能被分解成除了1和质数本身之外的组成部分一样）。就我们的目的而言，我们对整数集合不可约的多项式感兴趣。（注意，你可能能够通过例如实数或复数来分解某些多项式，即使你不能使用整数来分解它们。）

例如，考虑多项式 x<sup>2</sup> - 3x + 2。这可以重写为 (x – 1)(x – 2)。因此，这不是不可约的。现在考虑多项式 x<sup>2</sup> + 1。仅使用整数，没有办法进一步分解这个表达式。因此，这是一个关于整数的不可约多项式。
接下来，让我们来讨论向量乘法的概念。我们不会深入探讨这个话题，你只需要理解一个基本规则：任何向量除法都可以进行，只要被除数的次数高于或等于除数的次数。如果被除数的次数低于除数的次数，那么被除数就不能再被除数除。

例如，考虑表达式 x<sup>6</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup>。这显然可以进一步简化，因为被除数的次数，6，高于除数的次数，5。现在考虑表达式 x<sup>5</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup>。这也可以进一步简化，因为被除数的次数，5，和除数的次数，5，是相等的。

然而，现在考虑表达式 x<sup>4</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup>。这不会进一步简化，因为被除数的次数，4，低于除数的次数，5。

基于这些信息，我们现在准备找到集合 {0,1,x,x + 1,x<sup>2</sup>,x<sup>2</sup> + 1,x<sup>2</sup> + x,x<sup>2</sup> + x + 1} 的第二个运算。

我已经说过，第二个运算应该被理解为模某个不可约多项式的向量乘法。这个不可约多项式应该确保第二个运算在 **S** 上定义了一个阿贝尔群，并且与分配条件一致。那么，这个不可约多项式应该是什么呢？

由于集合中的所有向量的次数都是2或更低，不可约多项式应该是3次的。如果集合中两个向量的任何乘法产生的多项式次数为3或更高，我们知道模3次的多项式总是产生2次或更低次的多项式。这是因为任何3次或更高次的多项式总是可以被一个3次的多项式除尽。此外，作为除数的多项式必须是不可约的。

事实证明，有几个3次的不可约多项式我们可以用作我们的除数。这些多项式与我们的集合S以及模2加法结合，定义了不同的域。这意味着在使用加密学中的扩展域 2<sup>m</sup> 时，你有多个选项。

以我们的例子为例，假设我们选择多项式 x<sup>3</sup> + x + 1。这确实是不可约的，因为你不能使用整数将其分解。此外，它将确保任何两个元素的乘法都会产生2次或更低次的多项式。
让我们通过一个例子来演示第二种操作，使用多项式 x<sup>3</sup> + x + 1 作为除数来说明它是如何工作的。假设你将集合 **S** 中的元素 x<sup>2</sup> + 1 与 x<sup>2</sup> + x 相乘。然后，我们需要计算表达式 [(x<sup>2</sup> + 1) • (x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1。这可以简化如下：
* [(x<sup>2</sup> + 1) • (x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 =
* [x<sup>2</sup> • x<sup>2</sup> + x<sup>2</sup> • x + 1 • x<sup>2</sup> + 1 • x] mod x<sup>3</sup> + x + 1 = 
* [x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x] mod x<sup>3</sup> + x + 1

我们知道 [x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x] mod x<sup>3</sup> + x + 1 可以被简化，因为被除数的次数（4）高于除数的次数（3）。

首先，你可以看到表达式 x<sup>3</sup> + x + 1 能够整除 x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x 共 x 次。你可以通过将 x<sup>3</sup> + x + 1 乘以 x 验证这一点，即 x<sup>4</sup> + x<sup>2</sup> + x。由于后者的次数与被除数相同，即 4，我们知道这是可行的。你可以按如下方式计算这次除法的余数：

* [(x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x) – (x<sup>4</sup> + x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 = 
* [x<sup>3</sup>] mod x<sup>3</sup> + x + 1 =
* x<sup>3</sup>

所以，在将 x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x 除以 x<sup>3</sup> + x + 1 共 x 次后，我们得到了余数 x<sup>3</sup>。这个余数还能进一步被 x<sup>3</sup> + x + 1 除吗？
直观上，我们可能会认为 \(x^3\) 不能再被 \(x^3 + x + 1\) 整除，因为后者看起来更大。然而，记住我们之前关于向量除法的讨论。只要被除数的次数大于或等于除数的次数，表达式就可以进一步简化。具体来说，表达式 \(x^3 + x + 1\) 可以准确地进入 \(x^3\) 一次。余数的计算如下：
\[
[(x^3) – (x^3 + x + 1)] \mod x^3 + x + 1 = 
[x + 1] \mod x^3 + x + 1 = 
x + 1
\]

你可能会想，为什么 \((x^3) – (x^3 + x + 1)\) 的结果是 \(x + 1\) 而不是 \(- x – 1\)。记住，我们的第一个操作是定义在模 2 下的。因此，两个向量的减法得到的结果与两个向量的加法完全相同。

总结一下 \(x^2 + 1\) 和 \(x^2 + x\) 的乘法：当你将这两个项相乘时，你得到一个4次多项式，\(x^4 + x^3 + x^2 + x\)，需要模 \(x^3 + x + 1\) 进行约简。这个4次多项式可以被 \(x^3 + x + 1\) 准确地除 \(x + 1\) 次。将 \(x^4 + x^3 + x^2 + x\) 除以 \(x^3 + x + 1\) 准确地 \(x + 1\) 次后的余数是 \(x + 1\)。这确实是我们集合 \(\{0,1,x,x + 1,x^2,x^2 + 1,x^2 + x,x^2 + x + 1\}\) 中的一个元素。

为什么基于多项式集合的二进制扩展域，如上例所示，对密码学有用呢？原因是你可以将这些集合中多项式的系数，不是 0 就是 1，视为具有特定长度的二进制字符串的元素。例如，我们上面的例子中的集合 **S**，可以被视为包含所有长度为3的二进制字符串的集合（000到111）。然后，对 **S** 的操作，也可以用来对这些二进制字符串执行操作并产生相同长度的二进制字符串。

## 实践中的抽象代数
<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>
尽管讨论的语言正式且抽象，但群的概念不应该太难以理解。它只是一组元素以及一个二元运算，其中这些元素执行该二元运算满足四个一般条件。阿贝尔群（Abelian group）只是多了一个被称为交换律的额外条件。而循环群（cyclic group），则是一种特殊的阿贝尔群，即拥有一个生成元的群。域（field）仅仅是从基本群概念派生出的更复杂的结构。

但如果你是一个实际操作倾向的人，你可能会在这一点上想知道：谁在乎呢？知道一组元素和一个运算符构成一个群，甚至是一个阿贝尔群或循环群，有什么实际意义吗？知道某物是一个域有意义吗？

不深入太多细节，答案是“是的”。群最初是在19世纪由法国数学家埃瓦里斯特·伽罗瓦（Evariste Galois）创造的。他用它们来得出关于解高于五次的多项式方程的结论。

从那时起，群的概念帮助解决了数学和其他领域的许多问题。例如，物理学家穆雷-盖尔曼（Murray-Gellman）能够在实验中实际观察到一个粒子之前预测其存在。另一个例子，化学家使用群论来分类分子的形状。数学家甚至使用群的概念来得出关于像墙纸这样具体的东西的结论！

本质上，展示一组元素和某些运算符构成一个群，意味着你所描述的具有特定的对称性。不是常识中的对称性，而是一种更抽象的形式。这可以为特定的系统和问题提供重要的洞见。抽象代数中更复杂的概念只是给我们提供了额外的信息。

最重要的是，通过它们在密码学中的应用，特别是公钥密码学中，你将看到数论群和域在实践中的重要性。例如，我们已经在讨论域时看到，如何在Rijndael Cipher中使用扩展域。我们将在*第5章*中详细讨论这个例子。

## 进一步探索

<chapterId>ab51038d-82bd-5c5d-a759-276cfbf7fbce</chapterId>

对于抽象代数的进一步讨论，我推荐Socratica的优秀视频系列。特别推荐以下视频：“什么是抽象代数？”，“群定义（扩展）”，“环定义（扩展）”，和“域定义（扩展）”。这四个视频将为你提供上述讨论的一些额外洞见。（我们没有讨论环，但域只是一种特殊类型的环。）

对于现代数论的进一步讨论，你可以参考许多关于密码学的高级讨论。我会推荐Jonathan Katz和Yehuda Lindell的《现代密码学导论》或Christof Paar和Jan Pelzl的《理解密码学》进行进一步的讨论。

### 注释
[^1]: 该函数的工作原理如下。任何整数N都可以分解为质数的乘积。假设一个特定的N如下分解：p<sub>1</sub><sup>e1</sup> • p<sub>2</sub><sup>e2</sup> …. • p<sub>m</sub><sup>em</sup>，其中所有的p都是质数，所有的e都是大于或等于1的整数。那么，φ(N) = Sum<sub>i=1…m</sub>[p<sub>i</sub><sup>ei</sup> – p<sub>i</sub><sup>ei - 1</sup>] [^1]。
[^2]: 扩展域变得非常反直觉。它们不是有整数元素，而是有多项式集合。此外，任何操作都是在某个不可约多项式下进行模运算的 [^2]。

[^3]: 见 [YouTube 视频](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be) [^3]。

[^4]: Socratica，《抽象代数》(https://www.socratica.com/subject/abstract-algebra) [^4]。

[^5]: Katz 和 Lindell，《现代密码学导论》，第二版，2015年（CRC Press: Boca Raton, FL）。Paar 和 Pelzl，《理解密码学》，2010年（Springer-Verlag: Berlin）[^5]。


# 对称密码学
<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

密码学的两大主要分支之一是对称密码学。它包括加密方案以及与认证和完整性有关的方案。直到1970年代，所有的密码学都会包括对称加密方案。

主要讨论从查看对称加密方案开始，并对流密码和块密码进行关键区分。然后，我们转向消息认证码，这是确保消息完整性和真实性的方案。最后，我们探讨如何结合对称加密方案和消息认证码以确保安全通信。

本章顺便讨论了实践中各种对称密码学方案。下一章将提供实践中使用流密码和块密码加密的详细阐述，即RC4和AES。

在开始讨论对称密码学之前，我想简要地对本章及后续章节中的Alice和Bob插图做一些说明。


## Alice 和 Bob
<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

在阐述密码学原理时，人们常常依赖于涉及Alice和Bob的例子。我也将这样做。

特别是如果你是密码学的新手，重要的是要意识到，这些关于Alice和Bob的例子只是为了在简化的环境中说明密码学原理和构造。然而，这些原理和构造适用于更广泛的现实生活情境。

以下是关于密码学中涉及Alice和Bob的例子需要记住的五个关键点：

1. 它们可以轻松地翻译成涉及其他类型参与者（如公司或政府组织）的例子。
2. 它们可以轻松地扩展到包括三个或更多参与者。
3. 在示例中，Bob和Alice通常是创建每条消息并对该消息应用加密方案的积极参与者。但实际上，电子通信大多是自动化的。例如，当您使用传输层安全协议访问网站时，加密工作通常完全由您的计算机和Web服务器处理。4. 在电子通信的背景下，通过通信渠道发送的“消息”通常是TCP/IP数据包。这些数据包可以属于电子邮件、Facebook消息、电话对话、文件传输、网站、软件上传等。它们并不是传统意义上的消息。尽管如此，密码学家通常会简化这一现实，比如说消息就是一封电子邮件。
5. 示例通常关注电子通信，但也可以扩展到传统的通信形式，如信件。

## 对称加密方案
<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

我们可以将**对称加密方案**宽泛地定义为包含三种算法的任何加密方案：

1. **密钥生成算法**，用于生成私钥。
2. **加密算法**，将私钥和明文作为输入，输出密文。
3. **解密算法**，将私钥和密文作为输入，输出原始明文。

通常，无论是对称还是非对称加密方案，都提供了基于核心算法的加密模板，而不是确切的规范。

例如，考虑Salsa20，一种对称加密方案。它可以使用128位和256位密钥长度。关于密钥长度的选择影响算法的一些细节（确切地说是算法中的轮数）。

但人们不会说，使用128位密钥的Salsa20与使用256位密钥的Salsa20是不同的加密方案。核心算法保持不变。只有当核心算法改变时，我们才真正谈论两种不同的加密方案。

对称加密方案通常在两种情况下非常有用：（1）两个或多个代理在远距离通信并希望保密他们通信内容的情况；以及（2）一个代理希望随时间保密消息内容的情况。

您可以在下面的*图1*中看到情况（1）的描述。Bob想要跨越一定距离发送消息M给Alice，但不希望其他人能够阅读该消息。

Bob首先使用私钥K加密消息M。然后，他将密文C发送给Alice。一旦Alice收到密文，她就可以使用密钥K解密它并阅读明文。有了一个好的加密方案，任何截获密文C的攻击者都不应该能够了解到关于消息M的任何实质性信息。

您可以在下面的*图2*中看到情况（2）的描述。Bob想要阻止其他人查看某些信息。一个典型的情况可能是Bob是一名员工，他在自己的计算机上存储敏感数据，这些数据不应该被外人或他的同事阅读。
鲍勃在时间T<sub>0</sub>用密钥K加密消息M，生成密文C。在时间T<sub>1</sub>，他需要再次获取该消息，并使用密钥K解密密文C。在此期间，任何偶然接触到密文C的攻击者都不应该能够从中推断出关于M的任何重要信息。
*图1：空间上的保密性*

![图1：空间上的保密性](assets/Figure4-1.webp "图1：空间上的保密性")

*图2：时间上的保密性*

![图2：时间上的保密性](assets/Figure4-2.webp "图2：时间上的保密性")

## 一个例子：移位密码
<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

在第2章中，我们遇到了移位密码，这是一个非常简单的对称加密方案的例子。让我们在这里再次审视它。

假设有一个字典*D*，它将英文字母表中的所有字母按顺序与数字集{0,1,2…,25}相对应。假设有一组可能的消息**M**。然后，移位密码被定义为如下的加密方案：

- 从可能的密钥集**K**中随机选择一个密钥k，其中**K** = {0,1,2,…,25}
- 按如下方式加密消息m є **M**：
    - 将m分解为其各个字母m<sub>0</sub>, m<sub>1</sub>,….m<sub>i</sub>….,m<sub>l</sub>
    - 根据*D*将每个m<sub>i</sub>转换为一个数字
    - 对于每个m<sub>i</sub>，c<sub>i</sub> = [(m<sub>i</sub> + k) mod 26]
    - 根据*D*将每个c<sub>i</sub>转换为一个字母
    - 然后组合c<sub>0</sub>, c<sub>1</sub>,….,c<sub>l</sub>以产生密文c
- 按如下方式解密密文c：
    - 根据*D*将每个c<sub>i</sub>转换为一个数字
    - 对于每个c<sub>i</sub>，m<sub>i</sub> = [(c<sub>i</sub> – k) mod 26]
    - 根据*D*将每个m<sub>i</sub>转换为一个字母
    - 然后组合m<sub>0</sub>, m<sub>1</sub>,….,m<sub>l</sub>以产生原始消息m

移位密码是对称加密方案的原因是加密和解密过程使用的是相同的密钥。例如，假设你想使用移位密码加密消息“DOG”，并且你随机选择了“24”作为密钥。使用这个密钥加密消息将产生“BME”。检索原始消息的唯一方法是在解密过程中使用相同的密钥，“24”。
这个移位密码是**单字母替换密码**的一个例子：一种加密方案，其中密文字母表是固定的（即，只使用一个字母表）。假设解密算法是确定性的，那么替换密文中的每个符号最多只能对应明文中的一个符号。
直到1700年代，许多加密应用都严重依赖于单字母替换密码，尽管这些密码往往比移位密码复杂得多。例如，你可以在密文字母表中为每个原始文本字母随机选择一个字母，但约束条件是每个字母在密文字母表中只出现一次。这意味着你将有26的阶乘种可能的私钥，这在计算机前的时代是巨大的。

注意，在密码学中你会经常遇到**密码**这个术语。请注意，这个术语有多种含义。实际上，我至少知道在密码学中这个术语有五个不同的含义。

在某些情况下，它指的是加密方案，就像在移位密码和单字母替换密码中一样。然而，这个术语也可以特指加密算法、私钥，或者任何此类加密方案的密文。

最后，密码这个术语还可以指一种核心算法，你可以用它来构建加密方案。这些可以包括各种加密算法，但也包括其他类型的加密方案。在块密码（见下文“块密码”部分）的上下文中，这种意义变得相关。

你还可能遇到**加密**或**解密**这些术语。这些术语仅仅是加密和解密的同义词。

## 暴力攻击和克尔克霍夫原则
<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

移位密码是一种在现代世界中非常不安全的对称加密方案。<sup>[1](#footnote1)</sup> 攻击者可以尝试使用所有26个可能的密钥来解密任何密文，看看哪个结果是有意义的。这种攻击类型，即攻击者只是循环密钥看哪个有效，被称为**暴力攻击**或**穷举密钥搜索**。

任何加密方案要满足最低安全概念，它必须拥有一组可能的密钥，或**密钥空间**，这个空间如此之大以至于暴力攻击变得不可行。所有现代加密方案都满足这个标准。这被称为**足够密钥空间原则**。在不同类型的加密方案中通常也适用类似的原则。

为了感受现代加密方案中巨大的密钥空间大小，假设一个文件已经使用高级加密标准的128位加密。这意味着攻击者有一组2<sup>128</sup>个密钥需要循环通过以进行暴力攻击。要想以这种策略成功的几率达到0.78%，攻击者需要循环大约2.65 x 10<sup>36</sup>个密钥。
假设我们乐观地假设一个攻击者每秒可以尝试10千万亿（即10<sup>16</sup>）个密钥。为了测试密钥空间中0.78%的所有密钥，她的攻击必须持续2.65 x 10<sup>20</sup>秒。这大约是8.4万亿年。因此，即使是一个拥有荒谬强大能力的攻击者进行的暴力破解攻击，在现代128位加密方案下也是不现实的。这就是充足密钥空间原则的作用。

如果攻击者不知道加密算法，移位密码是否更安全？也许是，但提升不大。

无论如何，现代密码学总是假设任何对称加密方案的安全性仅依赖于保持私钥的秘密。攻击者总是假定知道所有其他细节，包括消息空间、密钥空间、密文空间、密钥选择算法、加密算法和解密算法。

认为对称加密方案的安全性仅依赖于私钥的保密性，这一想法被称为**克克霍夫原则**。

按照克克霍夫最初的意图，这一原则仅适用于对称加密方案。然而，一个更通用的版本的原则，也适用于所有其他现代类型的密码学方案：任何密码学方案的设计不需要保密，以确保其安全；保密性只能延伸到某些信息串，通常是一个私钥。

克克霍夫原则是现代密码学的核心，原因有四。<sup>[2](#footnote2)</sup>首先，对于特定类型的应用，只有有限数量的密码学方案。例如，大多数现代对称加密应用使用Rijndael密码。所以，关于方案设计的保密性非常有限。然而，在保持Rijndael密码的某些私钥的保密性方面，有更多的灵活性。

其次，替换一些信息串比替换整个密码学方案更容易。假设一个公司的所有员工都使用相同的加密软件，并且每两个员工都有一个私钥来保密通信。在这种情况下，密钥泄露是一个麻烦，但至少公司可以保留这样的软件以应对安全漏洞。如果公司依赖于方案的保密性，那么任何对该保密性的泄露都将需要替换所有软件。

第三，克克霍夫原则允许密码学方案之间的标准化和兼容性。这对效率有巨大的好处。例如，很难想象如果安全性需要保持密码学方案的保密，每天有数百万人如何能安全地连接到谷歌的网络服务器。

第四，克克霍夫原则允许对密码学方案进行公开审查。这种类型的审查对于实现安全的密码学方案绝对必要。例如，对称密码学中的主要核心算法，Rijndael密码，是由国家标准与技术研究院在1997年到2000年间组织的一场竞赛的结果。

任何试图通过**安全性模糊性**来实现安全的系统都是依赖于保持其设计和/或实现细节的秘密。在密码学中，这将是特别依赖于保持密码学方案的设计细节秘密的系统。因此，安全性模糊性与克克霍夫原则形成鲜明对比。
开放性提高质量和安全性的能力也更广泛地扩展到了数字世界，而不仅仅是密码学。例如，自由和开源的Linux发行版如Debian，通常在隐私、稳定性、安全性和灵活性方面比其Windows和MacOS对应版本有多个优势。虽然这可能有多种原因，但最重要的原则可能是，正如Eric Raymond在他著名的论文《大教堂与集市》中所表述的那样，“[g]iven enough eyeballs, all bugs are shallow。”<sup>[3](#footnote3)</sup> 正是这种群体智慧类型的原则给予了Linux其最显著的成功。
我们永远不能明确地声明一个密码方案是“安全的”或“不安全的”。相反，密码方案有各种各样的安全概念。每个**密码安全定义**必须指定（1）安全目标，以及（2）攻击者的能力。分析密码方案针对一个或多个特定的安全概念，可以提供对其应用和限制的见解。

虽然我们不会深入探讨各种密码安全概念的所有细节，但你应该知道，对于对称和非对称方案（以及某种形式的其他密码原语）的所有现代密码安全概念来说，有两个假设是普遍存在的：

* 攻击者对方案的了解符合Kerckhoffs原则。
* 攻击者不能可行地对方案进行暴力攻击。具体来说，密码安全概念的威胁模型通常甚至不允许暴力攻击，因为它们假设这些不是一个相关考虑。

## 流密码
<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

对称加密方案通常分为两种类型：流密码和块密码。然而，这种区分有些麻烦，因为人们使用这些术语的方式并不一致。在接下来的几节中，我将按照我认为最好的方式阐述这种区分。然而，你应该意识到，许多人使用这些术语的方式与我所阐述的有所不同。

首先让我们来看看流密码。**流密码**是一种对称加密方案，其中加密包括两个步骤。

首先，通过私钥产生一个与明文长度相同的字符串。这个字符串称为**密钥流**。

接下来，密钥流与明文通过数学方式结合产生密文。这种组合通常是一个XOR操作。对于解密，你可以简单地反向操作。（注意，如果A和B是位字符串，那么A XOR B = B XOR A。所以在流密码中XOR操作的顺序对结果没有影响。这个属性被称为交换律。）

一个典型的XOR流密码在*图3*中描述。你首先取一个私钥K，并使用它来生成一个密钥流。然后，密钥流通过XOR操作与明文结合产生密文。任何接收到密文的代理都可以轻松解密，如果他们有密钥K。她所需要做的就是根据方案指定的程序创建一个与密文一样长的密钥流，并将其与密文进行XOR操作。

*图3：一个XOR流密码*

![图3：一个XOR流密码](assets/Figure4-3.webp "图3：一个XOR流密码")
请注意，加密方案通常是一个模板，用于使用相同的核心算法进行加密，而不是一个确切的规范。相应地，流密码通常是一个加密模板，在其中您可以使用不同长度的密钥。尽管密钥长度可以影响方案的一些细节，但它不会影响其本质形式。
移位密码是一个非常简单且不安全的流密码示例。使用单个字母（私钥），您可以生成与消息长度相同的字母串（密钥流）。然后，通过模运算将此密钥流与明文结合，以产生密文。（当用位表示字母时，这个模运算可以简化为XOR运算）。

另一个著名的流密码示例是**维吉尼亚密码**，以16世纪末完全发展它的布莱斯·德·维吉尼亚命名（尽管其他人之前已经做了很多工作）。它是**多表替代密码**的一个示例：一种加密方案，其中明文符号的密文字母表根据其在文本中的位置而变化。与单表替代密码相比，密文符号可以与多个明文符号关联。

随着加密在文艺复兴时期欧洲的普及，**密码分析**——即破解密文——特别是使用**频率分析**，也变得流行。后者利用我们语言中的统计规律来破解密文，早在九世纪就被阿拉伯学者发现。这是一种特别适用于较长文本的技术。甚至到了1700年代的欧洲，特别是在军事和安全设置中，最复杂的单表替代密码也不再能抵抗频率分析。由于维吉尼亚密码在安全性上提供了显著的进步，它在这一时期变得流行，并在1700年代末广泛传播。

非正式地讲，加密方案的工作原理如下：

1. 选择一个多字母单词作为私钥
2. 对任何消息，使用密钥字中相应的字母作为移位，对消息的每个字母应用移位密码
3. 如果您已经循环使用了密钥字，但还没有完全加密明文，再次将密钥字的字母作为移位密码应用于文本剩余部分中相应的字母
4. 继续此过程，直到整个消息都被加密

举例说明，假设您的私钥是GOLD，您想加密消息"CRYPTOGRAPHY"。在这种情况下，您将根据维吉尼亚密码按如下方式进行：

- c<sub>0</sub> = [(2 + 6) Mod 26] = 8 = I
- c<sub>1</sub> = [(17 + 14) Mod 26] = 5 = F
- c<sub>2</sub> = [(24 + 11) Mod 26] = 9 = J
- c<sub>3</sub> = [(15 + 3) Mod 26] = 18 = S
- c<sub>4</sub> = [(19 + 6) Mod 26] = 25 = Z
- c<sub>5</sub> = [(14 + 14) Mod 26] = 2 = C
- c<sub>6</sub> = [(6 + 11) Mod 26] = 17 = R
- c<sub>7</sub> = [(17 + 3) Mod 26] = 20 = U
- c<sub>8</sub> = [(0 + 6) Mod 26] = 6 = G
- c<sub>9</sub> = [(15 + 14) Mod 26] = 3 = D
- c<sub>10</sub> = [(7 + 11) Mod 26] = 18 = S
- c<sub>11</sub> = [(24 + 3) Mod 26] = 1 = B
- c = "IFJSZCRUGDSB"

另一个著名的流密码示例是**一次性密码本**。使用一次性密码本时，你只需创建一个与明文消息一样长的随机位串，并通过XOR操作产生密文。因此，私钥和密钥流在一次性密码本中是等价的。

尽管在现代，移位密码和维吉尼亚密码非常不安全，但如果正确使用，一次性密码本非常安全。可能一次性密码本最著名的应用是，至少直到1980年代，用于**华盛顿-莫斯科热线**。

热线是华盛顿和莫斯科之间用于紧急事务的直接通信链接，安装于古巴导弹危机后。这项技术多年来已经发生了变化。目前，它包括一条直接的光纤电缆以及两个卫星链接（为了冗余），这使得电子邮件和文本消息成为可能。链接在美国的多个地方结束。五角大楼、白宫和乌鸦岩山是已知的终点。与流行观点相反，热线从未涉及电话。

一次性密码本方案的本质如下。华盛顿和莫斯科将拥有两套随机数字。一套由俄罗斯人创建的随机数字，涉及任何俄语消息的加密和解密。一套由美国人创建的随机数字，涉及任何英语消息的加密和解密。不时地，更多的随机数字会通过可信的信使送达对方。

通过使用这些随机数字创建一次性密码本，华盛顿和莫斯科能够秘密通信。每次你需要通信时，你将使用随机数字的下一部分进行消息传递。

虽然高度安全，一次性密码本面临着重大的实际限制：密钥需要与消息一样长，且一次性密码本的任何部分都不能重复使用。这意味着你需要跟踪你在一次性密码本中的位置，存储大量的位，并且不时地与你的对手交换随机位。因此，一次性密码本在实践中不经常使用。

相反，实践中常用的流密码是**伪随机流密码**。Salsa20及其密切相关的变体ChaCha是常用的伪随机流密码示例。

使用这些伪随机流密码时，你首先随机选择一个比明文长度短的密钥K。这样的随机密钥K通常是由我们的计算机基于它随时间收集的不可预测数据创建的，例如网络消息之间的时间、鼠标移动等。
随机密钥K随后被插入到一个扩展算法中，该算法创建一个与消息一样长的伪随机密钥流。你可以精确指定密钥流需要多长（例如，500比特、1000比特、1200比特、29,117比特等等）。
伪随机密钥流看起来*仿佛*是从与之长度相同的所有字符串集合中完全随机选择的。因此，使用伪随机密钥流的加密看起来就像是使用了一次性密码本进行的。但实际上当然不是这样。

由于我们的私钥比密钥流短，而我们的扩展算法需要是确定性的，以便加密/解密过程能够工作，所以并不是每一个特定长度的密钥流都能作为我们扩展操作的输出结果。

假设，例如，我们的私钥长度为128比特，我们可以将其插入到一个扩展算法中以创建一个更长的密钥流，比如说2500比特。由于我们的扩展算法需要是确定性的，我们的算法最多只能选择1/2<sup>128</sup>个长度为2500比特的字符串。所以这样的密钥流永远不能完全随机地从相同长度的所有字符串中选择。

我们对流密码的定义有两个方面：（1）使用私钥辅助生成与明文一样长的密钥流；（2）这个密钥流与明文结合，通常通过XOR操作，产生密文。

有时人们更严格地定义条件（1），断言密钥流必须具体是伪随机的。这意味着移位密码和一次性密码本将不被视为流密码。

在我看来，更广泛地定义条件（1）提供了组织加密方案的更简单方式。此外，这意味着我们不必因为我们了解到一个特定的加密方案实际上并不依赖于伪随机密钥流就停止称其为流密码。

## 块密码
<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

**块密码**通常被理解的第一种方式是作为比流密码更原始的东西：一个核心算法，使用密钥对适当长度的字符串执行长度保持转换。这个算法可以用于创建加密方案和可能的其他类型的密码学方案。

通常，块密码可以接受不同长度的输入字符串，如64、128或256比特，以及不同长度的密钥，如128、192或256比特。尽管这些变量的一些细节可能会改变，但核心算法不会改变。如果改变了，我们会说有两种不同的块密码。注意，这里使用核心算法术语的方式与加密方案相同。

下面*图4*展示了块密码的工作方式。消息M的长度L和密钥K作为输入到块密码。它输出一个长度L的消息M'。对于大多数块密码来说，密钥不必要与M和M'的长度相同。

*图4：一个块密码*

![图4：一个块密码](assets/Figure4-4.webp "图4：一个块密码")
单独一个分组密码并不构成一个加密方案。但是，分组密码可以与各种**操作模式**一起使用，以产生不同的加密方案。操作模式简单地在分组密码之外添加了一些额外的操作。

为了说明这是如何工作的，假设有一个分组密码（BC），它需要一个128位的输入字符串和一个128位的私钥。下面的图5展示了如何将该分组密码与**电子密码本模式**（**ECB模式**）一起使用，以创建一个加密方案。（右侧的省略号表示你可以根据需要重复这个模式）。

*图5：一个带有ECB模式的分组密码*

![图5：一个带有ECB模式的分组密码](assets/Figure4-5.webp "图5：一个带有ECB模式的分组密码")

使用分组密码进行电子密码本加密的过程如下。看看你是否可以将你的明文消息分割成128位的块。如果不行，就给消息添加**填充**，以便结果可以被128位的块大小均匀分割。这就是用于加密过程的数据。

现在将数据分割成128位字符串的块（M<sub>1</sub>、M<sub>2</sub>、M<sub>3</sub>等）。用你的128位密钥通过分组密码运行每个128位字符串，以产生128位密文块（C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>等）。这些块重新组合形成完整的密文。

解密只是反向过程，尽管接收者确实需要某种可识别的方式来去除解密数据中的任何填充，以产生原始的明文消息。

尽管相对简单，但带有电子密码本模式的分组密码在安全性上存在缺陷。这是因为它导致了**确定性加密**。任何两个相同的128位数据字符串都以完全相同的方式加密。这一信息可以被利用。

相反，从分组密码构建的任何加密方案都应该是**概率性的**：也就是说，任何消息M的加密，或M的任何特定块，通常应该每次产生不同的结果。<sup>[5](#footnote5)</sup>

**密码块链接模式**（**CBC模式**）可能是与分组密码一起使用最常见的模式。如果做得正确，这种组合产生一个概率性加密方案。你可以在下面的图6中看到这种操作模式的描述。

*图6：一个带有CBC模式的分组密码*

![图6：一个带有CBC模式的分组密码](assets/Figure4-6.webp "图6：一个带有CBC模式的分组密码")

假设块大小再次是128位。因此，首先，你需要确保你的原始明文消息接收到必要的填充。

然后，你将你的明文的第一个128位部分与一个128位的**初始化向量**进行XOR运算。结果放入分组密码中，以产生第一个块的密文。对于第二个128位的块，你首先将明文与第一个块的密文进行XOR运算，然后将其插入分组密码。你继续这个过程，直到你加密了整个明文消息。

完成后，你将加密消息连同未加密的初始化向量一起发送给接收者。接收者需要知道初始化向量，否则她无法解密密文。
这种构造方式在正确使用时比电子密码本模式更为安全。首先，您应确保初始化向量是一个随机或伪随机字符串。此外，每次使用这种加密方案时，您应使用不同的初始化向量。
换句话说，您的初始化向量应该是一个随机或伪随机的一次性数字（**nonce**），其中**nonce**代表“仅使用一次的数字”。如果您保持这种做法，那么使用块密码的CBC模式将确保任何两个相同的明文块每次加密时都会不同。

最后，让我们关注**输出反馈模式**（**OFB模式**）。您可以在*图7*中看到这种模式的描述。

*图7：带有OFB模式的块密码*

![图7：带有OFB模式的块密码](assets/Figure4-7.webp "图7：带有OFB模式的块密码")

使用OFB模式时，您也需要选择一个初始化向量。但在这里，对于第一个块，初始化向量直接与您的密钥一起插入块密码。然后，产生的128位被视为密钥流。这个密钥流与明文进行XOR运算，产生该块的密文。对于后续的块，您使用前一个块的密钥流作为输入进入块密码并重复这些步骤。

如果您仔细观察，实际上在OFB模式下从块密码创建的是一个流密码。您生成128位的密钥流部分，直到拥有与明文长度相同的密钥流（丢弃最后一个128位密钥流部分中不需要的位）。然后，您将密钥流与您的明文消息进行XOR运算，以获得密文。

在之前关于流密码的部分中，我提到您可以借助私钥生成密钥流。确切地说，它不仅可以用私钥创建。正如您在OFB模式中看到的，密钥流是在私钥和初始化向量的支持下产生的。

注意，与CBC模式一样，每次在OFB模式中使用块密码时选择一个伪随机或随机的一次性数字作为初始化向量也很重要。否则，不同通信中发送的相同128位消息字符串将以相同的方式加密。这是使用流密码创建概率加密的一种方式。

一些流密码仅使用私钥来创建密钥流。对于这些流密码，重要的是您每次通信时都使用一个随机的一次性数字来选择私钥。否则，使用这些流密码的加密结果也将是确定性的，导致安全问题。

最流行的现代块密码是**Rijndael密码**。它是在1997年到2000年间由国家标准与技术研究院（NIST）举办的一场比赛中从十五个提交作品中脱颖而出的，该比赛旨在替换较旧的加密标准，即**数据加密标准**（**DES**）。
Rijndael密码可以使用不同的密钥长度和块大小规格，以及不同的操作模式。NIST竞赛委员会采用了Rijndael密码的一个限制版本——即要求128位块大小和128位、192位或256位的密钥长度——作为**高级加密标准**（**AES**）的一部分。这实际上是对称加密应用的主要标准。它非常安全，以至于即使是NSA似乎也愿意使用256位密钥来加密最高机密文件。<sup>[6](#footnote6)</sup>
AES块密码将在*第5章*中详细解释。

## 消除混淆
<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

关于块密码和流密码之间区别的混淆，是因为有时人们会将块密码的术语特指*采用块加密模式的块密码*。

考虑前一节中的ECB和CBC模式。这些模式特别要求加密数据能够被块大小整除（意味着你可能需要为原始消息使用填充）。此外，这些模式中的数据也是由块密码直接操作（而不仅仅是与块密码操作的结果结合，如OFB模式中所做的）。

因此，你也可以将**块密码**定义为任何一种加密方案，它一次操作固定长度的消息块（任何块必须长于一个字节，否则它就变成了流密码）。加密数据和密文都必须能够均匀地分割成这种块大小。通常，块大小为64、128、192或256位长度。相比之下，流密码可以一次加密一位或一个字节的任意消息。

有了对块密码更具体的理解，你确实可以声称现代加密方案要么是流密码，要么是块密码。从现在开始，除非另有说明，我提到块密码一词时将采用更一般的含义。

上一节中关于OFB模式的讨论还提出了另一个有趣的点。一些流密码是由块密码构建的，如使用OFB的Rijndael。有些如Salsa20和ChaCha并非由块密码创建。你可能会称后者为**原始流密码**。（并没有真正的标准术语来指代这样的流密码。）

当人们讨论流密码和块密码的优缺点时，他们通常是在比较基于块密码的加密方案与原始流密码。

虽然你总是可以轻易地从块密码构造出流密码，但通常很难从原始流密码构建出某种类型的加密构造（如使用CBC模式）。

通过这次讨论，你现在应该理解*图8*。它提供了对称加密方案的概览。我们使用三种加密方案：原始流密码、块密码流密码和块模式下的块密码（在图中也称为“块密码”）。

*图8：对称加密方案概览*

![图8：对称加密方案概览](assets/Figure4-8.webp "图8：对称加密方案概览")

## 消息认证码
<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>
加密关注的是保密性。但密码学还涉及更广泛的主题，如消息的完整性、真实性和不可否认性。所谓的**消息认证码**（MACs）是支持通信中的真实性和完整性的对称密钥密码方案。

为什么通信中除了保密性之外还需要其他东西呢？假设Bob使用几乎无法破解的加密向Alice发送一条消息。任何截获此消息的攻击者都无法就内容获得任何重要见解。然而，攻击者仍然至少有两个其他的攻击途径可供选择：

1. 她可以截获密文，更改其内容，然后将更改后的密文发送给Alice。
2. 她可以完全阻止Bob的消息，并发送她自己创建的密文。

在这两种情况下，攻击者可能对来自密文（1）和（2）的内容没有任何见解。但她仍然可以通过这种方式造成重大损害。这就是消息认证码变得重要的地方。

消息认证码被宽泛定义为具有三种算法的对称密码方案：密钥生成算法、标签生成算法和验证算法。一个安全的MAC确保标签对任何攻击者来说都是**存在性不可伪造的**——也就是说，除非他们拥有私钥，否则他们不能成功地为消息创建一个验证通过的标签。

Bob和Alice可以使用MAC来对抗特定消息的操纵。假设目前他们不关心保密性。他们只想确保Alice收到的消息确实来自Bob，并且没有以任何方式被更改。

该过程在*图9*中描述。要使用MAC，他们首先生成一个私钥K，这个私钥在他们两人之间共享。Bob使用私钥K为消息创建一个标签T。然后，他将消息及其标签发送给Alice。然后，她可以通过运行私钥、消息和标签的验证算法来验证Bob确实制作了标签。

*图9：对称加密方案概览*

![图9：对称加密方案概览](assets/Figure4-9.webp "图9：对称加密方案概览")

由于存在性不可伪造性，攻击者无法以任何方式更改消息M或用有效标签创建自己的消息。即使攻击者观察到Bob和Alice之间使用相同私钥的许多消息的标签，情况也是如此。最多，攻击者可以阻止Alice接收消息M（这是密码学无法解决的问题）。

MAC保证了消息实际上是由Bob创建的。这种真实性，自动意味着消息完整性——也就是说，如果Bob创建了某些消息，那么，事实上，它不会以任何方式被攻击者更改。因此，从现在开始，对认证的任何关注应自动理解为对完整性的关注。

虽然我在讨论中区分了消息的真实性和完整性，但也常见于将这些术语作为同义词使用。它们然后指的是由特定发送者创建且未以任何方式更改的消息的概念。本着这种精神，消息认证码也经常被称为**消息完整性码**。

## 认证加密
<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>
通常，您会希望在通信中保证机密性和真实性，因此，加密方案和MAC方案通常会一起使用。
**认证加密方案**是一种将加密和MAC以高度安全的方式结合起来的方案。具体来说，它必须满足存在性伪造的标准以及非常强的保密性概念，即能抵抗**选择密文攻击**的保密性。<sup>[7](#footnote7)</sup>

为了使加密方案能够抵抗选择密文攻击，它必须满足**不可变性**的标准：即，攻击者对密文的任何修改都应该产生无效的密文，或者解密为与原始密文无关的明文。<sup>[8](#footnote8)</sup>

由于认证加密方案确保由攻击者创建的密文始终无效（因为标签不会被验证），它满足了抵抗选择密文攻击的标准。有趣的是，你可以证明，总是可以从一个存在性不可伪造的MAC和一个满足较弱安全概念的加密方案（即**选择明文攻击安全性**）的组合中创建出一个认证加密方案。

我们不会深入探讨构建认证加密方案的所有细节。但了解其构建的两个细节很重要。

首先，认证加密方案首先处理加密，然后在密文上创建一个消息标签。事实证明，其他方法——如将密文与明文上的标签结合，或者先创建一个标签然后加密明文和标签——是不安全的。此外，这两个操作都有它们自己随机选择的私钥，否则您的安全性将受到严重威胁。

上述原则更普遍地适用：*在结合基本加密方案时，你应该始终使用不同的密钥*。

认证加密方案在*图10*中描述。Bob首先使用随机选择的密钥K<sub>C</sub>从消息M创建密文C。然后，他通过运行密文和另一个随机选择的密钥K<sub>T</sub>通过标签生成算法来创建消息标签T。密文和消息标签都发送给Alice。

Alice现在首先检查给定密文C和密钥K<sub>T</sub>的标签是否有效。如果有效，她可以然后使用密钥K<sub>C</sub>解密消息。她不仅确信他们通信中有非常强的保密性概念，她还知道消息是由Bob创建的。

*图10：一个认证加密方案*

![图10：一个认证加密方案](assets/Figure4-10.webp "图10：一个认证加密方案")

MAC是如何创建的？虽然MAC可以通过多种方法创建，但一种常见且高效的方式是通过加密哈希函数。

我们将在*第6章*中更详细地介绍加密哈希函数。现在，只需知道**哈希函数**是一种能够高效计算的函数，它接受任意大小的输入并产生固定长度的输出。例如，流行的哈希函数**SHA-256**（安全哈希算法256）无论输入大小如何，总是生成256位的输出。一些哈希函数，如SHA-256，在密码学中有实际应用。
最常见的一种通过加密哈希函数生成的标签类型是**基于哈希的消息认证码**（HMAC）。该过程在*图11*中描述。一方从私钥K生成两个不同的密钥，内部密钥K<sub>1</sub>和外部密钥K<sub>2</sub>。然后，将明文M或密文C与内部密钥一起进行哈希处理。结果T'随后与外部密钥一起进行哈希处理，以产生消息标签T。
可以使用一系列哈希函数来创建HMAC。最常用的哈希函数是SHA-256。

*图11：HMAC*

![图11：HMAC](assets/Figure4-11.webp "图11：HMAC")

## 安全通信会话
<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

假设两方正在进行通信会话，因此他们来回发送多条消息。

认证加密方案允许消息的接收者验证消息是否由其通信会话中的伙伴创建（只要私钥没有泄露）。对于单条消息来说，这种方法效果不错。通常，然而，两方在通信会话中来回发送消息。在这种情况下，如前一节所述的普通认证加密方案在提供安全性方面存在不足。

主要原因是认证加密方案无法保证消息实际上也是由通信会话中创建它的代理发送的。考虑以下三种攻击向量：

1. **重放攻击**：攻击者重新发送她在两方之间之前某个时刻截获的密文和标签。
2. **重排序攻击**：攻击者在不同时间截获两条消息，并以相反的顺序将它们发送给接收者。
3. **反射攻击**：攻击者观察从A发送到B的消息，并且也将该消息发送给A。

尽管攻击者不知道密文并且不能创建伪造的密文，上述攻击仍然可以在通信中造成重大损害。

假设，例如，两方之间的特定消息涉及到财务资金的转移。重放攻击可能会第二次转移资金。普通的认证加密方案对这类攻击无能为力。

幸运的是，这些类型的攻击可以在通信会话中通过使用**标识符**和**相对时间指示器**来轻松缓解。

可以在加密之前向明文消息添加标识符。这将阻止任何反射攻击。相对时间指示器可以是特定通信会话中的序列号。每方在加密前向消息添加一个序列号，这样接收者就知道消息的发送顺序。这消除了重排序攻击的可能性。它也消除了重放攻击。攻击者发送的任何消息都会有一个旧的序列号，接收者将知道不再处理该消息。

为了说明安全通信会话是如何工作的，再次假设有Alice和Bob。他们来回发送总共四条消息。你可以在*图11*下面看到带有标识符和序列号的认证加密方案是如何工作的。
通信会话开始时，Bob向Alice发送一个包含消息标签T<sub>0,B</sub>的密文C<sub>0,B</sub>。密文中包含了消息、一个标识符（BOB）和一个序列号（0）。标签T<sub>0,B</sub>是对整个密文生成的。在随后的通信中，Alice和Bob维持这一协议，根据需要更新字段。
*图12：一个安全的通信会话*

![图12：一个安全的通信会话](assets/Figure4-12.webp "图12：一个安全的通信会话")


## 注释
<chapterId>b96d38dd-c9cb-56a7-8764-4af8526bc63f</chapterId>

[^1]: 根据Seutonius的说法，朱利叶斯·凯撒在他的军事通信中使用了一个常量密钥值为3的移位密码。因此A总是变成D，B总是变成E，C总是变成F，以此类推。这个特定版本的移位密码因此被称为**凯撒密码**（尽管它在现代词汇中并不真正是一个密码，因为密钥值是常量）。如果罗马的敌人对加密非常不熟悉，凯撒密码在公元前一世纪可能是安全的。但在现代，它显然不会是一个非常安全的方案 [^1]。

[^2]: Jonathan Katz和Yehuda Lindell，《现代密码学导论》，CRC出版社（佛罗里达州博卡拉顿：2015年），第7页 [^2]。

[^3]: Eric Raymond，“大教堂与集市”，论文在德国维尔茨堡的Linux Kongress上发表（1997年5月27日）。后续有多个版本以及一本书。我的引用来自书中的第30页：Eric Raymond，《大教堂与集市：一个偶然的革命者对Linux和开源的思考》，修订版（2001年），O’Reilly：加利福尼亚州塞巴斯托波尔 [^3]。

[^4]: Crypto Museum, "华盛顿-莫斯科热线," 2013, 可在[Crypto Museum](https://www.cryptomuseum.com/crypto/hotline/index.htm)查看 [^4]。

[^5]: Shafi Goldwasser和Silvio Micali首次强调了概率加密的重要性，“概率加密”，*Journal of Co [^5]。



# RC4和AES
<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

在本章中，我们将讨论一个现代原始流密码RC4（或“Rivest密码4”）和一个现代块密码AES的加密方案的细节。虽然RC4密码作为加密方法已经不受青睐，但AES是现代对称加密的标准。这两个例子应该能更好地说明对称加密的内部工作原理。


## RC4流密码
<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>
为了了解现代伪随机流密码是如何工作的，我将重点介绍RC4流密码。它是一种伪随机流密码，曾经被用于WEP和WAP无线接入点安全协议以及TLS中。由于RC4有许多已被证明的弱点，它已经变得不受欢迎。事实上，互联网工程任务组现在禁止在所有TLS实例中的客户端和服务器应用程序使用RC4套件。<sup>[3](#footnote3)</sup> 尽管如此，它作为一个示例很好地说明了原始流密码是如何工作的。

首先，我将展示如何使用一个简化版的RC4密码来加密一个明文消息。假设我们的明文消息是“SOUP”。然后，使用我们的简化版RC4密码进行加密，将分四步进行。

### 步骤1

首先，定义一个数组S，其中S[0] = 0到S[7] = 7。这里的数组仅仅意味着一个由索引组织的可变值集合，也在一些编程语言中被称为列表（例如，Python）。在这个例子中，索引从0到7，值也从0到7。所以S如下：

- S = [0,1,2,3,4,5,6,7]

这里的值不是ASCII数字，而是1字节字符串的十进制值表示。所以值2等于0000 0011。因此，数组S的长度为8字节。

### 步骤2

其次，通过选择一个1到8字节之间的密钥（不允许字节的分数）来定义一个长度为8字节的密钥数组K。由于每个字节是8位，所以你可以为密钥的每个字节选择0到255之间的任何数字。

假设我们选择我们的密钥k为[14,48,9]，因此它的长度为3字节。然后，根据密钥的特定元素的十进制值，依次设置我们密钥数组的每个索引。如果你遍历完整个密钥，从头开始，直到你填满了密钥数组的8个槽。因此，我们的密钥数组如下

- K = [14,48,9,14,48,9,14,48]

### 步骤3

第三，我们将使用密钥数组K转换数组S，这个过程被称为密钥调度。该过程的伪代码如下：

- 创建变量j和i
- 设置变量j = 0
- 对于每个i从0到7：
	- 设置j = j + S[i] + K[i] mod 8
	- 交换S[i]和S[j]

数组S的转换由*表1*捕获。

从一开始，你可以看到S的初始状态为[0,1,2,3,4,5,6,7]，j的初始值为0。这将使用密钥数组[14,48,9,14,48,9,14,48]进行转换。
for循环从i = 0开始。根据我们上面的伪代码，j的新值变为6（j = j + S[0] + K[0] mod 8 = 0 + 0 + 14 mod 8 = 6 mod 8）。交换S[0]和S[6]，一轮后S的状态变为[6,1,2,3,4,5,0,7]。
在下一行，i = 1。再次通过for循环，j获得一个值为7（j = j + S[1] + K[1] mod 8 = 6 + 1 + 48 mod 8 = 55 mod 8 = 7 mod 8）。从当前的S状态[6,1,2,3,4,5,0,7]交换S[1]和S[7]，第二轮后的结果为[6,7,2,3,4,5,0,1]。

我们继续这个过程，直到我们在S数组的底部产生最终行，[6,4,1,0,3,7,5,2]。

*表1：密钥调度表*

![表1：密钥调度表](assets/Table5-1.webp "表1：密钥调度表")

### 第四步

作为第四步，我们产生密钥流。这是一个与我们想要发送的消息长度相等的伪随机字符串。这将用于加密原始消息“SOUP”。由于密钥流需要与消息一样长，我们需要一个有4个字节的。

密钥流是通过以下伪代码产生的：

- 创建变量j、i和t
- 设置j = 0
- 对于明文的每个i，从i = 1开始，直到i = 4，密钥流的每个字节如下产生：
    - j = j + S[i] mod 8
	- 交换S[i]和S[j]
	- t = S[i] + S[j] mod 8
	- 密钥流的第i个字节 = S[t]

你可以在*表2*中跟踪计算。

S的初始状态 = S = [6,4,1,0,3,7,5,2]。设置i = 1，j的值变为4（j = j + S[i] mod 8 = 0 + 4 mod 8 = 4）。然后，我们交换S[1]和S[4]，在第二行产生S的转换，[6,3,1,0,4,7,5,2]。然后，t的值是7（t = S[i] + S[j] mod 8 = 3 + 4 mod 8 = 7）。最后，密钥流的字节是S[7]，或2。

然后，我们可以继续产生其他字节，直到我们有以下四个字节：2, 6, 3, 和 7。每个字节可以用来加密明文"SOUP"的每个字母。
首先，使用ASCII表，我们可以看到“SOUP”通过底层字节字符串的十进制值编码为“83 79 85 80”。与密钥流“2 6 3 2”的组合产生“85 85 88 82”，经过模256运算后保持不变。在ASCII中，密文“85 85 88 82”等于“UUXR”。
如果要加密的单词比数组S更长会发生什么？在这种情况下，数组S就会按照上面显示的方式不断变换，对明文的每个字节i进行处理，直到密钥流中的字节数等于明文中的字母数。

*表2：密钥流生成*

![表2：密钥流生成](assets/Table5-2.webp "表2：密钥流生成")

我们刚刚讨论的例子只是RC4流密码的简化版本。实际的RC4流密码有一个长度为256字节的S数组，而不是8字节，密钥长度可以在1到256字节之间，而不是1到8字节。然后，密钥数组和密钥流都是考虑到S数组的256字节长度来产生的。这些计算变得极其复杂，但原理保持不变。使用相同的密钥[14,48,9]，标准RC4密码将明文消息“SOUP”加密为十六进制格式的67 02 ed df。

一个密钥流独立于明文消息或密文更新的流密码是**同步流密码**。密钥流仅依赖于密钥。显然，RC4是同步流密码的一个例子，因为密钥流与明文或密文无关。我们在前一章提到的所有原始流密码，包括移位密码、维吉尼亚密码和一次性密码本，也都是同步类型。

相比之下，**异步流密码**的密钥流是由密钥和密文的前几个元素共同产生的。这种类型的密码也被称为**自同步密码**。

重要的是，用RC4产生的密钥流应该被视为一次性密码本，你不能以完全相同的方式下次产生密钥流。与其每次更换密钥，一个实用的解决方案是将密钥与一个随机数结合起来产生字节流。

## 搭配128位密钥的AES
<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

如上一章所述，国家标准与技术研究院（NIST）在1997年到2000年间举办了一场比赛，以确定新的对称加密标准。Rijndael密码成为了获胜的参赛作品。这个名字是比利时创造者Vincent Rijmen和Joan Daemen名字的文字游戏。

Rijndael密码是一种块密码，意味着有一个核心算法，可以用不同的密钥长度和块大小规格使用。然后，你可以用它与不同的操作模式结合来构建加密方案。
NIST竞赛的委员会采用了Rijndael密码的一种限制版本——即一种要求128位块大小和密钥长度为128位、192位或256位的版本——作为高级加密标准的一部分。这种限制版本的Rijndael密码也可以在多种操作模式下使用。该标准的规范被称为高级加密标准（AES）。

为了展示Rijndael密码的工作原理，即AES的核心，我将以128位密钥的加密过程为例进行说明。密钥大小会影响每个加密块所需的轮次数量。对于128位密钥，需要10轮。对于192位和256位，则分别需要12轮和14轮。

此外，我将假设AES使用的是ECB模式。这使得阐述稍微简单一些，并且对于Rijndael算法来说并不重要。确实，ECB模式在实践中是不安全的，因为它导致了确定性加密。与AES一起使用的最常见的安全模式是CBC。

我们将密钥称为K<sub>0</sub>。那么，根据上述参数的构造，如图1所示，其中M<sub>i</sub>代表128位的明文消息的一部分，C<sub>i</sub>代表128位的密文的一部分。如果明文不能被块大小均匀划分，则在最后一个块中添加填充。

*图1：128位密钥的AES-ECB*

![图1：128位密钥的AES-ECB](assets/Figure5-1.webp "图1：128位密钥的AES-ECB")

每个128位的文本块在Rijndael加密方案中经过十轮。这需要为每一轮生成一个单独的轮密钥（K<sub>1</sub>到K<sub>10</sub>）。这些轮密钥是通过密钥扩展算法从原始的128位密钥K<sub>0</sub>生成的。因此，对于要加密的每个文本块，我们将使用原始密钥K<sub>0</sub>以及十个单独的轮密钥。注意，这些相同的11个密钥用于需要加密的每个128位明文块。

密钥扩展算法既长又复杂。深入研究它的教育效益有限。如果你愿意，可以自己查看密钥扩展算法。一旦产生了轮密钥，Rijndael密码将操纵第一个128位的明文块M<sub>1</sub>，如图2所示。我们现在将通过这些步骤。

*图2：使用Rijndael密码操纵M<sub>1</sub>*

![图2：使用Rijndael密码操纵M<sub>1</sub>](assets/Figure5-2.webp "图2：使用Rijndael密码操纵M<sub>1</sub>")

### 第0轮

Rijndael密码的第0轮非常直接。通过128位明文和私钥之间的XOR操作产生一个数组S<sub>0</sub>。即，

- S<sub>0</sub> = M<sub>1</sub> XOR K<sub>0</sub>
在第一轮中，数组 S<sub>0</sub> 首先通过 XOR 操作与轮密钥 K<sub>1</sub> 结合。这产生了 S 的一个新状态。
其次，对 S 的当前状态执行字节替换操作。它通过取 16 字节 S 数组的每个字节，并将其替换为称为 **Rijndael 的 S 盒** 的数组中的一个字节来工作。每个字节都有一个独特的转换，并且产生了一个新的 S 状态。Rijndael 的 S 盒在 *图 3* 中显示。

*图 3: Rijndael 的 S 盒*

![图 3: Rijndael 的 S 盒](assets/Figure5-3.webp "图 3: Rijndael 的 S 盒")

这个 S 盒是抽象代数在 Rijndael 密码中发挥作用的地方之一，特别是伽罗瓦域。

首先，你定义每个可能的字节元素 00 到 FF 为一个 8 位向量。每个这样的向量都是伽罗瓦域 GF(2<sup>8</sup>) 的一个元素，其中模运算的不可约多项式是 x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1。具有这些规格的伽罗瓦域也称为 Rijndael 的有限域。

接下来，对于域中的每个可能元素，我们创建所谓的 **Nyberg S 盒**。在这个盒子中，每个字节都映射到它的乘法逆元（即，使它们的乘积等于 1）。然后，我们将 Nyberg S 盒中的值通过仿射变换映射到 Rijndael 的 S 盒。

S 数组的第三个操作是行移位操作。它取 S 的状态并列出矩阵中的所有十六个字节。填充矩阵从左上角开始，并通过从上到下工作，然后，每次填充一列，向右移动一列并返回到顶部。

一旦构造了 S 的矩阵，四行就会被移位。第一行保持不变。第二行向左移动一位。第三行向左移动两位。第四行向左移动三位。过程的一个示例在 *图 4* 中提供。S 的原始状态显示在顶部，行移位操作后的结果状态显示在下面。

*图 4: 行移位操作*

![图 4: 行移位操作](assets/Figure5-4.webp "图 4: 行移位操作")

在第四步中，伽罗瓦域再次出现。首先，S 矩阵的每一列乘以 *图 5* 中看到的 4 x 4 矩阵的一列。但这不是常规的矩阵乘法，而是模不可约多项式 x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1 的向量乘法。结果向量系数代表一个字节的各个位。

*图 5: 混合列矩阵*

![图 5: 混合列矩阵](assets/Figure5-5.webp "图 5: 混合列矩阵")

S 矩阵的第一列与上述 4 x 4 矩阵的乘法产生 *图 6* 中的结果。
*图 6：第一列的乘法*
![图 6：第一列的乘法](assets/Figure5-6.webp "图 6：第一列的乘法")

下一步，矩阵中的所有项都需要转换成多项式。例如，F1代表1字节，将变成x<sup>7</sup> + x<sup>6</sup> + x<sup>5</sup> + x<sup>4</sup> + 1，而03代表1字节，将变成x + 1。

然后，所有的乘法运算都是在x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1的模下进行的。这将导致每个列的四个单元中加入四个多项式。在对这些加法进行模2运算后，你将得到四个多项式。这些多项式中的每一个都代表一个8位字符串，或1字节，即S。我们不会在*图 6*中的矩阵上执行所有这些计算，因为它们是广泛的。

一旦处理了第一列，S矩阵的其他三列也以相同的方式处理。最终这将产生一个包含十六个字节的矩阵，可以转换成一个数组。

作为最后一步，数组S再次与轮密钥通过XOR操作结合。这产生了状态S<sub>1</sub>。即，

- S<sub>1</sub> = S XOR K<sub>0</sub>

### 第2轮至第10轮

第2轮至第9轮只是第1轮的重复，*mutatis mutandis*。最后一轮与前几轮非常相似，除了混合列步骤被省略。即，第10轮如下执行：

- S<sub>9</sub> XOR K<sub>10</sub>
- 字节替换
- 行移位
- S<sub>10</sub> = S XOR K<sub>10</sub>

状态S<sub>10</sub>现在设置为C<sub>1</sub>，即密文的前128位。处理剩余的128位明文块，得到完整的密文C。

### Rijndael密码的操作

Rijndael密码不同操作背后的逻辑是什么？

不深入细节，加密方案是基于它们产生混淆和扩散的程度来评估的。如果加密方案具有高度的**混淆性**，这意味着密文与明文看起来截然不同。如果加密方案具有高度的**扩散性**，这意味着对明文的任何小改动都会产生截然不同的密文。

Rijndael密码背后操作的逻辑是它们产生了高度的混淆和扩散。混淆是通过字节替换操作产生的，而扩散是通过行移位和列混合操作产生的。

# 非对称加密
<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

与对称加密一样，非对称方案也可以用来确保机密性和认证性。然而，与之相反，这些方案使用两个而不是一个密钥：一个私钥和一个公钥。
我们的探询从非对称加密技术的发现开始，特别是激发这一技术发展的问题。接下来，我们将讨论在高层次上，非对称加密和认证方案是如何工作的。然后，我们介绍哈希函数，这对于理解非对称认证方案至关重要，并且在其他加密上下文中也有相关性，比如我们在第四章讨论的基于哈希的消息认证码。

## 密钥分发和管理问题
<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

假设Bob想从Jim的体育用品店，一个拥有数百万北美客户的在线体育用品零售商，购买一件新的雨衣。这将是他第一次从他们那里购买，他想使用他的信用卡。因此，Bob首先需要在Jim的体育用品店创建一个账户，这需要发送个人详细信息，如他的地址和信用卡信息。然后，他可以完成购买雨衣所需的步骤。

Bob和Jim的体育用品店会希望在整个过程中他们的通信是安全的，考虑到互联网是一个开放的通信系统。例如，他们会希望确保没有潜在的攻击者可以获取到Bob的信用卡和地址详情，也没有潜在的攻击者可以重复他的购买或代表他创建假的购买。

正如上一章讨论的，一个高级的认证加密方案肯定可以使Bob和Jim的体育用品店之间的通信安全。但显然，实施这样的方案存在实际障碍。

为了说明这些实际障碍，假设我们生活在一个只有对称加密工具存在的世界中。那么，Jim的体育用品店和Bob又该如何确保通信的安全呢？

在这种情况下，他们将面临沟通安全的巨大成本。由于互联网是一个开放的通信系统，他们不能仅仅通过它交换一组密钥。因此，Bob和Jim的体育用品店的代表将需要亲自进行密钥交换。

一种可能性是，Jim的体育用品店创建特殊的密钥交换地点，Bob和其他新客户可以在那里获取一组用于安全通信的密钥。这显然会带来巨大的组织成本，并且极大地降低新客户进行购买的效率。

或者，Jim的体育用品店可以通过一个高度可信的快递员发送一对密钥给Bob。这可能比组织密钥交换地点更有效率。但这仍然会带来巨大的成本，特别是如果许多客户只进行一次或几次购买的话。

接下来，对于认证加密的对称方案也迫使Jim的体育用品店为所有客户存储单独的密钥集。对于成千上万的客户来说，这将是一个重大的实际挑战，更不用说数百万了。

为了理解这一点，假设Jim的体育用品店为每个客户提供相同的一对密钥。这将允许每个客户——或任何其他可能获得这对密钥的人——阅读甚至操纵Jim的体育用品店与其客户之间的所有通信。那么，你可能就不应该在你的通信中使用加密技术了。

即使只为一些客户重复一组密钥，也是一个糟糕的安全实践。任何潜在的攻击者都可能尝试利用该方案的这一特点（记住，根据Kerckhoffs原则，攻击者假定知道方案的一切，但不知道密钥）。

因此，Jim的体育用品店不管如何分发这些密钥对，都必须为每个客户存储一对密钥。这显然带来了几个实际问题。

- Jim的体育用品店将不得不存储数百万对密钥，每个客户一套。
- 这些密钥必须得到妥善保护，因为它们肯定会成为黑客的首要目标。任何安全漏洞都将需要重复进行昂贵的密钥交换，无论是在特殊的密钥交换地点还是通过快递。
- Jim's Sporting Goods的任何顾客都必须在家中安全存储一对密钥。丢失和盗窃将发生，需要重复密钥交换。顾客还必须为他们希望通过互联网与之通信和交易的任何其他在线商店或其他类型的实体，经历这一过程。

直到1970年代晚期，上述这两个主要挑战都是非常基本的关切。它们被称为**密钥分发问题**和**密钥管理问题**。

这些问题当然一直存在，并且在过去经常造成头痛。例如，军事力量必须不断地将带有安全通信密钥的书籍分发给实地人员，这既冒着巨大风险又需要大量成本。但随着世界越来越多地转向长距离数字通信，特别是对于非政府实体，这些问题变得更加严重。

如果这些问题在1970年代没有得到解决，那么在Jim's Sporting Goods进行高效和安全购物可能根本就不存在。实际上，我们大多数现代世界的实用和安全电子邮件、在线银行和购物可能只是一个遥远的幻想。任何类似比特币的东西根本就不可能存在。

那么，1970年代发生了什么？我们如何能够立即在线进行购买并安全浏览万维网？我们如何能够即时从我们的智能手机向全世界发送比特币？

## 密码学的新方向
<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

到了1970年代，密钥分发和密钥管理问题引起了一群美国学术密码学家的注意：Whitfield Diffie、Martin Hellman和Ralph Merkle。面对来自大多数同行的严重怀疑，他们冒险寻找解决方案。

他们冒险的至少一个主要动机是预见到开放的计算机通信将深刻影响我们的世界。正如Diffie和Helmann在1976年指出的，

> 计算机控制的通信网络的发展，承诺在世界的对面人们或计算机之间提供轻松和廉价的联系，用电信替代大多数邮件和许多出行。对于许多应用来说，这些联系必须对窃听和非法消息的注入保持安全。然而，目前，安全问题的解决方案远远落后于通信技术的其他领域。*现代密码学无法满足要求，因为它的使用将对系统用户施加如此严重的不便，以至于消除了电信处理的许多好处。*<sup>[1](#footnote1)</sup>

Diffie、Hellman和Merkle的坚持得到了回报。他们的研究结果首次发表是Diffie和Helmann在1976年发表的论文《密码学的新方向》。在其中，他们提出了两种原创方法来解决密钥分发和密钥管理问题。
他们提供的第一个解决方案是一个远程*密钥交换协议*，即一套在不安全的通信渠道上交换一个或多个对称密钥的规则。这个协议现在被称为*Diffie-Helmann密钥交换*或*Diffie-Helmann-Merkle密钥交换*。<sup>[2](#footnote2)</sup>
通过Diffie-Helmann密钥交换，两个参与方首先在一个不安全的渠道如互联网上公开交换一些信息。基于这些信息，他们接着独立地创建一个对称密钥（或一对对称密钥）以进行安全通信。虽然双方独立创建他们的密钥，但他们公开共享的信息确保了这个密钥创建过程对他们双方来说产生相同的结果。

重要的是，虽然每个人都可以观察到双方通过不安全渠道公开交换的信息，但只有参与信息交换的两个方能够从中创建对称密钥。

当然，这听起来完全违反直觉。两个方如何能公开交换一些信息，而只允许他们从中创建对称密钥？为什么观察信息交换的其他人不能创建相同的密钥呢？

这当然依赖于一些美妙的数学原理。Diffie-Helmann密钥交换通过一个具有陷门的单向函数来工作。让我们依次讨论这两个术语的含义。

假设你被给定了某个函数f(x)和结果f(a) = y，其中a是x的一个特定值。我们说f(x)是一个**单向函数**，如果当给定a和f(x)时，计算出y的值很容易，但是当给定y和f(x)时，计算出a的值在计算上是不可行的。单向函数这个名称，当然是因为这样的函数只能在一个方向上实际计算。

一些单向函数具有所谓的陷门。虽然在只给定y和f(x)的情况下计算出a几乎是不可能的，但有一种特定的信息Z使得从y计算出a在计算上变得可行。这种信息Z被称为**陷门**。具有陷门的单向函数被称为**陷门函数**。

我们在这里不会深入探讨Diffie-Helmann密钥交换的细节。但本质上，每个参与者创建一些信息，其中一部分公开共享，而一些保密。然后，每个方都将他们的保密信息和另一方共享的公开信息结合起来创建一个私钥。有点神奇的是，两个方最终会得到相同的私钥。

任何仅观察两个方在Diffie-Helmann密钥交换中公开共享的信息的一方都无法复制这些计算。他们需要从两个方之一那里获得私密信息才能做到这一点。

尽管1976年论文中提出的Diffie-Helmann密钥交换的基本版本并不非常安全，但基本协议的复杂版本今天肯定仍在使用。最重要的是，最新版本的传输层安全协议（版本1.3）中的每个密钥交换协议本质上都是Diffie和Hellman在1976年提出的协议的丰富版本。传输层安全协议是安全交换根据超文本传输协议（http）格式化的信息的主要协议，http是交换Web内容的标准。
重要的是，Diffie-Helmann 密钥交换不是一种非对称方案。严格来说，它可以说属于对称密钥密码学的范畴。但由于 Diffie-Helmann 密钥交换和非对称密码学都依赖于具有陷门的单向数论函数，它们通常会一起讨论。
Diffie 和 Helmann 在他们 1976 年的论文中提出的解决密钥分发和管理问题的第二种方式，当然是通过非对称密码学。

与他们对 Diffie-Hellman 密钥交换的介绍相比，他们只提供了如何可信构建非对称密码学方案的一般轮廓。他们没有提供任何特定的单向函数，这些函数可以具体满足这些方案中合理安全性所需的条件。

然而，一年后，三位不同的学术密码学家和数学家找到了一种非对称方案的实际实现：Ronald Rivest、Adi Shamir 和 Leonard Adleman。<sup>[3](#footnote3)</sup> 他们介绍的密码系统被称为 **RSA 密码系统**（以他们的姓氏命名）。

非对称密码学（和 Diffie Helmann 密钥交换）中使用的陷门函数都与两个主要的**计算难题**相关：素数分解和离散对数的计算。

**素数分解**，顾名思义，需要将一个整数分解成其素因数。RSA 问题是迄今为止与素数分解相关的最著名的密码系统示例。

**离散对数问题**是在循环群中出现的问题。给定一个特定循环群中的生成元，它需要计算产生该群中另一个元素所需的唯一指数。

基于离散对数的方案依赖于两种主要的循环群：整数的乘法群和包括椭圆曲线上点的群。原始的 Diffie Helmann 密钥交换如在《密码学新方向》中所呈现的，是与整数的循环乘法群一起工作的。比特币的数字签名算法和最近引入的 Schnorr 签名方案（2021年）都基于特定椭圆曲线循环群的离散对数问题。

接下来，我们将转向非对称设置中的保密性和认证的高层次概述。然而，在此之前，我们确实需要做一个简短的历史说明。

现在看来，为政府通信总部（GCHQ）工作的一群英国密码学家和数学家可能在几年前就独立发现了上述内容。这个团队由 James Ellis、Clifford Cocks 和 Malcolm Williamson 组成。

根据他们自己的说法以及 GCHQ 的说法，是 James Ellis 在 1969 年首先构想了公钥密码学的概念。据说，Clifford Cocks 在 1973 年发现了 RSA 密码系统，Malcolm Williamson 在 1974 年发现了 Diffie Helmann 密钥交换的概念。<sup>[4](#footnote4)</sup> 然而，鉴于在 GCHQ 所做工作的秘密性质，他们的发现据称直到 1997 年才被披露。


## 非对称加密和认证
<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

*图 1* 提供了 Bob 和 Alice 帮助下的非对称加密概述。
爱丽丝首先创建一对密钥，包括一个公钥（K<sub>P</sub>）和一个私钥（K<sub>S</sub>），其中K<sub>P</sub>中的“P”代表“公开”，K<sub>S</sub>中的“S”代表“秘密”。然后，她将这个公钥自由地分发给其他人。我们稍后会回到这个分发过程的细节。但现在假设任何人，包括鲍勃，都可以安全地获取爱丽丝的公钥K<sub>P</sub>。
在稍后的某个时刻，鲍勃想给爱丽丝写一条包含敏感信息的消息M。然而，他希望这些内容对除了爱丽丝之外的所有人保密。因此，鲍勃首先使用K<sub>P</sub>加密他的消息M。然后，他将得到的密文C发送给爱丽丝，爱丽丝用K<sub>S</sub>解密C，还原出原始消息M。

*图1：非对称加密*

![图1：非对称加密](assets/Figure6-1.webp "图1：非对称加密")

任何监听鲍勃和爱丽丝通信的对手都可以观察到C。她还知道K<sub>P</sub>和加密算法E(·)。然而，重要的是，这些信息不允许攻击者可行地解密密文C。解密特别需要K<sub>S</sub>，而攻击者并不拥有。

对称加密方案通常需要对可以有效加密明文消息的攻击者保持安全（称为选择密文攻击安全）。然而，它并不是为了允许攻击者或任何其他人创建这样有效的密文而特别设计的。

这与非对称加密方案形成鲜明对比，其整个目的是允许任何人，包括攻击者，产生有效的密文。因此，非对称加密方案可以被标记为**多重访问密码**。

为了更好地理解发生了什么，想象一下，如果鲍勃想要秘密地发送一封实体信件，而不是电子消息。确保秘密的一种方式可能是爱丽丝发送一个安全的挂锁给鲍勃，但保留解锁它的钥匙。在写完信后，鲍勃可以将信放入一个盒子中，并用爱丽丝的挂锁关闭它。然后，他可以发送这个锁着的盒子和消息给拥有钥匙的爱丽丝。

虽然鲍勃能够锁上挂锁，但如果挂锁确实安全，他或任何其他拦截盒子的人都无法打开挂锁。只有爱丽丝可以解锁它并查看鲍勃信件的内容，因为她拥有钥匙。

粗略地说，非对称加密方案是这个过程的数字版本。挂锁类似于公钥，挂锁钥匙类似于私钥。然而，因为挂锁是数字的，所以对爱丽丝来说，将它分发给可能想要向她发送秘密消息的任何人要容易得多，也不那么昂贵。

在非对称设置中进行认证时，我们使用**数字签名**。因此，它们在对称设置中具有与消息认证码相同的功能。*图2*提供了数字签名的概述。
鲍勃首先创建一对密钥，包括公钥（K<sub>P</sub>）和私钥（K<sub>S</sub>），并分发他的公钥。当他想向爱丽丝发送经过认证的消息时，他首先取他的消息M和他的私钥来创建数字签名D。然后，鲍勃将他的消息连同数字签名一起发送给爱丽丝。爱丽丝将消息、公钥和数字签名输入到验证算法中。这个算法产生的结果要么是对于有效签名的真（true），要么是对于无效签名的假（false）。

数字签名，正如其名称清楚地表明的，是书信、合同等上书面签名的数字等价物。实际上，数字签名通常要安全得多。通过一些努力，你可以伪造书面签名；这一过程因为书面签名经常不被仔细核实而变得更容易。然而，一个安全的数字签名，就像一个安全的消息认证码一样，是**存在性不可伪造的**：也就是说，有了一个安全的数字签名方案，除非他们拥有私钥，否则没有人可以可行地为一条消息创建一个通过验证程序的签名。

*图2：非对称认证*

![图2：非对称认证](assets/Figure6-2.webp "图2：非对称认证")

与非对称加密一样，我们看到数字签名和消息认证码之间有一个有趣的对比。对于后者，验证算法只能由参与安全通信的一方使用。这是因为它需要一个私钥。然而，在非对称设置中，任何人都可以验证鲍勃所做的数字签名S。

所有这些使得数字签名成为一个极其强大的工具。例如，它构成了在合同上创建可以出于法律目的验证的签名的基础。如果鲍勃在上述交换中对合同做了签名，爱丽丝可以向法庭展示消息M、合同和签名S。然后，法庭可以使用鲍勃的公钥来验证签名。<sup>[5](#footnote5)</sup>

再举一个例子，数字签名是确保软件和软件更新分发安全的一个重要方面。这种公共可验证性永远无法仅通过消息认证码来创建。

作为数字签名力量的最后一个例子，考虑比特币。关于比特币，特别是在媒体中，最常见的误解之一是交易是加密的：它们不是。相反，比特币交易通过使用数字签名来确保安全性。

比特币存在于称为未花费交易输出（或UTXO）的批次中。假设你在一个特定的比特币地址收到三笔支付，每笔2比特币。技术上你现在并不拥有那个地址上的6比特币。相反，你拥有三批每批2比特币，它们被与那个地址相关联的密码问题锁定。对于你进行的任何支付，你可以根据交易需要使用其中的一批、两批或全部三批。

对未花费交易输出的所有权证明通常通过一个或多个数字签名来显示。比特币之所以有效，正是因为在未花费交易输出上的有效数字签名在计算上是不可行的，除非你拥有制作它们所需的秘密信息。
目前，比特币交易透明地包含了网络参与者需要验证的所有信息，例如交易中使用的未花费交易输出的来源。虽然有可能隐藏部分信息并仍然允许验证（如某些替代加密货币例如门罗币所做的那样），但这也会带来特定的安全风险。
有时会对数字签名和数字化捕获的书面签名产生混淆。在后一种情况下，你会捕获你的书面签名的图像，并将其粘贴到电子文档上，例如雇佣合同。然而，这并不是加密意义上的数字签名。后者只是一个长数字，只有拥有私钥的人才能生成。

就像在对称密钥设置中一样，你也可以将非对称加密和认证方案一起使用。类似的原则适用。首先，你应该使用不同的私钥-公钥对进行加密和制作数字签名。此外，你应该先加密消息，然后对其进行认证。

重要的是，在许多应用中，并不是在整个通信过程中都使用非对称加密。相反，它通常只用于*交换对称密钥*，以便双方实际进行通信。

例如，在你在线购买商品时就是这种情况。知道了卖家的公钥，她可以向你发送经过数字签名的消息，你可以验证这些消息的真实性。在此基础上，你可以遵循多种协议之一来交换对称密钥，以安全地通信。

采用上述方法的主要原因是，与对称加密相比，非对称加密在产生特定安全级别方面的效率要低得多。这就是为什么我们仍然需要对称密钥加密来辅助公钥加密的原因之一。此外，对称密钥加密在特定应用中更为自然，例如计算机用户加密自己的数据。

那么，数字签名和公钥加密是如何准确地解决密钥分发和密钥管理问题的呢？

这里没有一个答案。非对称加密是一个工具，并没有一种方式来使用这个工具。但让我们以吉姆体育用品店的早期示例来展示这些问题通常是如何被解决的。

首先，吉姆体育用品店可能会接近一个**证书颁发机构**，这是一个支持公钥分发的组织。证书颁发机构会注册关于吉姆体育用品店的一些细节，并授予它一个公钥。然后，它会发送给吉姆体育用品店一个证书，称为**TLS/SSL证书**，该证书上有吉姆体育用品店的公钥，并使用证书颁发机构自己的公钥进行数字签名。通过这种方式，证书颁发机构确认特定的公钥确实属于吉姆体育用品店。

理解TLS/SSL证书过程的关键是，虽然你通常不会在计算机上存储吉姆体育用品店的公钥，但是认可的证书颁发机构的公钥确实存储在你的浏览器或操作系统中。这些存储在所谓的**根证书**中。

因此，当吉姆体育用品店向你提供其TLS/SSL证书时，你可以通过浏览器或操作系统中的根证书验证证书颁发机构的数字签名。如果签名有效，你可以相对确定证书上的公钥确实属于吉姆体育用品店。在此基础上，与吉姆体育用品店建立安全通信协议就变得容易了。
密钥分发对于吉姆体育用品店来说现在变得非常简单了。不难看出，密钥管理也变得更加简化。吉姆体育用品店不再需要存储成千上万的密钥，它只需要存储一个私钥，这个私钥允许它为其SSL证书上的公钥制作签名。每当顾客访问吉姆体育用品店的网站时，他们可以从这个公钥建立一个安全的通信会话。顾客也不需要存储任何信息（除了在他们的操作系统和浏览器中认可的证书授权机构的公钥之外）。

## 哈希函数
<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

哈希函数在密码学中无处不在。它们既不是对称方案也不是非对称方案，但它们自成一类密码学分类。

我们在第4章中已经遇到了哈希函数，当时是在创建基于哈希的认证消息时。它们在数字签名的上下文中也很重要，尽管原因略有不同：数字签名通常是在某个（加密的）消息的哈希值上进行的，而不是实际的（加密的）消息。在这一节中，我将提供关于哈希函数的更详细介绍。

让我们开始定义哈希函数。**哈希函数**是任何可以高效计算的函数，它接受任意大小的输入并产生固定长度的输出。

**加密哈希函数**只是一种对密码学应用有用的哈希函数。加密哈希函数的输出通常称为**哈希**、**哈希值**或**消息摘要**。

在密码学的上下文中，“哈希函数”通常指的是加密哈希函数。从现在开始，我将采用这种做法。

一个流行的哈希函数示例是**SHA-256**（安全哈希算法256）。无论输入的大小（例如，15位、100位或10,000位），这个函数都将产生一个256位的哈希值。下面你可以看到SHA-256函数的一些示例输出。

* “Hello”: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969
* “52398”: a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90
* “Cryptography is fun”: 3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c

所有的输出都是以十六进制格式精确表示的256位（每个十六进制数字可以由四个二进制数字表示）。所以即使你将托尔金的《指环王》一书输入到SHA-256函数中，输出仍然是256位。

像SHA-256这样的哈希函数在密码学中被用于各种目的。哈希函数所需的属性真的取决于特定应用的上下文。在密码学中，哈希函数通常需要两个主要属性：<sup>[6](#footnote6)</sup>

1.	抗碰撞性
2.	隐藏性

如果找到两个值x和y，使得x ≠ y，但H(x) = H(y)是不可行的，则称哈希函数H为**抗碰撞性**的。
抗碰撞哈希函数在软件验证中非常重要，例如，在验证比特币核心（Bitcoin Core）0.21.0 Windows版本（一个用于处理比特币网络流量的服务器应用程序）的合法性时就非常重要。为了验证软件的合法性，你需要执行以下主要步骤：
1. 首先，你需要下载并导入一个或多个比特币核心贡献者的公钥到可以验证数字签名的软件中（例如，Kleopetra）。你可以在[这里](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt)找到这些公钥。建议你使用多个贡献者的公钥来验证比特币核心软件。
2. 接下来，你需要验证你导入的公钥。至少你应该采取的一个步骤是验证你找到的公钥是否与在其他多个位置发布的公钥相同。例如，你可以咨询公钥所有者的个人网页、Twitter页面或Github页面。通常，这种公钥比较是通过比较公钥的短哈希（即指纹）来完成的。
3. 接下来，你需要从它们的[网站](www.bitcoincore.org)下载比特币核心的可执行文件。将会有适用于Linux、Windows和MAC操作系统的包。
4. 接下来，你需要找到两个发布文件。第一个包含了你下载的可执行文件的官方SHA-256哈希，以及所有其他发布包的哈希。另一个发布文件将包含各个贡献者对包含包哈希的发布文件的签名。这两个发布文件应该位于比特币核心网站上。
5. 接下来，你需要在自己的电脑上计算从比特币核心网站下载的可执行文件的SHA-256哈希。然后，将这个结果与官方包哈希进行比较。它们应该是相同的。
6. 最后，你需要验证一个或多个数字签名是否确实对应于你导入的一个或多个公钥（比特币核心的发布不总是由所有人签名）。你可以使用Kleopetra等应用程序来完成这一步。

这个软件验证过程有两个主要好处。首先，它确保了从比特币核心网站下载时没有传输错误。其次，它确保没有攻击者能够通过黑客攻击比特币核心网站或拦截流量，让你下载修改过的恶意代码。

上述软件验证过程如何确切地防止这些问题呢？

如果你认真验证了你导入的公钥，那么你可以相当确定这些公钥确实是他们的，并且没有被泄露。鉴于数字签名具有存在性不可伪造性，你知道只有这些贡献者才能在发布文件上对官方包哈希进行数字签名。

假设你下载的发布文件上的签名检查无误。你现在可以将你本地计算出的Windows可执行文件的哈希值与正确签名的发布文件中包含的哈希值进行比较。由于你知道SHA-256哈希函数是抗碰撞的，匹配意味着你的可执行文件与官方可执行文件完全相同。

现在让我们转向哈希函数的第二个常见属性：隐藏性。如果对于从非常大的范围内随机选择的任何x，仅给定H(x)时找到x是不可行的，则称哈希函数H具有隐藏性。
在下面，您可以看到我写的一条消息的SHA-256输出。为了确保足够的随机性，消息的末尾包含了一个随机生成的字符串。鉴于SHA-256具有隐藏属性，没有人能够解读这条消息。
* b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded

但我不会让你们悬念直到SHA-256变得更弱。我写的原始消息如下：

* “这是一个非常随机的消息，或者说有点随机。这个开始部分不是，但我会以一些相对随机的字符结束，以确保一个非常不可预测的消息。XLWz4dVG3BxUWm7zQ9qS”。

哈希函数具有隐藏属性的一个常见用途是在密码管理中（抗碰撞性对这个应用也很重要）。任何像Facebook或Google这样的体面的在线账户服务都不会直接存储你的密码来管理对你账户的访问。相反，它们只会存储该密码的哈希值。每次你在浏览器上输入密码时，首先会计算一个哈希值。只有这个哈希值被发送到服务提供商的服务器并与后端数据库中存储的哈希值进行比较。隐藏属性可以帮助确保攻击者无法从哈希值中恢复它。

当然，通过哈希管理密码只有在用户实际选择了难以破解的密码时才有效。隐藏属性假设x是从一个非常大的范围内随机选择的。选择像“1234”、“mypassword”或你的生日日期这样的密码不会提供任何真正的安全性。存在长列表的常见密码及其哈希值，攻击者可以利用这些列表，如果他们曾经获得了你密码的哈希值。这类攻击被称为**字典攻击**。如果攻击者知道你的一些个人细节，他们也可能尝试一些有根据的猜测。因此，你总是需要长的、安全的密码（最好是来自密码管理器的长的、随机字符串）。

有时候，一个应用可能需要一个既具有抗碰撞性又具有隐藏性的哈希函数。但肯定不总是需要的。例如，我们讨论的软件验证过程，只要求哈希函数显示出抗碰撞性，隐藏并不重要。

虽然在密码学中寻求的哈希函数的主要属性是抗碰撞性和隐藏性，在某些应用中也可能需要其他类型的属性。

### 注释
[^1]: Whitfield Diffie和Martin Hellman，“密码学的新方向”，*IEEE信息理论交易* IT-22 (1976)，页 644–654，第644页 [^1]。

[^2]: Ralph Merkle也在“不安全通道上的安全通信”中讨论了一个密钥交换协议，*计算机协会通讯*，21 (1978), 294–99。虽然Merkle实际上在Diffie和Hellman的论文之前提交了这篇论文，但它后来才被发表。Merkle的解决方案不像Diffie-Hellman的那样具有指数级安全性 [^2]。

[^3]: Ron Rivest, Adi Shamir和Leonard Adleman，“获取数字签名和公钥密码系统的方法”，*计算机协会通讯*，21 (1978)，页 120–26 [^3]。

[^4]: Simon Singh提供了这些发现的良好历史，《密码书》，Fourth Estate (伦敦, 1999)，第6章 [^4]。
[^5]: 任何试图实现不可否认性的方案，这是我们在*第1章*中讨论的另一个主题，其基础需要涉及数字签名[^5]。
[^6]: “隐藏”术语并不是常用语，而是特别引用自Arvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller和Steven Goldfeder的*比特币和加密货币技术*，普林斯顿大学出版社（普林斯顿，2016年），第1章[^6]。

# RSA密码系统
<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

虽然对于大多数人来说，对称加密通常相对直观，但非对称加密通常不是这样。尽管你可能对之前章节提供的高层描述感到舒适，你可能还在想什么是单向函数以及它们是如何确切用于构建非对称方案的。

在本章中，我将通过深入探讨一个具体的例子，即RSA密码系统，来揭开非对称加密的一些神秘面纱。在第一节中，我将介绍RSA问题所基于的因式分解问题。然后，我将涵盖数论中的一些关键结果。在最后一节中，我们将把这些信息综合起来，解释RSA问题以及如何使用它来创建非对称加密方案。

增加我们讨论的深度并非易事。它需要引入相当多的数论定理和命题。但不要让数学吓到你。通过这个讨论将显著提高你对非对称加密基础的理解，这是值得投资的。

现在让我们首先转向因式分解问题。

## 因式分解问题
<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

当你将两个数相乘，比如a和b，我们将数a和b称为**因数**，结果称为**乘积**。尝试将一个数N写成两个或更多因数的乘积被称为**因式分解**或**分解**。<sup>[1](#footnote1)</sup> 你可以将任何需要这样做的问题称为**因式分解问题**。

大约2500年前，希腊数学家欧几里得（Euclid of Alexandria）发现了一个关于整数因式分解的关键定理。它通常被称为**唯一因式分解定理**，其内容如下：

*定理1*。每个大于1的整数N要么是一个质数，要么可以表示为质因数的乘积。

这句话的后半部分意味着，你可以取任何一个大于1的非质数整数N，并将其写成质数的乘积。下面是几个非质数整数写成质因数乘积的例子。

* 18 = 2 • 3 • 3 = 2 • 3<sup>2</sup>
* 84 = 2 • 2 • 3 • 7 = 2<sup>2</sup> • 3 • 7
* 144 = 2 • 2 • 2 • 2 • 3 • 3 = 2<sup>4</sup> • 3<sup>2</sup>
对于上述所有三个整数，计算它们的质因数相对容易，即使你只给定了N。你从最小的质数，即2开始，看整数N可以被它除几次。然后，你继续测试N被3、5、7等的可除性。你继续这个过程，直到你的整数N被写为只有质数的乘积。
以整数84为例。下面你可以看到确定其质因数的过程。在每一步中，我们取出剩余的最小质因数（在左边）并确定要被分解的剩余项。我们继续，直到剩余项也是一个质数。在每一步中，84的当前分解在最右边显示。

* 质因数 = 2：剩余项 = 42 	(84 = 2 • 42)
* 质因数 = 2：剩余项 = 21 	(84 = 2 • 2 • 21)
* 质因数 = 3：剩余项 = 7 		(84 = 2 • 2 • 3 • 7)
* 由于7是一个质数，结果是 2 • 2 • 3 • 7，或 2<sup>2</sup> • 3 • 7。

假设现在N非常大。将N分解成其质因数有多困难？

这真的取决于N。例如，假设N是50,450,400。虽然这个数字看起来令人生畏，但计算并不复杂，可以很容易地手工完成。如上所述，你只需从2开始，然后继续前进。下面，你可以以类似上述的方式看到这个过程的结果。

* 2: 25,225,200 	(50,450,400 = 2 • 25,225,200)
* 2: 12,612,600 	(50,450,400 = 2<sup>2</sup> • 12,612,600)
* 2: 6,306,300 		(50,450,400 = 2<sup>3</sup> • 6,306,300)
* 2: 3,153,150 		(50,450,400 = 2<sup>4</sup> • 3,153,150)
* 2: 1,576,575 		(50,450,400 = 2<sup>5</sup> • 1,576,575)
* 3: 525,525 		(50,450,400 = 2<sup>5</sup> • 3 • 525,525)
* 3: 175,175 		(50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 175,175)
* 5: 35,035 		(50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5 • 35,035)
* 5: 7,007		    (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7,007)
* 7: 1,001 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7 • 1,001) * 7: 143 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 143)
* 11: 13 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 11 • 13)
* 由于13是一个质数，结果是2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 11 • 13。

手工解决这个问题需要一些时间。当然，计算机可以在一小部分秒内完成所有这些计算。实际上，计算机甚至可以在一小部分秒内分解极大的整数。

然而，有一些例外。假设我们首先随机选择两个非常大的质数。通常将这些质数标记为p和q，我在这里也将采用这种约定。

具体来说，假设p和q都是1024位的质数，并且它们确实需要至少1024位才能表示（所以第一位必须是1）。所以，例如，37不能是其中的一个质数。你当然可以用1024位来表示37。但显然*你不需要*这么多位来表示它。你可以用任何有6位或更多的字符串来表示37。（在6位中，37将被表示为100101）。

重要的是要理解如果在上述条件下选择p和q，它们有多大。作为一个例子，我在下面选择了一个随机质数，它需要至少1024位来表示。

* 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

假设现在在随机选择质数p和q之后，我们将它们相乘以获得一个整数N。因此，这个后来的整数是一个2048位数，它需要至少2048位来表示。它比p或q大得多。
假设你只给一台计算机N，并要求它找到N的两个1024位质数因子。计算机发现p和q的概率极其微小。你可以说，出于所有实际目的，这是不可能的。即使你使用超级计算机或者一网络的超级计算机，情况也是如此。

首先，假设计算机尝试通过循环遍历1024位数字来解决问题，在每种情况下测试它们是否为质数以及它们是否是N的因子。那么要测试的质数集大约是1.265 • 10<sup>305</sup>。<sup>[2](#footnote2)</sup>

即使你利用地球上所有的计算机尝试以这种方式找到并测试1024位质数，成功找到N的一个质数因子的机会也是十亿分之一，这需要的计算时间远远超过宇宙的年龄。

现实中，计算机可以比刚刚描述的粗略程序做得更好。存在几种算法，计算机可以应用这些算法更快地进行因式分解。然而，重点是，即使使用这些更高效的算法，计算机的任务仍然是计算上不可行的。<sup>[3](#footnote3)</sup>

重要的是，刚刚描述的条件下的因式分解难度基于这样一个假设：不存在用于计算质数因子的计算效率高的算法。我们实际上无法证明不存在高效的算法。尽管如此，这个假设非常合理：尽管经过数百年的广泛努力，我们还没有找到这样的计算效率高的算法。

因此，在某些情况下，因式分解问题可以合理地假设为一个难题。特别是当p和q是非常大的质数时，它们的乘积N不难计算；但仅给定N的因式分解实际上是不可能的。

## 数论结果
<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

不幸的是，因式分解问题不能直接用于非对称加密方案。然而，我们可以使用一个更复杂但相关的问题来实现这一效果：RSA问题。

要理解RSA问题，我们需要理解数论中的一些定理和命题。这些内容在本节的三个小节中介绍：（1）N的阶，（2）模N的可逆性，（3）欧拉定理。

这三个小节中的一些材料已经在*第3章*中介绍过了。但我将在这里为方便起见重新陈述这些材料。

### N的阶

如果整数a与整数N的最大公约数是1，则称整数a是**互质**或与N是**相对质数**。虽然按照惯例1不是质数，但它是每个整数的互质数（-1也是）。

例如，考虑a = 18和N = 37的情况。这些显然是互质的。同时能被18和37整除的最大整数是1。相比之下，考虑a = 42和N = 16的情况。这些显然不是互质的。两个数字都可以被2整除，这大于1。
我们现在可以这样定义N的阶。假设N是一个大于1的整数。那么，**N的阶**是所有与N互质的数的数量，对于每个互质的数a，以下条件成立：1 ≤ a < N。
例如，如果N = 12，那么1, 5, 7, 和 11是唯一满足上述要求的互质数。因此，12的阶等于4。

假设N是一个质数。那么任何小于N但大于或等于1的整数都与它互质。这包括以下集合中的所有元素：{1,2,3….,N – 1}。因此，当N是质数时，N的阶是N – 1。这在命题1中有说明，其中φ(N)表示N的阶。

**命题1**。当N是质数时，φ(N) = N – 1

假设N不是质数。那么，你可以使用**欧拉Phi函数**来计算它的阶。虽然计算一个小整数的阶相对简单，但对于较大的整数，欧拉Phi函数变得特别重要。欧拉Phi函数的命题如下所述。

*定理2*。设N等于p<sub>1</sub><sup>e_1</sup> • p<sub>2</sub><sup>e_2</sup> • … • p<sub>i</sub><sup>e_i</sup> • … • p<sub>n</sub><sup>e_n</sup>，其中集合{p<sub>i</sub>}包含N的所有不同质因数，每个e_i表示质因数p<sub>i</sub>对N出现的次数。那么，φ(N) = p<sub>1</sub><sup>e_1 - 1</sup> • (p<sub>1</sub> - 1) • p<sub>2</sub><sup>e_2 - 1</sup> • (p<sub>2</sub> - 1) • … • p<sub>n</sub><sup>e_n - 1</sup> • (p<sub>n</sub> - 1)。

*定理2*表明，一旦你将任何非质数N分解成其不同的质因数，计算N的阶就变得简单了。

例如，假设N = 270。这显然不是一个质数。将N分解成其质因数得到表达式：2 • 3<sup>3</sup> • 5。根据欧拉Phi函数，N的阶如下：

* φ(N) = 2<sup>1 – 1</sup> (2 – 1) + 3<sup>3 – 1</sup> (3 – 1) + 5<sup>1 – 1</sup> (5 – 1) = 1 (1) + 9 (2) + 1 (4) = 1 + 18 + 4 = 23
假设接下来N是两个质数p和q的乘积。上述的*定理2*，则表明N的阶如下：p<sup>1 – 1</sup> (p – 1) x q<sup>1 – 1</sup> (q – 1) = (p – 1) x (q – 1)。这是RSA问题特别关键的一个结果，并在下面的*命题2*中说明。
*命题2*。如果N是两个质数p和q的乘积，那么N的阶是乘积(p – 1) x (q – 1)。

举例来说，假设N = 119。这个整数可以分解为两个质数，即7和17。因此，欧拉的Phi函数表明119的阶如下：

* φ(119) = (7 – 1) • (17 – 1) = 6 • 16 = 96。

换句话说，整数119在1到119的范围内有96个互质数。实际上，这个集合包括了从1到119的所有整数，这些整数不是7或17的倍数。

从这里开始，让我们用**C<sub>N</sub>**表示决定N阶的互质数集合。对于我们的例子N = 119，集合**C<sub>119</sub>**太大无法完全列出。但是其中的一些元素如下：**C<sub>119</sub>** = {1,2,….6,8….13,15,16,18,….,33,35….,96}。

### 模N的可逆性

我们可以说，如果存在至少一个整数b使得a x b模N = 1模N，那么整数a是**模N可逆的**。任何这样的整数b被称为a的**逆**（或**乘法逆**）通过模N约简。

例如，假设a = 5且N = 11。有许多整数可以乘以5，使得5 x b模11 = 1模11。例如，考虑整数20和31。可以很容易看出，这两个整数都是5对于模11约简的逆。

* 5 x 20模11 = 100模11 = 1模11
* 5 x 31模11 = 155模11 = 1模11

虽然5在模11约简下有许多逆，但你可以证明只存在一个正逆小于11。实际上，这不仅仅是我们特定例子的结果，而是一个普遍结果。

*命题3*。如果整数a是模N可逆的，那么必须有一个且仅有一个正逆小于N。（所以，这个唯一的a的逆必须来自集合{1,…,N – 1}）。
让我们用a<sup>-1</sup>来表示命题3中a的唯一逆元。当a = 5且N = 11时，你可以看到a<sup>-1</sup> = 9，因为5 x 9 mod 11 = 45 mod 11 = 1 mod 11。
注意，在我们的例子中，你也可以通过简单地将a的任何其他逆元通过模11来减少，得到a<sup>-1</sup>的值9。例如，20 mod 11 = 31 mod 11 = 9 mod 11。所以，当一个整数a > N在模N下是可逆的时候，那么a mod N也必须在模N下是可逆的。

并不是所有情况下a的逆元都存在模N的约简中。例如，假设a = 2且N = 8。没有任何b，或者具体说没有任何a<sup>-1</sup>，使得2 x b mod 8 = 1 mod 8。这是因为任何b的值总会产生2的倍数，所以没有任何除以8的操作能够产生余数等于1。

我们如何确切地知道某个整数a在给定的N下是否有逆元？正如你可能在上面的例子中注意到的，2和8之间的最大公约数高于1，即2。这实际上说明了以下一般结果：

*命题4*。一个整数a在模N下的约简中存在逆元，并且特别是存在一个小于N的唯一正逆元，当且仅当a和N之间的最大公约数为1（即，如果它们是互质的）。

对于a = 5且N = 11的情况，我们得出结论a<sup>-1</sup> = 9，因为5 x 9 mod 11 = 45 mod 11 = 1 mod 11。重要的是要注意，反过来也是正确的。也就是说，当a = 9且N = 11时，a<sup>-1</sup> = 5。

### 欧拉定理

在讨论RSA问题之前，我们需要理解另一个关键定理，即**欧拉定理**。它声明如下：

*定理3*。假设两个整数a和N是互质的。那么，a<sup>φ(N)</sup> mod N = 1 mod N。

这是一个了不起的结果，但一开始可能有点令人困惑。让我们通过一个例子来理解它。

假设a = 5且N = 7。这些确实是互质的，正如欧拉定理所要求的。我们知道7的阶等于6，因为7是一个质数（见**命题1**）。

欧拉定理现在声明的是，5<sup>6</sup> mod 7必须等于1 mod 7。以下是展示这确实是真实的计算。

* 5<sup>6</sup> mod 7 = 15,625 mod 7 = 1 mod N

整数7除以15,624共计2,233次。因此，16,625除以7的余数是1。

接下来，使用欧拉的Phi函数，*定理2*，你可以推导出下面的*命题5*。
*命题 5*。对于任何正整数a和b，有φ(a • b) = φ(a) • φ(b)。
我们不会展示为什么会这样。但只需注意，你已经通过φ(p • q) = φ(p) • φ(q) = (p – 1) • (q – 1)的事实看到了这个命题的证据，当p和q为质数时，如*命题 2*中所述。

欧拉定理与*命题 5*结合有重要的含义。例如，看看下面的表达式中发生了什么，其中a和N是互质的。

* a<sup>2 • φ(N)</sup> mod N = a<sup>φ(N)</sup> • a<sup>φ(N)</sup> mod N = 1 • 1 mod N = 1 mod N
* a<sup>φ(N) + 1</sup> mod N = a<sup>φ(N)</sup> • a<sup>1</sup> mod N = 1 • a<sup>1</sup> mod N = a mod N
* a<sup>8 • φ(N) + 3</sup> mod N = a<sup>8 • φ(N)</sup> • a<sup>3</sup>  mod N = 1 • a<sup>3</sup>  mod N = a<sup>3</sup>  mod N

因此，欧拉定理和*命题 5*的结合允许我们简单地计算许多表达式。一般来说，我们可以将洞见总结为*命题 6*。

*命题 6*。a<sup>x</sup> mod N = a<sup>x mod φ(N)</sup>

现在我们必须在一个棘手的最后一步中把一切整合在一起。

正如N有一个阶φ(N)，它包括集合**C<sub>N</sub>**的元素，我们知道整数φ(N)反过来也必须有一个阶和一组互质数。设φ(N) = R。然后我们知道也有一个φ(R)的值和一组互质数**C<sub>R</sub>**。

假设我们现在从集合**C<sub>R</sub>**中选择一个整数e。我们从*命题 3*知道，这个整数e在R以下只有一个唯一的正逆元。也就是说，e在集合**C<sub>R</sub>**中有一个唯一的逆元。我们称这个逆元为d。根据逆元的定义，这意味着e • d = 1 mod R。

我们可以使用这个结果对我们原始的整数N做出声明。这总结在*命题 7*中。

*命题 7*。假设e • d mod φ(N) = 1 mod φ(N)。那么对于集合**C<sub>N</sub>**的任何元素a，必须有a<sup>e • d mod φ(N)</sup> = a<sup>1 mod φ(N)</sup> = a mod N。

我们现在拥有了陈述RSA问题所需的所有数论结果。

## RSA密码系统
<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>
我们现在准备阐述RSA问题。假设你创建了一组变量，包括p、q、N、φ(N)、e、d和y。称这组变量为Π。它的创建方式如下：
1. 生成两个大小相等的随机质数p和q，并计算它们的乘积N。
2. 通过以下乘积计算N的阶，φ(N)：(p - 1) • (q - 1)。
3. 选择一个大于2的e，使其小于且与φ(N)互质。
4. 通过设置e • d mod φ(N) = 1来计算d。
5. 选择一个小于且与N互质的随机值y。

RSA问题包括找到一个x，使得x<sup>e</sup> = y，同时只给出关于Π的部分信息，即变量N、e和y。当p和q非常大时，通常建议它们的大小为1024位，RSA问题被认为是困难的。鉴于前述讨论，你现在可以看到为什么会这样。

当x<sup>e</sup> mod N = y mod N时，计算x的一个简单方法就是计算y<sup>d</sup> mod N。我们知道y<sup>d</sup> mod N = x mod N，通过以下计算：

* y<sup>d</sup> mod N = x<sup>e • d</sup> mod N = x<sup>e • d mod φ(N)</sup> mod N = x<sup>1 mod φ(N)</sup> mod N = x mod N。

问题在于我们不知道d的值，因为它在问题中没有给出。因此，我们不能直接计算y<sup>d</sup> mod N来产生x mod N。

然而，我们可能能够从N的阶φ(n)间接计算出d，因为我们知道e • d mod φ(N) = 1 mod φ(N)。但按照假设，问题也没有给出φ(N)的值。

最后，阶可以通过质因数p和q间接计算，这样我们最终可以计算出d。但按照假设，p和q的值也没有提供给我们。

严格来说，即使在RSA问题中的因式分解问题很难，我们也不能证明RSA问题也是难的。可能还有其他解决RSA问题的方法，而不仅仅是通过因式分解。然而，通常接受并假设，如果RSA问题中的因式分解问题很难，那么RSA问题本身也是困难的。

如果RSA问题确实很难，那么它产生了一个带有陷门的单向函数。这里的函数是f(g) = g<sup>e</sup> mod N。有了f(g)的知识，任何人都可以轻松计算出特定g = x的值y。然而，仅仅通过知道值y和函数f(g)，几乎不可能计算出特定的值x。例外情况是当你被给予一个信息片段d，即陷门。在那种情况下，你可以简单地计算y<sup>d</sup>来得到x。

让我们通过一个具体的例子来说明RSA问题。我不能选择一个在上述条件下被认为是困难的RSA问题，因为数字会很笨重。相反，这个例子只是为了说明RSA问题通常是如何工作的。
首先，假设你随机选择了两个质数13和31。因此p = 13且q = 31。这两个质数的乘积N等于403。我们可以轻松计算403的阶。它等同于(13 - 1) • (31 - 1) = 360。
接下来，根据RSA问题的第三步，我们需要为360选择一个大于2且小于360的互质数。我们不必随机选择这个值。假设我们选择了103。这是360的一个互质数，因为它与103的最大公约数是1。

现在第四步要求我们计算一个值d，使得103 • d mod 360 = 1。当N的值很大时，手工完成这个任务并不容易。这需要我们使用一种叫做**扩展欧几里得算法**的程序。

虽然我在这里没有展示这个程序，但当e = 103时，它产生的值是7。你可以验证，值对103和7确实满足一般条件e • d mod φ(n) = 1，通过下面的计算。

* 103 • 7 mod 360 = 721 mod 360 = 1 mod 360

重要的是，根据*命题4*，我们知道在1到360之间，没有其他整数d会产生103 • d = 1 mod 360的结果。此外，该命题意味着，为e选择一个不同的值，将产生一个不同的、唯一的d值。

在RSA问题的第五步，我们必须选择一个较小的与403互质的正整数y。假设我们将y设置为2<sup>103</sup>。2的103次方的指数运算产生下面的结果。

* 2<sup>103</sup> mod 403 = 10,141,204,801,825,835,211,973,625,643,008 mod 403 = 349 mod 403

在这个特定示例中的RSA问题现在如下：你被提供了N = 403，e = 103，和y = 349 mod 403。你现在必须计算x，使得x<sup>103</sup> = 349 mod 403。也就是说，你必须找到103次方指数运算之前的原始值是2。

如果我们知道d = 7，计算x将会很容易（至少对于计算机来说）。在这种情况下，你可以如下确定x。

* x = y<sup>7</sup> mod 403 = 349<sup>7</sup> mod 403 = 630,634,881,591,804,949 mod 403 = 2 mod 403

问题是你没有被提供d = 7的信息。当然，你可以从103 • d = 1 mod 360的事实中计算出d。问题是你也没有被告知N的阶= 360。最后，你也可以通过计算以下乘积来计算403的阶：(p – 1) • (q – 1)。但你也没有被告知p = 13和q = 31。
当然，对于这个例子，计算机仍然可以相对容易地解决RSA问题，因为涉及的质数并不大。但是，当质数变得非常大时，它面临的任务几乎是不可能完成的。
我们现在已经介绍了RSA问题，它在某些条件下难以解决的一组条件，以及其背后的数学原理。这一切如何帮助我们理解非对称加密呢？具体来说，我们如何将RSA问题在某些条件下的难度转化为加密方案或数字签名方案？

一种方法是直接采取RSA问题并构建方案。例如，假设你生成了一组如RSA问题中所描述的变量Π，并确保p和q足够大。你将你的公钥设置为(N, e)并与世界分享这些信息。如上所述，你保密p, q, φ(n)和d的值。实际上，d是你的私钥。

任何想要给你发送消息m（m是**C<sub>N</sub>**的一个元素）的人都可以简单地这样加密：c = m<sup>e</sup> mod N。（这里的密文c等同于RSA问题中的y值。）你可以通过计算c<sup>d</sup> mod N来轻松解密这条消息。

你也许会尝试以同样的方式创建一个数字签名方案。假设你想要发送一条带有数字签名S的消息m。你可以简单地设置S = m<sup>d</sup> mod N并将(m,S)对发送给接收者。任何人都可以通过检查S<sup>e</sup> mod N = m mod N来验证数字签名。然而，任何攻击者在不拥有d的情况下，都很难为一条消息创建有效的S。

不幸的是，将本身就是一个难题的RSA问题转化为加密方案并不是这么直接。对于直接的加密方案，你只能选择N的互质数作为你的消息。这并不会留给我们许多可能的消息，肯定不足以进行标准通信。此外，这些消息必须被随机选择。这似乎有些不切实际。最后，任何被选择两次的消息都会产生完全相同的密文。这在任何加密方案中都极其不受欢迎，并且不符合加密中任何严格的现代安全标准。

对于我们直接的数字签名方案，问题变得更糟。就目前而言，任何攻击者都可以通过首先选择N的一个互质数作为签名，然后计算相应的原始消息来轻松伪造数字签名。这显然破坏了存在性不可伪造的要求。

尽管如此，通过增加一点巧妙的复杂性，RSA问题可以用来创建一个安全的公钥加密方案以及一个安全的数字签名方案。我们在这里不会详细介绍这些构造。<sup>[4](#footnote4)</sup> 重要的是，这种额外的复杂性并不改变这些方案所基于的基本RSA问题。

### 注释

[^1]: 因式分解也可以用于处理除了数字之外的其他类型的数学对象。例如，分解多项式表达式x^2 – 2x + 1可能很有用。在我们的讨论中，我们将只关注数字的因式分解，特别是整数[^1]。
[^2]: 根据素数定理，小于或等于N的素数数量大约为N/ln(N)。这意味着你可以通过2^1024/ln(2^1024) - 2^1023/ln(2^1023)来近似计算1024位长度的素数数量，其结果约为1.265 x 10^305 [^2]。

# 贡献
<partId>4556aab1-4876-552a-b6db-df6837bbf27a</partId>

## 关于
<chapterId>ff08a57b-740f-5d7e-8cf2-81db0908166e</chapterId>

欢迎任何贡献。在此之前，请查看下面的背景信息，了解我对书籍的计划以及贡献的指南。

### 当前计划

我对书籍进一步发展的当前计划如下：

- 创建一个最终章节，深入讨论实际的密码学应用，如传输层安全、洋葱路由以及比特币中的价值交换
- 创建更好、更多的图表来支持书面讨论
- 使用LaTeX数学或其他排版应用程序来进行正式符号表示（而不仅仅是Markdown）

### 贡献指南

如果你对现有文本有小的更正或建议，你可以创建一个拉取请求或提出一个问题。如果你创建一个拉取请求，请遵循以下指南：

- 在你的存储库的一个单独分支上创建提交
- 清晰地标记提交
- 为逻辑上不同的问题创建单独的提交，以简化审查过程

如果你对书籍有更实质性的建议，请提出一个问题或直接通过 **jaburgers@protonmail.com** 与我联系。

### 许可

此存储库中的作品根据创作共用署名-非商业性-禁止演绎 4.0 国际许可证（CC BY-NC-ND 4.0）授权。

你可以在[这里](https://creativecommons.org/licenses/by-nc-nd/4.0/)找到许可证的简短描述。

你可以在[这里](https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode)找到许可证的完整版本。

## 符号表示
<chapterId>07250f8d-ad7c-5531-a70c-4417d6d1b865</chapterId>

### 关键术语

入门关键术语通过加粗来引入。例如，引入Rijndael密码作为关键术语的方式如下：**Rijndael密码**。

除非是专有名词或从讨论中明显可以看出其含义，否则明确定义关键术语。

通常在引入关键术语时给出定义，尽管有时直到稍后才给出定义更为方便。

### 强调的单词和短语

通过斜体来强调单词和短语。例如，“记住你的密码”将如下表示：*记住你的密码*。

### 正式符号

正式符号主要涉及变量、随机变量和集合。

* 变量：通常只用小写字母表示（例如，“x”或“y”）。有时为了清晰而大写（例如，“M”或“K”）。
* 随机变量：总是用大写字母表示（例如，“X”或“Y”）。
* 集合：这些总是用粗体大写字母表示（例如，**S**）