---
name: 形式的な暗号学への導入
goal: 暗号学の科学と実践に深く潜るための導入。
objectives:
  - ビール暗号と現代の暗号化方法を探求し、暗号学の基本的かつ歴史的な概念を理解する。
  - 数論、群、および体に深く潜り、暗号学の基礎となる主要な数学的概念を習得する。
  - RC4ストリーム暗号と128ビットキーを使用したAESを学び、対称暗号化アルゴリズムについて理解を深める。
  - RSA暗号システム、鍵配布、およびハッシュ関数を調査し、非対称暗号化を探究する。

---
# 暗号学への深い潜入

暗号学教育において、良い中間地点を提供する資料を見つけるのは難しい。

一方で、数学、論理学、またはその他の形式的な分野に強い背景を持つ人々にしかアクセスできない長く、形式的な論文がある。他方、少しでも好奇心がある人には多くの詳細を隠してしまう非常に高度な導入がある。

この暗号学への導入は、その中間地点を捉えることを目指している。暗号学に新しい人にとっては比較的挑戦的で詳細であるべきだが、典型的な基礎的な論文のような深い穴ではない。

+++

# 暗号学への導入
<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## 短い説明
<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

この本は、暗号学の科学と実践への深い潜入を提供する。可能な限り、形式的な展開よりも概念的な展開に焦点を当てる。

> このコースは[JWBurgersのリポジトリ](https://github.com/JWBurgers/An_Introduction_to_Cryptography)に基づいています。すべての権利は彼にあります。コンテンツはまだ完成しておらず、JWburgerが同意すれば、どのように統合できるかを示すためにここにあります。

### 動機と目的

暗号学教育において、良い中間地点を提供する資料を見つけるのは難しい。

一方で、数学、論理学、またはその他の形式的な分野に強い背景を持つ人々にしかアクセスできない長く、形式的な論文がある。他方、少しでも好奇心がある人には多くの詳細を隠してしまう非常に高度な導入がある。

この暗号学への導入は、その中間地点を捉えることを目指している。暗号学に新しい人にとっては比較的挑戦的で詳細であるべきだが、典型的な基礎的な論文のような深い穴ではない。

### 対象読者

開発者から知的好奇心旺盛な人まで、暗号学について表面的な理解以上を望むすべての人にとって有用な本である。暗号学の分野をマスターすることが目標であれば、この本も良い出発点となる。

### 読書ガイド

現在、この本には7章が含まれている: 「暗号学とは何か？」（第1章）、 「暗号学の数学的基礎 I」（第2章）、 「暗号学の数学的基礎 II」（第3章）、 「対称暗号」（第4章）、 「RC4とAES」（第5章）、 「非対称暗号」（第6章）、そして「RSA暗号システム」（第7章）。最終章「実践における暗号学」はまだ追加される予定で、トランスポート層セキュリティ、オニオンルーティング、ビットコインの価値交換システムを含む様々な暗号学的アプリケーションに焦点を当てる。
数学の強いバックグラウンドがない限り、数論はこの本で最も難しいトピックの一つでしょう。第3章でその概要を提供しており、第5章のAESの解説と第7章のRSA暗号システムでも登場します。
この本のこれらの部分の形式的な詳細に本当に苦労している場合は、最初はそれらを高いレベルで読むことをお勧めします。

### 謝辞

この本を形作る上で最も影響力のある本は、Jonathan KatzとYehuda Lindellの_Introduction to Modern Cryptography_、CRC Press（フロリダ州ボカラトン）、2015年です。Courseraで「Cryptography」というコースが利用可能です。

この本の概要を作成する上で役立った主な追加の情報源は、Simon Singhの_The Code Book_、Fourth Estate（ロンドン、1999年）; Christof PaarとJan Pelzlの_Understanding Cryptography_、Springer（ハイデルベルク、2010年）およびPaarによる本に基づいたコース「Introduction to Cryptography」（https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQgで利用可能）; そしてBruce SchneierのApplied Cryptography、第2版、2015年（インディアナポリス、IN：John Wiley & Sons）です。

これらの情報源から非常に具体的な情報と結果を引用するだけですが、ここで一般的な負債を認めたいと思います。

この導入後に暗号学に関するより高度な知識を求めたい読者には、KatzとLindellの本を強くお勧めします。CourseraのKatzのコースは、本よりもややアクセスしやすいです。

### 貢献

プロジェクトをサポートする方法に関するいくつかのガイドラインについては、リポジトリの貢献ファイルをご覧ください。

# 暗号学とは何か？
<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

暗号学の分野への問い合わせを、その歴史の中で最も魅力的で楽しいエピソードの一つであるビール暗号から始めましょう。<sup>[1](#footnote1)</sup>

ビール暗号の話は、私の意見では、現実よりもフィクションである可能性が高いです。しかし、次のように起こったとされています。

## ビール暗号
<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>

1820年と1822年の冬に、Thomas J. Bealeという男性がバージニア州リンチバーグにあるRobert Morrissが所有する宿に滞在しました。Bealeの2回目の滞在の終わりに、彼は貴重な書類が入った鉄の箱をMorrissに安全保管するように渡しました。

数ヶ月後、Morrissは1822年5月9日付けのBealeからの手紙を受け取りました。それは鉄の箱の内容の大きな価値を強調し、Morrissにいくつかの指示を関連付けました：もしBealeや彼の関係者がその箱を請求しに来なかった場合、彼は手紙の日付からちょうど10年後（つまり1832年5月9日）にそれを開けるべきです。箱の中には通常のテキストで書かれたいくつかの書類が含まれています。しかし、他のいくつかは、「鍵」の助けなしには理解できないでしょう。この「鍵」は、1832年6月にBealeの名前のない友人によってMorrissに届けられることになっていました。
明確な指示にもかかわらず、モリスは1832年の5月にその箱を開けず、ビールの謎の友人もその年の6月には現れませんでした。ついに宿屋の主人が箱を開ける決心をしたのは1845年のことでした。箱の中で、モリスはビールと彼の仲間たちが西部で金と銀を発見し、それをいくつかの宝石と共に安全のために埋めたことを説明するメモを見つけました。さらに、箱には3つの**暗号文**が含まれていました。つまり、解読するためには**暗号鍵**、つまり秘密とそれに伴うアルゴリズムが必要な、コードで書かれたテキストです。この暗号文を解読するプロセスは**復号**として知られており、ロックするプロセスは**暗号化**として知られています。（第3章で説明されているように、cipherという用語は様々な意味を持ち得ます。"Beale ciphers"の名前では、それは暗号文の略です。）
モリスが鉄の箱で見つけた3つの暗号文は、それぞれカンマで区切られた一連の数字で構成されています。ビールのメモによると、これらの暗号文は別々に宝の場所、宝の内容、そして宝の正当な相続人とその分け前のリストを提供します（後者の情報は、ビールと彼の仲間たちが箱を請求しに来なかった場合に関連します）。

モリスは20年間にわたって3つの暗号文を解読しようと試みました。鍵があればこれは簡単でした。しかし、モリスは鍵を持っておらず、元のテキスト、つまり暗号学で一般的に呼ばれる**平文**を回復する試みに成功しませんでした。

人生の終わりに近づき、モリスは1862年に箱を友人に渡しました。この友人は後に1885年に、J.B. Wardという偽名の下で小冊子を出版しました。それには箱の（推定される）歴史、3つの暗号文、そして彼が見つけた2番目の暗号文の解決策が含まれていました。（どうやら、各暗号文ごとに1つの鍵があり、ビールがモリスへの手紙で当初示唆していたように、3つの暗号文すべてに作用する1つの鍵があるわけではないようです。）

*図2*以下で2番目の暗号文を見ることができます。<sup>[2](#footnote2)</sup> この暗号文の鍵はアメリカ独立宣言です。復号手順は、以下の2つのルールを適用することに帰着します：

* 暗号文の任意の数nについて、アメリカ独立宣言のn番目の単語を見つける
* 見つけた単語の最初の文字で数nを置き換える


*図1: ビール暗号 no. 2*

![図1: ビール暗号 no. 2](assets/Figure1-1.webp "図1: ビール暗号 no. 2")


例えば、2番目の暗号文の最初の数字は115です。独立宣言の115番目の単語は「instituted」なので、平文の最初の文字は「i」です。暗号文は直接的に単語の間隔や大文字化を示していません。しかし、最初の数単語を復号した後、論理的に平文の最初の単語が単に「I」であったと推測できます。（平文は「I have deposited in the county of Bedford.」というフレーズで始まります。）
暗号解読後、2番目のメッセージは宝の詳細な内容（金、銀、宝石）を提供し、それがバージニア州ベッドフォード郡で鉄の鍋に入れられ、岩で覆われて埋められたことを示唆しています。人々は良いミステリーが大好きなので、宝の場所を記述したもう一つのベール暗号を解読するために大きな努力が払われてきました。さまざまな著名な暗号学者もそれに挑戦してきました。しかし、現時点では、他の2つの暗号文を解読できた人はいません。

## 現代の暗号学
<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

ベール暗号のようなカラフルな話は、私たちが暗号学に関連付けるもののほとんどです。しかし、現代の暗号学は、これらの歴史的な例と少なくとも4つの重要な点で異なります。

まず、歴史的に暗号学は**秘密性**（または機密性）にのみ関心を持っていました。<sup>[3](#footnote3)</sup> 暗号文は、ベール暗号の場合のように、特定の当事者のみが平文の情報を知ることができるように作成されました。暗号化スキームがこの目的をうまく果たすためには、鍵を持っている場合にのみ暗号文を解読できるようにする必要があります。

現代の暗号学は、秘密性だけでなく、より幅広いテーマに関心を持っています。これらのテーマには主に（1）**メッセージの完全性**—つまり、メッセージが変更されていないことを保証すること、（2）**メッセージの真正性**—つまり、メッセージが特定の送信者から実際に来たことを保証すること、および（3）**否認防止**—つまり、送信者が後でメッセージを送信したことを偽って否定できないようにすること、が含まれます。<sup>[4](#footnote4)</sup>

したがって、心に留めておくべき重要な区別は、**暗号化スキーム**と**暗号スキーム**の間です。暗号化スキームは秘密性にのみ関心があります。暗号化スキームは暗号スキームですが、その逆は真ではありません。暗号スキームは、完全性、真正性、および否認防止を含む暗号学の他の主要なテーマも果たすことができます。

完全性と真正性のテーマは、秘密性と同じくらい重要です。現代の通信システムは、通信の完全性と真正性に関する保証なしには機能することができません。否認防止も、デジタル契約などにおいて重要な懸念事項ですが、秘密性、完全性、真正性ほど広く暗号化アプリケーションで必要とされるわけではありません。

第二に、ベール暗号のような古典的な暗号化スキームは常に、すべての関連する当事者間で共有される1つの鍵を含んでいました。しかし、多くの現代の暗号スキームでは、1つではなく2つの鍵：**プライベート**キーと**パブリックキー**が関与します。前者は任意のアプリケーションでプライベートのままであるべきですが、後者は通常、公知の情報です（したがって、それぞれの名前）。暗号化の領域では、パブリックキーを使用してメッセージを暗号化し、プライベートキーを使用して復号化することができます。

すべての当事者が1つの鍵を共有するスキームを扱う暗号学の分野は**対称暗号学**として知られています。そのようなスキームの単一の鍵は通常、**プライベートキー**（または秘密鍵）と呼ばれます。プライベートキーとパブリックキーのペアが必要なスキームを扱う暗号学の分野は**非対称暗号学**として知られています。これらの分野は、時に**プライベートキー暗号学**および**パブリックキー暗号学**とも呼ばれます（ただし、パブリックキー暗号スキームにもプライベートキーがあるため、混乱を招くことがあります）。
1970年代後半に非対称暗号技術が登場して以来、これは暗号学の歴史において最も重要な出来事の一つであると言えます。これがなければ、Bitcoinを含む現代の通信システムの多くは不可能であったか、少なくとも非常に非現実的であったでしょう。
重要なことに、現代の暗号学は、対称キーと非対称キーの暗号方式の研究だけではありません（それが多くを占めてはいますが）。例えば、暗号学はハッシュ関数や擬似乱数生成器にも関心を持ち、これらの基本要素上に構築されたアプリケーションは、対称キーや非対称キーの暗号技術とは関係ないものもあります。

第三に、ベール暗号などの古典的な暗号方式は、科学というよりも芸術に近かったです。その安全性は、その複雑さに関する直感に大きく依存していました。新たな攻撃方法が見つかると通常は修正されたり、攻撃が特に深刻であれば完全に放棄されたりしました。しかし、現代の暗号学は、暗号方式の開発と分析の両方に対して形式的かつ数学的なアプローチを取る厳密な科学です。<sup>[5](#footnote5)</sup>

具体的には、現代の暗号学は**安全性の証明**に焦点を当てています。暗号方式の安全性の証明は、次の三つのステップで進行します：

1. **安全性の暗号学的定義**の声明、つまり、安全性の目標と攻撃者によってもたらされる脅威のセット。
2. 方式の計算複雑性に関する数学的仮定の声明。例えば、暗号方式には擬似乱数生成器が含まれているかもしれません。これらが存在することを証明することはできませんが、存在すると仮定することができます。
3. 形式的な安全性の概念と任意の数学的仮定に基づいて、方式の**安全性の数学的証明**の提示。

第四に、歴史的に暗号学は主に軍事設定で利用されていましたが、デジタル時代においては私たちの日常活動に浸透してきました。オンラインバンキング、ソーシャルメディアへの投稿、クレジットカードでAmazonから商品を購入すること、友人にビットコインをチップすることなど、暗号学は私たちのデジタル時代の必需品です。

これらの四つの側面を踏まえると、現代の**暗号学**は、敵対的な攻撃からデジタル情報を保護するための暗号方式の形式的な開発と分析に関心を持つ科学として特徴づけることができます。<sup>[6](#footnote6)</sup> ここでのセキュリティは、通信における秘密性、完全性、認証、および/または否認防止の損害を防ぐこととして広く理解されるべきです。

暗号学は、コンピュータシステムの盗難、損害、および悪用を防ぐことに関心を持つ**サイバーセキュリティ**の一分野として最もよく見られます。多くのサイバーセキュリティの懸念は、暗号学とは少しまたは部分的にしか関連がありません。

例えば、会社が高価なサーバーをローカルに保管している場合、盗難や損害からこのハードウェアを保護することが懸念されるかもしれません。これはサイバーセキュリティの懸念ですが、暗号学とはあまり関係がありません。

別の例として、**フィッシング攻撃**は現代における一般的な問題です。これらの攻撃は、人々をだましてメールやその他のメッセージ媒体を通じてパスワードやクレジットカード番号などの機密情報を手放させようとします。暗号学はある程度フィッシング攻撃に対処するのに役立ちますが、包括的なアプローチには暗号学だけを使用する以上のものが必要です。

## オープンコミュニケーション
<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

現代の暗号学は、**オープンコミュニケーション**環境でのセキュリティ保証を提供するように設計されています。もし私たちの通信チャネルが盗聴者がメッセージを操作したり、観察したりすることさえ不可能なほどよく保護されているなら、暗号学は不要です。しかし、ほとんどの通信チャネルは、これほどまでには守られていません。
現代世界におけるコミュニケーションの基盤は、巨大な光ファイバーケーブルのネットワークです。電話をかけたり、テレビを見たり、ウェブを閲覧したりすることは、一般的にこの光ファイバーケーブルのネットワークに依存しています（ごく少数が完全に衛星に依存している場合もあります）。自宅には同軸ケーブル、（非対称）デジタル加入者線、光ファイバーケーブルなど、異なるデータ接続があるかもしれません。しかし、少なくとも先進国では、これら異なるデータ媒体は家の外で迅速に光ファイバーケーブルの巨大なネットワークのノードに接続され、全世界を繋ぎます。例外として、アメリカやオーストラリアのような先進国の一部の遠隔地では、データトラフィックが従来の銅製の電話線を介して大きな距離を移動することもあります。

このケーブルとその支援インフラストラクチャへの物理的なアクセスを防ぐことは不可能です。実際、インターネットの重要な交差点で、様々な国家情報機関によって私たちのほとんどのデータが傍受されていることは既に知られています。これには、Facebookメッセージからあなたが訪れるウェブサイトのアドレスまで、あらゆるものが含まれます。

大規模なデータの監視には、国家情報機関のような強力な敵が必要ですが、資源が少ない攻撃者でも、よりローカルな規模での盗聴を容易に試みることができます。これはワイヤーのタッピングレベルで起こり得ますが、無線通信を傍受する方がはるかに簡単です。

現在、私たちのローカルネットワークデータのほとんどは—自宅であれ、オフィスであれ、カフェであれ—物理的なケーブルを通じてではなく、オールインワンルーターの無線アクセスポイントへと無線波を介して移動します。したがって、攻撃者はあなたのローカルトラフィックを傍受するためにほとんどリソースを必要としません。これは、ほとんどの人がローカルネットワークを介して移動するデータを保護するためにほとんど何もしないため、特に懸念されます。さらに、潜在的な攻撃者は、3G、4G、5Gなどのモバイルブロードバンド接続も標的にすることができます。これらの無線通信は攻撃者にとって簡単な標的です。

したがって、通信チャネルを保護することによって通信を秘密に保つという考えは、現代世界の多くにとって絶望的な幻想です。私たちが知っているすべてのことは、重度の偏執病を正当化します：常に誰かが聞いていると仮定すべきです。そして、暗号化はこの現代の環境である種のセキュリティを得るために私たちが持っている主なツールです。

### 注釈
[^1]: 物語の良い要約については、Simon Singh, *The Code Book*, Fourth Estate (London, 1999), pp. 82-99を参照してください。この物語の短編映画がAndrew Allenによって2010年に制作されました。映画「The Thomas Beale Cipher」はそのウェブサイトで見ることができます [^1]。

[^2]: この画像は、Beale ciphersのWikipediaページで利用可能です [^2]。

[^3]: 正確に言うと、暗号化スキームの重要な応用は秘密性に関係しています。例えば、子供たちはしばしば「楽しみ」のために単純な暗号化スキームを頻繁に使用します。これらの場合、秘密性は実際には問題ではありません [^3]。

[^4]: Bruce Schneier, *Applied Cryptography*, 2nd edn, 2015 (Indianapolis, IN: John Wiley & Sons), p. 2 [^4]。

[^5]: 良い説明については、Jonathan Katz and Yehuda Lindell, *Introduction to Modern Cryptography*, CRC Press (Boca Raton, FL: 2015), 特にpp. 16–23を参照してください [^5]。

[^6]: Katz and Lindell, 同上, p. 3。彼らの特徴付けにはいくつかの問題があると思うので、ここでは彼らの声明のやや異なるバージョンを提示します [^6]。
[^7]: 例えば、オルガ・カザンの「海底ケーブルの盗聴という長年にわたる気味の悪い慣行」、*The Atlantic*、2013年7月16日（[The Atlantic](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)で入手可能）を参照してください。[^7]

# 暗号学の数学的基礎 I
<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

暗号学は数学に依存しています。そして、暗号学について表面的な理解以上のものを構築したい場合、その数学に慣れ親しむ必要があります。

この章では、暗号学を学ぶ際に遭遇する基本的な数学のほとんどを紹介します。トピックには、ランダム変数、モジュロ演算、XOR演算、疑似乱数が含まれます。暗号学の非表面的な理解のためには、これらのセクションの内容をマスターする必要があります。

次の章では、より難易度の高い数論について扱います。

## ランダム変数
<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

ランダム変数は通常、太字でない大文字で表されます。したがって、例えば、ランダム変数X、ランダム変数Y、またはランダム変数Zについて話すかもしれません。これは、これからも私が使用する表記法です。

**ランダム変数**は、それぞれが一定の正の確率を持つ2つ以上の可能な値を取ることができます。可能な値は、**結果セット**にリストされます。

ランダム変数を**サンプリング**するたびに、定義された確率に従ってその結果セットから特定の値を引き出します。

簡単な例について考えてみましょう。変数Xが次のように定義されているとします：

* Xの結果セットは{1,2}
* Pr [X = 1] = 0.5
* Pr [X = 2] = 0.5

Xがランダム変数であることは容易に理解できます。まず、Xが取り得る2つ以上の可能な値、すなわち1と2があります。次に、Xをサンプリングするたびに、それぞれの可能な値が発生する正の確率があります、すなわち0.5です。

ランダム変数に必要なのは、サンプリング時にそれぞれの可能性が正の確率で発生する2つ以上の可能性を持つ結果セットです。原則として、ランダム変数は、任意の文脈から抽象的に定義することができます。この場合、「サンプリング」とは、ランダム変数の値を決定するために何らかの自然実験を実行することと考えるかもしれません。

上記の変数Xは抽象的に定義されました。したがって、上記の変数Xのサンプリングを、公平なコインを投げて、「2」を表、「1」を裏と割り当てることと考えるかもしれません。Xの各サンプルについて、コインを再び投げます。

または、公平なサイコロを振り、「2」の場合は「1」を、「1」、「3」、または「4」が出た場合は「2」を割り当てることと考えることもできます。Xをサンプリングするたびに、サイコロを再び振ります。

実際には、上記のXの可能な値の確率を定義することができる任意の自然実験を、描画に関して想像することができます。
しかし、しばしば、確率変数は抽象的に導入されるだけではありません。代わりに、可能な結果の値のセットは、単なる数値としてではなく、明確な実世界の意味を持っています。さらに、これらの結果の値は、特定のタイプの実験（値を持つ任意の自然実験としてではなく）に対して定義されることがあります。
ここで、抽象的に定義されていない変数Xの例を考えてみましょう。Xは、2つのチームのどちらがサッカーゲームを開始するかを決定するために次のように定義されています：

* Xの結果セットは{赤がキックオフ、青がキックオフ}
* 特定のコインCを投げる：裏 = 「赤がキックオフ」；表 = 「青がキックオフ」
* Pr [X = 赤がキックオフ] = 0.5
* Pr [X = 青がキックオフ] = 0.5

この場合、Xの結果セットは、サッカーゲームでどちらのチームが開始するかという具体的な意味を持って提供されます。さらに、可能な結果とそれらの関連する確率は、特定のコインCを投げるという具体的な実験によって決定されます。

暗号論の議論では、確率変数は通常、実世界の意味を持つ結果セットに対して導入されます。それは、暗号化される可能性のあるすべてのメッセージのセット、つまりメッセージ空間、または暗号化を使用する当事者が選択できるすべての鍵のセット、つまり鍵空間であるかもしれません。

しかし、暗号論における確率変数の議論では、通常、特定の自然実験に対してではなく、正しい確率分布をもたらす可能性のある任意の実験に対して定義されます。

確率変数は、離散または連続の確率分布を持つことができます。**離散確率分布**を持つ確率変数、つまり離散確率変数は、有限数の可能な結果を持ちます。これまでに与えられた両方の例での確率変数Xは離散でした。

**連続確率変数**は代わりに一つ以上の区間で値を取ることができます。例えば、ある確率変数がサンプリングされると、0から1の間の任意の実数値を取り、この区間内の各実数が等しく可能性があると言うかもしれません。この区間内には無限に可能な値があります。

暗号論の議論では、離散確率変数を理解するだけで十分です。したがって、ここから先の確率変数の議論は、特に別のことが明記されていない限り、離散確率変数を指すと理解されるべきです。

### 確率変数のグラフ化

確率変数の可能な値と関連する確率は、グラフを通じて簡単に視覚化することができます。例えば、前のセクションからの確率変数Xで、結果セットが{1,2}であり、Pr [X = 1] = 0.5およびPr [X = 2] = 0.5の場合を考えてみましょう。このような確率変数は通常、*図1*のような棒グラフの形で表示されます。

*図1: 確率変数X*

![図1: 確率変数X。](assets/Figure2-1.webp)

*図1*の広い棒は、確率変数Xが実際に連続であることを示唆するものではありません。代わりに、棒はより視覚的に魅力的であるために広く作られています（ただ真っ直ぐ上に線を引くだけでは直感的な視覚化が提供されません）。

### 一様変数

「確率変数」という表現では、「確率的」を意味する「ランダム」は、変数の2つ以上の可能な結果が特定の確率で発生することを単に意味します。これらの結果が*必ずしも*等しく可能性があるわけではありません（ただし、「ランダム」という用語は他の文脈ではその意味を持つことが確かにあります）。
**一様変数**は、ランダム変数の特別なケースです。それは、等しい確率で2つ以上の値を取ることができます。*図1*に示されるランダム変数Xは、両方の可能な結果が確率0.5で発生するため、明らかに一様変数です。しかし、一様変数の例ではない多くのランダム変数があります。
例えば、ランダム変数Yを考えてみましょう。それは結果セット{1,2,3,8,10}を持ち、次の確率分布を持っています：Pr [Y = 1] = 0.25; Pr [Y = 2] = 0.35; Pr [Y = 3] = 0.1; Pr [Y = 8] = 0.25; Pr [Y = 10] = 0.05。

確かに2つの可能な結果が等しい確率で発生することはありますが、すなわち1と8ですが、Yはサンプリング時に0.25と異なる確率で特定の値を取ることもできます。したがって、Yは確かにランダム変数ですが、一様変数ではありません。

Yのグラフィカルな描写が*図2*に提供されています。

*図2: ランダム変数Y*

![図2: ランダム変数Y。](assets/Figure2-2.webp "図2: ランダム変数Y")

最後の例として、ランダム変数Zを考えてみましょう。それは結果セット{1,3,7,11,12}を持ち、次の確率分布を持っています：Pr (2) = 0.2; Pr (3) = 0.2; Pr (9) = 0.2; Pr (11) = 0.2; Pr (12) = 0.2。図3に示されているように見ることができます。ランダム変数Zは、Yとは対照的に、サンプリング時の可能な値のすべての確率が等しいため、実際には一様変数です。

*図3: ランダム変数Z*

![図3: ランダム変数Z。](assets/Figure2-3.webp "図3: ランダム変数Z")

### 条件付き確率

仮定として、ボブが最後の暦年から均等に日を選ぶつもりであるとします。選ばれた日が夏にある確率は何と結論付けるべきでしょうか？

ボブのプロセスが実際に真に均一であると思う限り、ボブが夏の日を選ぶ確率は1/4であると結論付けるべきです。これは、ランダムに選ばれた日が夏にある**無条件の確率**です。

今度は、均等に暦日を引き出す代わりに、ボブがニュージャージー州のクリスタルレイクで正午の温度が21度セルシウス以上だった日から均等に選ぶと仮定します。この追加情報を考慮して、ボブが夏の日を選ぶ確率について何を結論付けることができますか？

特定の情報（例えば、昨年の暦年の毎日の正午の温度）がなくても、以前とは異なる結論を出すべきです。

クリスタルレイクがニュージャージー州にあることを知っているので、冬に正午の温度が21度セルシウス以上であることを確かに期待しません。代わりに、春や秋の暖かい日、または夏のどこかの日である可能性がはるかに高いです。したがって、選択された日のクリスタルレイクでの正午の温度が21度セルシウス以上であったことを知っていると、ボブが選んだ日が夏である確率ははるかに高くなります。これは、クリスタルレイクでの正午の温度が21度セルシウス以上であったことを条件として、ランダムに選ばれた日が夏である**条件付き確率**です。
前の例とは異なり、2つのイベントの確率が完全に無関係であることもあります。その場合、それらは**独立している**と言います。
例えば、ある公正なコインが表を出したとします。この事実を踏まえて、明日雨が降る確率はどのくらいでしょうか？この場合の条件付き確率は、コインの投げ方が一般的に天気に影響を与えないため、明日雨が降る無条件の確率と同じであるべきです。

条件付き確率の記述には「|」記号を使用します。例えば、イベントBが起こったという条件でのイベントAの確率は、次のように書くことができます：Pr[A|B]。したがって、2つのイベント、AとBが独立している場合、Pr[A|B] = Pr[A] および Pr[B|A] = Pr[B] となります。独立の条件は次のように簡略化できます：Pr[A,B] = Pr[A]*Pr[B]。

確率論における重要な結果の一つに、**ベイズの定理**があります。基本的に、Pr[A|B]は次のように書き換えることができます：

Pr[A|B] = (Pr[B|A] • Pr[A]) / Pr[B]

特定のイベントに対する条件付き確率を使用する代わりに、可能なイベントのセットにわたる2つ以上のランダム変数に関連する条件付き確率を見ることもできます。ランダム変数XとYを仮定します。Xの任意の値をx、Yの任意の値をyと表すことができます。したがって、次の声明が成り立つ場合、2つのランダム変数は独立していると言えます：

すべてのxとyに対して、Pr[X = x,Y = y] = Pr[X = x] • Pr[Y = y]

この声明が何を意味するのかもう少し具体的に説明しましょう。

XとYの結果セットが次のように定義されていると仮定します：**X** = {x<sub>1</sub>,x<sub>2</sub>….,x<sub>i</sub>,….x<sub>n</sub>} および **Y** = {y<sub>1</sub>,y<sub>2</sub>….,y<sub>i</sub>,….y<sub>m</sub>}。（値のセットを太字の大文字で示すのが一般的です。）

今、Yをサンプリングしてy<sub>1</sub>を観測したとします。上記の声明は、Xからx<sub>1</sub>を得る確率が、y<sub>1</sub>を観測していなかった場合と全く同じであることを私たちに教えています。これは、Yの初期サンプリングから引き出すことができた任意のy<sub>i</sub>に対して真です。最後に、これはx<sub>1</sub>だけでなく、任意のx<sub>i</sub>に対しても成り立ちます。Yのサンプリング結果がXのサンプリング結果に影響を与えないのです。これは、Xが最初にサンプリングされた場合にも適用されます。

少し哲学的な点で議論を終えましょう。実際の状況では、何らかのイベントの確率は常に特定の情報セットに対して評価されます。非常に厳密な意味での「無条件の確率」というものはありません。

例えば、2030年までに豚が飛ぶ確率を尋ねたとします。さらなる情報を提供しないにもかかわらず、あなたは世界について多くのことを知っており、それがあなたの判断に影響を与えることを明らかに知っています。あなたは豚が飛ぶのを見たことがありません。ほとんどの人がそれを期待しないことを知っています。彼らが飛ぶために本当に作られていないことも知っています。などなど。
したがって、「無条件の確率」という用語を実世界の文脈で話すとき、それは「それ以上の明確な情報なしに確率」というような意味で理解する以外に意味を持つことはできません。したがって、「条件付き確率」の理解は、常に特定の情報に対して理解されるべきです。
例えば、ニュージーランドのヤギが数年の訓練の後に飛ぶことを学んだという証拠を提供した後で、2030年までに豚が飛ぶ確率を尋ねるかもしれません。この場合、おそらく2030年までに豚が飛ぶ確率の判断を調整するでしょう。したがって、2030年までに豚が飛ぶ確率は、ニュージーランドのヤギに関するこの証拠に基づいています。

## モジュロ演算
<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

**モジュロ演算**の最も基本的な表現は次の形式です：x mod y。

変数xは被除数と呼ばれ、変数yは除数です。正の被除数と正の除数でモジュロ演算を行う場合、単に除算の余りを決定します。

例えば、式25 mod 4を考えてみましょう。数4は数25に合計6回入ります。その除算の余りは1です。したがって、25 mod 4は1に等しいです。同様の方法で、以下の式を評価できます：

* 29 mod 30 = 29（30が29に合計0回入り、余りが29であるため）
* 42 mod 2 = 0（2が42に合計21回入り、余りが0であるため）
* 12 mod 5 = 2（5が12に合計2回入り、余りが2であるため）
* 20 mod 8 = 4（8が20に合計2回入り、余りが4であるため）

被除数または除数が負の場合、プログラミング言語によってモジュロ演算の扱い方が異なる場合があります。

暗号学では、負の被除数のケースに間違いなく遭遇します。これらのケースでは、典型的なアプローチは以下の通りです：

* まず、除数が余りゼロで割り切れる被除数以下の最も近い値pを決定します。
* 被除数がxの場合、モジュロ演算の結果はx – pの値です。

例えば、被除数が-20で除数が3の場合、3が均等に割り切れる-20以下の最も近い値は-21です。この場合のx – pの値は-20 – (-21)です。これは1に等しく、したがって、-20 mod 3は1に等しいです。同様の方法で、以下の式を評価できます：

* -8 mod 5 = 2
* -19 mod 16 = 13
* -14 mod 6 = 4

表記に関しては、通常、次のタイプの式を見るでしょう：x = [y mod z]。括弧のため、この場合モジュロ演算は式の右側にのみ適用されます。例えば、yが25でzが4の場合、xは1と評価されます。
括弧がない場合、モジュロ演算は式の*両側*に作用します。例えば、次の式を考えてみましょう：x = y mod z。もしyが25でzが4だった場合、私たちが知っているのはx mod 4が1に評価されるということだけです。これはxの値が{….– 7, – 3, 1, 5, 9….}の集合からの任意の値で一致します。

数と式に対するモジュロ演算を扱う数学の分野は**モジュラー算術**と呼ばれます。この分野は、数直線が無限に長くない場合の算術と考えることができます。通常、暗号学内で（正の）整数に対するモジュロ演算に遭遇しますが、任意の実数を使用してモジュロ演算を実行することもできます。

### シフト暗号

モジュロ演算は暗号学内で頻繁に遭遇します。例を挙げると、最も有名な歴史的暗号化スキームの一つであるシフト暗号を考えてみましょう。

まずそれを定義しましょう。英語のアルファベットのすべての文字を、順番に、数の集合{0,1,2…,25}と等価とする辞書*D*を想定します。メッセージ空間**M**を仮定します。**シフト暗号**は、次のように定義される暗号化スキームです：

- キー空間**K**から、一様にキーkを選択します。ここで、**K** = {0,1,2,…,25}<sup>[1](#footnote1)</sup>
- メッセージm є **M**を次のように暗号化します：
    - mを個々の文字m<sub>0</sub>, m<sub>1</sub>,….m<sub>i</sub>….,m<sub>l</sub>に分割します
    - *D*に従って各m<sub>i</sub>を数に変換します
    - 各m<sub>i</sub>について、c<sub>i</sub> = [(m<sub>i</sub> + k) mod 26]
    - *D*に従って各c<sub>i</sub>を文字に変換します
    - それからc<sub>0</sub>, c<sub>1</sub>,….,c<sub>l</sub>を結合して暗号文cを生成します
- 暗号文cを次のように復号します：
    - *D*に従って各c<sub>i</sub>を数に変換します
    - 各c<sub>i</sub>について、m<sub>i</sub> = [(c<sub>i</sub> – k) mod 26]
    - *D*に従って各m<sub>i</sub>を文字に変換します
    - それからm<sub>0</sub>, m<sub>1</sub>,….,m<sub>l</sub>を結合して元のメッセージmを生成します

シフト暗号におけるモジュロ演算子は、すべての暗号文の文字が定義されるように文字がラップアラウンドすることを保証します。例を挙げると、「DOG」という単語にシフト暗号を適用した場合を考えてみましょう。

キーの値を17に一様に選択したと仮定します。「O」は15に等しいです。モジュロ演算がなければ、この平文数にキーを加えると、暗号文数は32になります。しかし、英語のアルファベットには26文字しかないため、その暗号文数を暗号文の文字に変換することはできません。モジュロ演算により、暗号文数は実際には6（32 mod 26の結果）であり、これは暗号文の文字「G」に等しいです。

キーの値が17である「DOG」という単語の完全な暗号化は次のとおりです：
* メッセージ = DOG = D,O,G = 3,15,6* c<sub>0</sub> = [(3 + 17) Mod 26] = [(20) Mod 26] = 20 = U
* c<sub>1</sub> = [(15 + 17) Mod 26] = [(32) Mod 26] = 6 = G
* c<sub>2</sub> = [(6 + 17) Mod 26] = [(23) Mod 26] = 23 = X
* c = UGX

誰もが直感的にシフト暗号の仕組みを理解し、おそらく自分自身で使用することができます。しかし、暗号学の知識を進めるためには、より複雑なスキームになるにつれて、形式化に慣れ始めることが重要です。そのため、シフト暗号の手順が形式化されました。

## XOR演算
<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

すべてのコンピューターデータは、ビットレベルで処理、保存、およびネットワークを介して送信されます。コンピューターデータに適用される暗号化スキームも、ビットレベルで操作されます。

例えば、あなたが電子メールアプリケーションに電子メールを入力したとします。適用される暗号化は、直接あなたの電子メールのASCII文字には行われません。代わりに、電子メールの文字やその他の記号のビット表現に適用されます。

現代の暗号学で理解するための重要な数学的操作の一つは、モジュロ演算の他に、**XOR演算**、または「排他的論理和」演算です。この演算は、2つのビットを入力として受け取り、別のビットを出力として生成します。XOR演算は単に「XOR」と表記されます。2つのビットが同じ場合は0を、異なる場合は1を生成します。以下に4つの可能性を示します。

* 0 XOR 0 = 0
* 0 XOR 1 = 1
* 1 XOR 0 = 1
* 1 XOR 1 = 0

2つのメッセージが単一ビットよりも長い場合、それら2つのメッセージのビットを並べて、各ビットペアに対してXOR演算を実行することで、XOR演算を行うことができます。

例を挙げると、メッセージm<sub>1</sub>（01111001）とメッセージm<sub>2</sub>（01011001）があるとします。これら2つのメッセージのXOR演算は以下の通りです。

* m<sub>1</sub> XOR m<sub>2</sub> = 01111001 XOR 01011001 = 00100000

このプロセスは直接的です。最初にm<sub>1</sub>とm<sub>2</sub>の最も左のビットをXORします。この場合、それは0 XOR 0 = 0です。次に、左から2番目のビットペアをXORします。この場合、それは1 XOR 1 = 0です。このプロセスを続け、最も右のビットに対してXOR演算を実行するまで続けます。
XOR演算が交換可能であることは容易に理解できます。つまり、m<sub>1</sub> XOR m<sub>2</sub> = m<sub>2</sub> XOR m<sub>1</sub>です。さらに、XOR演算は結合的でもあります。すなわち、(m<sub>1</sub> XOR m<sub>2</sub>) XOR m<sub>3</sub> = m<sub>1</sub> XOR (m<sub>2</sub> XOR m<sub>3</sub>)です。
異なる長さの2つの文字列に対するXOR演算は、文脈によって異なる解釈を持つことがあります。ここでは、異なる長さの文字列に対するXOR演算については取り扱いません。

XOR演算は、ビットの加算に対して除数が2の場合のモジュロ演算を行う特別なケースに相当します。以下の結果で等価性を確認できます：

* (0 + 0) mod 2 = 0 XOR 0 = 0
* (1 + 0) mod 2 = 1 XOR 0 = 1
* (0 + 1) mod 2 = 0 XOR 1 = 1
* (1 + 1) mod 2 = 1 XOR 1 = 0

## 擬似乱数
<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

ランダム変数と一様変数についての議論では、「ランダム」と「一様」の間に特定の区別を行いました。この区別は、ランダム変数を記述する際に実際には通常維持されます。しかし、現在の文脈では、この区別を取り除き、「ランダム」と「一様」を同義語として使用します。このセクションの最後にその理由を説明します。

まず、長さnの二進文字列が、それぞれの二進文字列に等しい選択確率を与える一様変数Sのサンプリング結果であった場合、その文字列を**ランダム**（または**一様**）と呼ぶことができます。

例えば、長さ8のすべての二進文字列のセット：{0000 0000,0000 0001,….,1111 1111}を考えてみましょう。（8ビット文字列は通常、2つのクァルテットに書かれ、それぞれを**ニブル**と呼びます。）この文字列のセットを**S<sub>8</sub>**と呼びましょう。

上記の定義に従って、**S<sub>8</sub>**内の各文字列に等しい選択確率を与える一様変数Sのサンプリング結果であった場合、特定の長さ8の二進文字列をランダム（または一様）と呼ぶことができます。セット**S<sub>8</sub>**が2<sup>8</sup>要素を含むことを考えると、サンプリング時の選択確率はセット内の各文字列に対して1/2<sup>8</sup>でなければなりません。

二進文字列のランダム性の重要な側面は、それが選択されたプロセスに関して定義されることです。したがって、特定の二進文字列の形式自体は、選択のランダム性について何も明らかにしません。

例えば、多くの人々は直感的に、1111 1111のような文字列がランダムに選択された可能性がないと考えがちです。しかし、これは明らかに誤りです。
長さ8のすべてのバイナリ文字列にわたって一様変数Sを定義すると、セット**S<sub>8</sub>**から1111 1111を選択する確率は、0111 01001のような文字列を選択する確率と同じです。したがって、文字列自体を分析するだけでは、文字列のランダム性について何も言えません。
また、バイナリ文字列を特に意味することなく、ランダムな文字列についても話すことができます。たとえば、ランダムな16進文字列AF 02 82について話すことができます。この場合、文字列は長さ6のすべての16進文字列のセットからランダムに選択されたものです。これは、各16進数が4ビットを表すため、長さ24のバイナリ文字列をランダムに選択することと同等です。

通常、「ランダムな文字列」という表現は、特に限定することなく、同じ長さのすべての文字列のセットからランダムに選択された文字列を指します。これが上で説明した方法です。長さnの文字列は、もちろん、異なるセットからランダムに選択されることもあります。たとえば、長さnのすべての文字列のサブセットのみを構成するものや、異なる長さの文字列を含むセットなどです。しかし、これらの場合には、「ランダムな文字列」とは言わず、「あるセット**S**からランダムに選択された文字列」と言います。

暗号学内の重要な概念は、擬似ランダム性です。長さnの**擬似ランダム文字列**は、**S<sub>n</sub>**内の各文字列に同じ選択確率を与える一様変数Sのサンプリング結果であるかのように*見えます*。実際には、しかし、文字列は**S<sub>n</sub>**のサブセット上にのみ確率分布を定義する一様変数S'のサンプリング結果です—必ずしもすべての可能な結果に対して等しい確率を持つわけではありません。ここでの重要な点は、多くのサンプルを取っても、SとS'からのサンプルを実際に区別することができないということです。

たとえば、ランダム変数Sを想定します。その結果セットは**S<sub>256</sub>**で、これは長さ256のすべてのバイナリ文字列のセットです。このセットには2<sup>256</sup>の要素があります。サンプリング時に、各要素は1/2<sup>256</sup>の等しい選択確率を持ちます。

さらに、ランダム変数S’を想定します。その結果セットは長さ256のバイナリ文字列の2<sup>128</sup>のみを含みます。これらの文字列にはある確率分布がありますが、この分布は必ずしも一様ではありません。

今、私がSとS'からそれぞれ1000のサンプルを取り、2つの結果セットをあなたに渡したとします。どのセットの結果がどのランダム変数に関連しているかをあなたに伝えます。次に、2つのランダム変数のいずれかからサンプルを取ります。しかし、この時はどのランダム変数からサンプルを取ったかをあなたには伝えません。S'が擬似ランダムであれば、私がどのランダム変数からサンプルを取ったかについて正しい推測をするあなたの確率は、実質的に1/2より良くないというのが考え方です。

通常、長さnの擬似ランダム文字列は、サイズがn – xの文字列をランダムに選択し、それを拡張アルゴリズムの入力として使用することによって生成されます。ここでxは正の整数です。このサイズn – xのランダム文字列は、**シード**として知られています。
擬似乱数文字列は、暗号技術を実用的にするための重要な概念です。例えば、ストリーム暗号を考えてみましょう。ストリーム暗号では、ランダムに選択された鍵が拡張アルゴリズムに入力され、はるかに大きな擬似乱数文字列を生成します。この擬似乱数文字列は、平文とXOR演算を行うことで暗号文を生成します。
このタイプの擬似乱数文字列をストリーム暗号で生成できない場合、そのセキュリティのためにはメッセージと同じ長さの鍵が必要になります。これはほとんどの場合、非常に実用的なオプションではありません。

このセクションで議論される擬似乱数性の概念は、より正式に定義することができます。また、他の文脈にも拡張されます。しかし、ここではその議論に深入りする必要はありません。暗号技術の多くについて直感的に理解するために本当に必要なのは、ランダムな文字列と擬似乱数文字列の違いです。<sup>[2](#footnote2)</sup>

「ランダム」と「一様」の区別を議論から省略する理由も、今は明らかになるはずです。実際には、誰もが擬似乱数を、一様変数Sのサンプリング結果であるかのように見える文字列を指すために使用します。厳密に言えば、このような文字列を「擬似一様」と呼ぶべきですが、以前の言葉を採用します。しかし、「擬似一様」という用語はとても不格好で誰も使っていないため、ここでは明確さのために導入しません。代わりに、現在の文脈では「ランダム」と「一様」の区別を省略します。

## メモ
<chapterId>7cccd92c-15bc-5394-9024-af126988ecd7</chapterId>

[^1]: この声明を前のセクションからの用語を使用して正確に定義することができます。一様変数Kが可能な結果のセットとして**K**を持つとします。したがって、Pr [K = 0] = 1/26、Pr [K = 1] = 1/26、と続きます。一様変数Kを一度サンプルすると、特定の鍵が得られます[^1]。

[^2]: これらの問題についてより正式な説明に興味がある場合は、KatzとLindellの*Introduction to Modern Cryptography*、特に第3章を参照してください[^2]。

# 暗号学の数学的基礎 II
<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

この章では、暗号学の数学的基礎に関するより高度なトピックである数論について説明します。数論は対称暗号（例えばRijndael Cipher）にとって重要ですが、公開鍵暗号の設定では特に重要です。

数論の詳細が煩雑に感じる場合は、最初は高いレベルでの読みをお勧めします。後でいつでも戻ってくることができます。

## 数論とは何か？
<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>

**数論**は、整数と整数で動作する数学的関数の性質を研究すると特徴づけることができます。

例えば、任意の二つの数aとNが、それらの最大公約数が1である場合に**互いに素**（または**相対素**）であるとします。特定の整数Nについて、Nより小さい整数のうち、Nと互いに素であるものはいくつありますか？この質問に対する一般的な回答を出すことはできますか？これらは数論が答えを求めようとする典型的なタイプの質問です。
現代の数論は抽象代数のツールに依存しています。**抽象代数**の分野は、主に代数的構造として知られる抽象的なオブジェクトが分析の主な対象である数学のサブディシプリンです。**代数的構造**は、一つ以上の演算が結合され、特定の公理を満たす要素の集合です。代数的構造を通じて、数学者はその詳細から抽象化することで、特定の数学的問題についての洞察を得ることができます。
抽象代数の分野は、時には現代代数とも呼ばれます。また、**抽象数学**（または**純粋数学**）という概念に出会うこともあります。この後者の用語は抽象代数を指すものではなく、数学をそのもののために、そして潜在的な応用に目を向けるだけでなく、研究することを意味します。

抽象代数からの集合は、正三角形に対する形状を保持する変換から壁紙のパターンまで、多くの種類のオブジェクトを扱うことができます。数論においては、整数を含む要素の集合や整数で動作する関数のみを考慮します。

## グループ
<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

数学における基本的な概念は、要素の集合です。集合は通常、要素がコンマで区切られた中括弧で示されます。

例えば、すべての整数の集合は{…,-2,-1,0,1,2,…}です。ここでの省略記号は、特定のパターンが特定の方向に続くことを意味します。したがって、すべての整数の集合には、3,4,5,6など、また-3,-4,-5,-6なども含まれます。このすべての整数の集合は通常、ℤで示されます。

別の集合の例は、ℤ mod 11、またはすべての整数の11による剰余の集合です。全体の集合ℤとは対照的に、この集合には有限数の要素、すなわち{0,1,…,9,10}のみが含まれます。

一般的な誤解は、集合ℤ mod 11が実際には{-10,-9,….,0,….,9,10}であると考えることです。しかし、以前に定義したように剰余演算を考えると、この考えは正しくありません。11による剰余で減少した任意の負の整数は{0,1,….,9,10}にラップされます。例えば、式-2 mod 11は9に、式-27 mod 11は5にラップされます。

数学における別の基本的な概念は、二項演算です。これは、二つの要素を取って第三の要素を生成する任意の演算です。例えば、基本的な算数や代数から、四つの基本的な二項演算：加算、減算、乗算、除算に慣れ親しんでいるでしょう。

これら二つの基本的な数学的概念、集合と二項演算は、抽象代数における最も基本的な構造であるグループの概念を定義するために使用されます。

具体的には、ある二項演算◌を仮定します。さらに、その演算で装備された要素の集合**S**を仮定します。ここでの「装備された」とは、集合**S**内の任意の二つの要素の間で演算◌が実行できることを意味します。

組み合わせ〈**S**, ◌〉は、それが四つの特定の条件、グループの公理を満たす場合に、**グループ**です。

1. **S**の要素である任意のaとbに対して、a ◌ bもまた**S**の要素である。これは**閉包条件**として知られています。
**S**の任意の要素a、b、cについて、(a ◌ b) ◌ c = a ◌ (b ◌ c)が成り立つ。これは**結合律**として知られています。**S**には、**S**の任意の要素aに対して次の方程式が成り立つような、一意の要素eが存在します：e ◌ a = a ◌ e = a。eという要素がただ一つしかないため、これを**単位元**と呼びます。この条件は**単位律**として知られています。
**S**の各要素aに対して、次の方程式が成り立つような**S**の要素bが存在します：a ◌ b = b ◌ a = e、ここでeは単位元です。ここでの要素bは**逆元**として知られ、一般にa<sup>-1</sup>と表記されます。この条件は**逆元律**または**可逆性条件**として知られています。

群についてもう少し探求しましょう。全ての整数の集合をℤと表します。この集合は標準的な加算と組み合わせたもの、つまり〈ℤ, +〉は、上記の四つの公理を満たすため、群の定義に明らかに適合します。

1. ℤの任意の要素xとyについて、x + yもℤの要素です。したがって、〈ℤ, +〉は閉包条件を満たします。
2. ℤの任意の要素x、y、zについて、(x + y) + z = x + (y + z)です。したがって、〈ℤ, +〉は結合律を満たします。
3. 〈ℤ, +〉には単位元が存在し、それは0です。ℤの任意のxに対して、0 + x = x + 0 = xが成り立ちます。したがって、〈ℤ, +〉は単位律を満たします。
4. 最後に、ℤの各要素xに対して、x + y = y + x = 0となるようなyが存在します。例えば、xが10の場合、yは-10になります（xが0の場合、yも0です）。したがって、〈ℤ, +〉は逆元律を満たします。

重要なことは、整数の集合が加算によって群を構成するということは、乗算によって群を構成するということではないということです。〈ℤ, •〉を四つの群の公理に対してテストすることによって、これを確認することができます（ここで•は標準的な乗算を意味します）。

最初の二つの公理は明らかに成り立ちます。さらに、乗算の下では、要素1が単位元として機能します。任意の整数xに1を乗じると、xが得られます。しかし、〈ℤ, •〉は逆元律を満たしません。つまり、ℤの任意のxに対して、x • y = 1となるような一意の要素yがℤに存在しないのです。

例えば、x = 22と仮定します。集合ℤからxに乗じると単位元1が得られるような値yは何でしょうか？1/22の値が機能しますが、これはℤの集合には含まれていません。実際、1と-1の値を除く任意の整数xに対して、この問題に直面します（この場合、yはそれぞれ1と-1でなければなりません）。
私たちが集合に実数を許可した場合、問題は大部分が解消されます。集合内の任意の要素xに対して、1/xによる乗算は1を生み出します。分数は実数の集合に含まれるため、すべての実数には逆数が見つかります。例外はゼロで、ゼロとの任意の乗算は決して単位元1を生み出しません。したがって、乗算を備えた非ゼロ実数の集合は実際には群です。

いくつかの群は、**交換条件**として知られる第5の一般条件を満たします。この条件は以下の通りです：

* 群Gが集合**S**と二項演算子◌を持つとします。**S**の要素であるaとbがあるとします。**S**内の任意の2つの要素aとbに対してa ◌ b = b ◌ aである場合、Gは交換条件を満たします。

交換条件を満たす任意の群は、**可換群**、または**アーベル群**（Niels Henrik Abelにちなんで）として知られています。加算における実数の集合と加算における整数の集合がアーベル群であることを確認するのは簡単です。乗算における整数の集合はそもそも群ではないので、事実上アーベル群にはなり得ません。対照的に、乗算における非ゼロ実数の集合もまたアーベル群です。

記法に関して二つの重要な慣習に注意すべきです。まず、記号"+"や"x"は、要素が実際には数値でない場合でも、群の演算を象徴するために頻繁に使用されます。これらの場合、これらの記号を標準的な算術加算や乗算として解釈すべきではありません。代わりに、これらはこれらの算術演算と抽象的な類似性のみを持つ演算です。

特に算術加算や乗算を指していない場合は、◌や◊のような記号を群の演算に使用する方が簡単です。これらは文化的に深く根付いた意味合いを持っていません。

二つ目に、"+"や"x"が非算術演算を示すためによく使用されるのと同じ理由で、群の単位元はしばしば"0"や"1"によって象徴されますが、これらの群の要素が数値でない場合でもです。数値を持つ群の単位元を指していない場合は、単位元を示すために"e"のようなより中立的な記号を使用する方が簡単です。

数学において、特定の二項演算を備えた多くの異なる非常に重要な値の集合は群です。しかし、暗号学的アプリケーションは、整数によって記述される要素、つまり数論の領域内の整数の集合または少なくとも整数で記述される要素の集合のみを使用します。したがって、整数以外の実数を含む集合は暗号学的アプリケーションで使用されません。

整数ではないが「整数によって記述される」要素の例を挙げて終わりにしましょう。良い例は楕円曲線の点です。楕円曲線上の任意の点は明らかに整数ではありませんが、実際には2つの整数によって記述されます。

例えば、楕円曲線はビットコインにとって不可欠です。標準的なビットコインの秘密鍵と公開鍵のペアは、次の楕円曲線によって定義される点の集合から選択されます：x<sup>3</sup> + 7 = y<sup>2</sup> mod 2<sup>256</sup> – 232 – 29 – 28 – 27 – 26 - 24 - 1（2<sup>256</sup>未満の最大の素数）。x座標は秘密鍵であり、y座標は公開鍵です。
ビットコインでの取引は、通常、何らかの方法で一つ以上の公開鍵に出力をロックすることを含みます。これらの取引からの価値は、対応する秘密鍵でデジタル署名を行うことで、解除することができます。

## 循環群
<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

私たちが引き出せる主な区別は、**有限**群と**無限**群の間です。前者は有限数の要素を持ち、後者は無限数の要素を持ちます。任意の有限群の要素数は、**群の位数**として知られています。群を使用する実用的な暗号学はすべて、有限（数論的）群に依存しています。

公開鍵暗号学内では、特定のクラスの有限アーベル群である循環群が特に重要です。循環群を理解するためには、まず群要素のべき乗の概念を理解する必要があります。

群Gが群演算◌を持ち、aがGの要素であるとします。その場合、a<sup>n</sup>は、要素aが自身と合計n - 1回組み合わされると解釈されるべきです。例えば、a<sup>2</sup>はa ◌ a、a<sup>3</sup>はa ◌ a ◌ aを意味し、以降同様です。（ここでのべき乗は、必ずしも標準的な算術の意味でのべき乗ではありません。）

例を挙げましょう。G = 〈ℤ mod 7,+〉で、aの値が4であるとします。この場合、a<sup>2</sup> = [4 + 4 mod 7] = [8 mod 7] = 1 mod 7です。また、a<sup>4</sup>は[4 + 4 + 4 + 4 mod 7] = [16 mod 7] = 2 mod 7を表します。

いくつかのアーベル群は、継続的なべき乗を通じて他のすべての群要素を生成できる一つまたは複数の要素を持っています。これらの要素は**生成元**または**原始元**と呼ばれます。

そのような群の重要なクラスは、〈ℤ* mod N, •〉で、ここでNは素数です。記号ℤ*は、群がN未満のすべての非ゼロの正の整数を含むことを意味します。したがって、このような群は常にN - 1の要素を持ちます。

例えば、G = 〈ℤ* mod 11, •〉を考えてみましょう。この群は次の要素を持っています：{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}。この群の位数は10です（実際には11 - 1に等しい）。

この群から要素2をべき乗することを探求しましょう。2<sup>12</sup>までの計算が以下に示されています。方程式の左側の指数は群要素のべき乗を指します。私たちの特定の例では、これは実際に方程式の右側での算術的なべき乗を含んでいます（しかし、例えば加算を含んでいた可能性もあります）。明確にするために、右側に繰り返し操作を書き出しましたが、指数形式ではありません。

* 2<sup>1</sup> = 2 mod 11
* 2<sup>2</sup> = 2 · 2 mod 11 = 4 mod 11
* 2<sup>3</sup> = 2 · 2 · 2 mod 11 = 8 mod 11
* 2<sup>4</sup> = 2 · 2 · 2 · 2 mod 11 = 16 mod 11 = 5 mod 11
* 2<sup>5</sup> = 2 · 2 · 2 · 2 · 2 mod 11 = 32 mod 11 = 10 mod 11
* 2<sup>6</sup> = 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 64 mod 11 = 9 mod 11
* 2<sup>7</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 128 mod 11 = 7 mod 11
* 2<sup>8</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 256 mod 11 = 3 mod 11
* 2<sup>9</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 512 mod 11 = 6 mod 11
* 2<sup>10</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 1024 mod 11 = 1 mod 11
* 2<sup>11</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 2048 mod 11 = 2 mod 11
* 2<sup>12</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 4096 mod 11 = 4 mod 11

注意深く見ると、要素2に対して指数演算を行うと、〈ℤ* mod 11, •〉の全ての要素を次の順序で循環することがわかります：2, 4, 8, 5, 10, 9, 7, 3, 6, 1。2<sup>10</sup>の後、要素2の指数演算を続けると、全ての要素を再び同じ順序で循環します。したがって、要素2は〈ℤ* mod 11, •〉における生成元です。

〈ℤ* mod 11, •〉には複数の生成元がありますが、この群の全ての要素が生成元であるわけではありません。例えば、要素3を考えてみましょう。最初の10回の指数演算を行うと、煩雑な計算を示さずに、以下の結果が得られます：

* 3<sup>1</sup> = 3 mod 11
* 3<sup>2</sup> = 9 mod 11
* 3<sup>3</sup> = 5 mod 11
* 3<sup>4</sup> = 4 mod 11
* 3<sup>5</sup> = 1 mod 11
* 3<sup>6</sup> = 3 mod 11
* 3<sup>7</sup> = 9 mod 11
* 3<sup>8</sup> = 5 mod 11
* 3<sup>9</sup> = 4 mod 11
* 3<sup>10</sup> = 1 mod 11

11を法とした時、要素3のべき乗を通して得られる値は、全ての値を通過するのではなく、3, 9, 5, 4, そして1の部分集合にのみ至ります。5回のべき乗後、これらの値は繰り返し始めます。

これにより、**巡回群**を少なくとも1つの生成元を持つ任意の群として定義することができます。つまり、べき乗を通じて他の全ての群要素を生成できる少なくとも1つの群要素が存在します。

上記の例で気付かれたかもしれませんが、2<sup>10</sup>と3<sup>10</sup>は両方とも1 mod 11と等しくなります。実際には、計算を行わないまでも、群〈ℤ* mod 11, •〉内の任意の要素を10でべき乗すると、1 mod 11が得られるのです。これはなぜでしょうか？

これは重要な問題ですが、答えるにはいくつかの作業が必要です。

まず、2つの正の整数aとNを想定します。数論における重要な定理は、aがNに対する乗法的逆数（つまり、a • b = 1 mod Nとなる整数b）を持つのは、aとNの最大公約数が1に等しい場合、つまりaとNが互いに素である場合に限られると述べています。

したがって、Nに対する乗法モジュロを備えた整数の任意の群には、Nと互いに素な小さい整数のみが含まれます。この集合をℤ<sup>c</sup> mod Nと表すことができます。

例えば、Nが10である場合、1,3,7,そして9の整数のみが10と互いに素です。したがって、集合ℤ<sup>c</sup> mod 10には{1,3,7,9}のみが含まれます。1から10までの他の任意の整数を使用して、10を法とする整数の乗法による群を作成することはできません。この特定の群では、逆数のペアは1と9、そして3と7です。

N自体が素数である場合、1からN – 1までの全ての整数はNと互いに素です。したがって、そのような群はN – 1の位数を持ちます。先ほどの表記を使用すると、Nが素数の場合、ℤ<sup>c</sup> mod Nはℤ* mod Nと等しくなります。私たちが先ほどの例で選んだ群、〈ℤ* mod 11, •〉は、このクラスの群の特定のインスタンスです。

次に、関数φ(N)は、ある数Nまでの互いに素な数の数を計算し、**オイラーのファイ関数**として知られています。<sup>[1](#footnote1)</sup> **オイラーの定理**によると、2つの整数aとNが互いに素である場合、以下が成り立ちます：

* a<sup>φ(N)</sup> mod N = 1 mod N
このことは、Nが素数である群 〈ℤ* mod N, •〉 のクラスにとって重要な意味を持ちます。これらの群において、群要素の指数化は算術指数化を表します。つまり、a<sup>φ(N)</sup> mod N は算術操作 a<sup>φ(N)</sup> mod N を表します。これらの乗法群の任意の要素 a が N と互いに素であるため、a<sup>φ(N)</sup> mod N = a<sup>N – 1</sup> mod N = 1 mod N となります。
オイラーの定理は非常に重要な結果です。まず、これは 〈ℤ* mod N, •〉 の全要素が、N – 1 に分割される数値を指数化によってのみ循環できることを意味します。〈ℤ* mod 11, •〉の場合、これは各要素が2、5、または10の要素を通じてのみ循環できることを意味します。指数化によって任意の要素が循環する群の値は、**要素の位数**として知られています。群の位数に等しい位数を持つ要素は生成元です。

さらに、オイラーの定理は、Nが素数である群 〈ℤ* mod N, •〉 において、a<sup>N – 1</sup> mod N の結果を常に知ることができることを意味します。これは、実際の計算がどれほど複雑であっても、そうであることです。

例えば、私たちの群が ℤ* mod 160,481,182（ここで160,481,182は確かに素数です）であるとします。1から160,481,181までの全整数がこの群の要素であること、そしてφ(n) = 160,481,181であることを知っています。計算の全ステップを行うことはできませんが、514<sup>160,481,181</sup>、2,005<sup>160,481,181</sup>、256,212<sup>160,481,181</sup> などの表現がすべて 1 mod 160,481,182 と評価されることを知っています。

## Fields
<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

群は抽象代数における基本的な代数構造ですが、それ以外にも多くの代数構造があります。あなたが習熟する必要がある唯一の他の代数構造は、特に有限体のそれである**フィールド**です。このタイプの代数構造は、Advanced Encryption Standardのような暗号学で頻繁に使用されます。後者は、実際に遭遇する主要な対称暗号化スキームです。

フィールドは、群の概念から派生しています。具体的には、**フィールド**は二つの二項演算子 ◌ と ◊ を備えた要素の集合 **S** であり、以下の条件を満たします：

1. 集合 **S** は ◌ を備えるとアーベル群です。
2. 集合 **S** は ◊ を備えると「非ゼロ」要素のアーベル群です。
3. 集合 **S** が二つの演算子を備えると、分配条件として知られるものを満たします：a、b、およびcが **S** の要素であるとします。すると、集合 **S** が二つの演算子を備えると、a ◌ (b ◊ c) = a ◌ b ◊ a ◌ c となり、分配法則を満たします。
グループと同様に、フィールドの定義は非常に抽象的です。**S**内の要素の型や、◌および◊の操作について何も主張していません。フィールドとは、上記の3つの条件が成立する2つの操作を持つ要素の集合であると単に述べています。（第二のアーベル群の「ゼロ」要素は抽象的に解釈できます。）

では、フィールドの例は何でしょうか？良い例は、標準的な加算（上記の◌の代わりに）と標準的な乗算（上記の◊の代わりに）で定義された、集合 ℤ mod 7、または {0,1,…,7}です。

まず、ℤ mod 7は加算に関してアーベル群である条件を満たし、ゼロでない要素のみを考慮した場合に乗算に関してアーベル群である条件を満たします。次に、2つの演算子との集合の組み合わせは分配条件を満たします。

これらの主張を、特定の値を使用して探求することは、教育的に価値があります。集合 ℤ mod 7からランダムに選択された要素である5、2、および3の実験値を取り、フィールド 〈ℤ mod 7, +, •〉を検証しましょう。特定の条件を探求するために必要に応じてこれら3つの値を順番に使用します。

まず、加算を備えた ℤ mod 7がアーベル群であるかどうかを探ります。

1. 閉包条件：5と2を値として取りましょう。その場合、[5 + 2] mod 7 = 7 mod 7 = 0です。これはℤ mod 7の要素であり、結果は閉包条件と一致しています。
2. 結合条件：5、2、および3を値として取りましょう。その場合、[(5 + 2) + 3] mod 7 = [5 + (2 + 3)] mod 7 = 10 mod 7 = 3です。これは結合条件と一致しています。
3. 単位元条件：5を値として取りましょう。その場合、[5 + 0] mod 7 = [0 + 5] mod 7 = 5です。したがって、0は加算のための単位元であると考えられます。
4. 逆元条件：5の逆元を考えましょう。[5 + d] mod 7 = 0となるようなdの値が必要です。この場合、この条件を満たすℤ mod 7からの唯一の値は2です。
5. 交換条件：5と3を値として取りましょう。その場合、[5 + 3] mod 7 = [3 + 5] mod 7 = 1です。これは交換条件と一致しています。

加算を備えた集合 ℤ mod 7は明らかにアーベル群であるように見えます。次に、乗算を備えた ℤ mod 7がゼロでない要素に対してアーベル群であるかどうかを探りましょう。

1. 閉包条件：5と2を値として取りましょう。その場合、[5 • 2] mod 7 = 10 mod 7 = 3です。これもℤ mod 7の要素であり、結果は閉包条件と一致しています。
2. 結合律の条件：値として5、2、3を取りましょう。その場合、[(5 • 2) • 3] mod 7 = [5 • (2 • 3)] mod 7 = 30 mod 7 = 2です。これは結合律の条件と一致しています。
3. 単位元の条件：値として5を取りましょう。その場合、[5 • 1] mod 7 = [1 • 5] mod 7 = 5です。したがって、1は乗法における単位元であると考えられます。
4. 逆元の条件：5の逆元を考えましょう。[5 • d] mod 7 = 1となるようなdの値が必要です。この条件を満たすℤ mod 7からの唯一の値は3です。これは逆元の条件と一致しています。
5. 交換律の条件：値として5と3を取りましょう。その場合、[5 • 3] mod 7 = [3 • 5] mod 7 = 15 mod 7 = 1です。これは交換律の条件と一致しています。

集合ℤ mod 7は、非ゼロの要素に対する加法または乗法と組み合わせた場合、アーベル群である規則を明らかに満たしているようです。

最終的に、この集合は両方の演算子と組み合わせることで分配律の条件を満たしているようです。値として5、2、3を取りましょう。[5 • (2 + 3)] mod 7 = [5 • 2 + 5 • 3] mod 7 = 25 mod 7 = 4となることがわかります。

これで、ℤ mod 7が加法と乗法で装備された場合、特定の値でテストすると有限体の公理を満たすことが見られました。もちろん、一般的にも示すことができますが、ここでは行いません。

重要な区別は、二つのタイプの体、有限体と無限体の間にあります。

**無限体**は、集合**S**が無限に大きい場合の体を指します。実数の集合ℝが加法と乗法で装備された例は、無限体の一例です。**有限体**、または**ガロア体**とも呼ばれるのは、集合**S**が有限である場合の体です。上記の例である〈ℤ mod 7, +, •〉は有限体です。

暗号学では、主に有限体に関心があります。一般的に、ある集合**S**がp<sup>m</sup>個の要素を持つ場合（ただしpは素数で、mは1以上の正の整数）、その集合**S**の順序が素数（p<sup>m</sup>、ここでm = 1）または素数のべき乗（p<sup>m</sup>、ここでm > 1）であれば、体の条件を満たすような二つの演算子◌と◊を見つけることができます。

ある有限体が素数個の要素を持つ場合、それは**素体**と呼ばれます。有限体の要素の数が素数のべき乗である場合、その体は**拡張体**と呼ばれます。暗号学では、素体と拡張体の両方に関心があります。<sup>[2](#footnote2)</sup>
暗号学における主要な関心分野の一つは、全ての整数の集合がある素数によって剰余され、演算子が標準的な加算と乗算である場所です。この有限体のクラスには、ℤ mod 2、ℤ mod 3、ℤ mod 5、ℤ mod 7、ℤ mod 11、ℤ mod 13などが含まれます。任意の素数体ℤ mod pにおいて、その体の整数の集合は次のようになります：{0,1,….,p – 2, p – 1}。
暗号学では、特にm > 1である2<sup>m</sup>要素を持つ任意の体、特に拡張体にも関心があります。このような有限体は、例えば、Advanced Encryption Standardの基礎を形成するRijndael Cipherで使用されています。素数体は比較的直感的ですが、これらの基数2の拡張体は、抽象代数に不慣れな人にとってはおそらくそうではありません。

始めに、2<sup>m</sup>要素を持つ任意の整数の集合には、その組み合わせを体にするための2つの演算子を割り当てることができるということは確かに真実です（mが正の整数である限り）。しかし、体が存在するというだけで、それが特定のアプリケーションにとって容易に発見されるか、特に実用的であるとは限りません。

特に、暗号学において適用可能な2<sup>m</sup>の拡張体は、整数の集合ではなく、特定の多項式表現の集合に定義されたものです。

例えば、2<sup>3</sup>（つまり、8）要素の集合を持つ拡張体を求めたいとします。そのサイズの体に使用できるさまざまな集合があるかもしれませんが、そのような集合の一つには、各係数a<sub>i</sub>が0または1である形式のa<sub>2</sub>x<sup>2</sup> + a<sub>1</sub>x + a<sub>0</sub>のすべてのユニークな多項式が含まれます。したがって、この集合**S**には以下の要素が含まれます：

1. 0: a<sub>2</sub> = 0、a<sub>1</sub> = 0、およびa<sub>0</sub> = 0の場合。
2. 1: a<sub>2</sub> = 0、a<sub>1</sub> = 0、およびa<sub>0</sub> = 1の場合。
3. x: a<sub>2</sub> = 0、a<sub>1</sub> = 1、およびa<sub>0</sub> = 0の場合。
4. x + 1: a<sub>2</sub> = 0、a<sub>1</sub> = 1、およびa<sub>0</sub> = 1の場合。
5. x<sup>2</sup>: a<sub>2</sub>= 1、a<sub>1</sub> = 0、およびa<sub>0</sub> = 0の場合。
6. x<sup>2</sup> + 1: a<sub>2</sub> = 1、a<sub>1</sub> = 0、およびa<sub>0</sub> = 1の場合。
7. x<sup>2</sup> + x: a<sub>2</sub> = 1、a<sub>1</sub> = 1、そしてa<sub>0</sub> = 0の場合。8. x<sup>2</sup> + x + 1: a<sub>2</sub> = 1、a<sub>1</sub> = 1、そしてa<sub>0</sub> = 1の場合。

したがって、**S**は集合{0,1,x,x + 1, x<sup>2</sup>,x<sup>2</sup> + 1, x<sup>2</sup> + x, x<sup>2</sup> + x + 1}になります。この要素の集合に対して定義できる2つの操作とは、その組み合わせが体を形成することを保証するものは何でしょうか？

集合Sに対する最初の操作(◌)は、標準的な多項式の加算モジュロ2として定義できます。通常どおりに多項式を加算し、その結果の多項式の各係数に対してモジュロ2を適用するだけです。以下に例を示します：

* [(x<sup>2</sup>) + (x<sup>2</sup> + x + 1)] mod 2 = [2x<sup>2</sup> + x + 1] mod 2 = x + 1
* [(x<sup>2</sup> + x) + (x)] mod 2 = [x<sup>2</sup> + 2x] mod 2 = x<sup>2</sup>
* [(x + 1) + (x<sup>2</sup> + x + 1)] mod 2 = [x<sup>2</sup> + 2x + 2] mod 2 = x<sup>2</sup> + 1

体を作成するために必要な集合Sに対する2番目の操作(◌)はもっと複雑です。これは乗算の一種ですが、算数からの標準的な乗算ではありません。代わりに、各要素をベクトルとして見て、それら2つのベクトルの乗算を既約多項式モジュロで理解する必要があります。

まず、既約多項式の概念について考えてみましょう。**既約多項式**とは、因数分解できない多項式のことです（素数が1とその素数自身以外の成分に因数分解できないのと同じです）。私たちの目的では、すべての整数の集合に対して既約である多項式に興味があります。（例えば、整数を使って因数分解できない場合でも、実数や複素数を使えば特定の多項式を因数分解できるかもしれません。）

例えば、多項式x<sup>2</sup> - 3x + 2を考えてみましょう。これは(x – 1)(x – 2)と書き換えることができます。したがって、これは既約ではありません。次に、多項式x<sup>2</sup> + 1を考えてみましょう。整数を使ってこの式をさらに因数分解する方法はありません。したがって、これは整数に対して既約な多項式です。
次に、ベクトル乗算の概念について見ていきましょう。このトピックを深く掘り下げることはありませんが、基本的なルールを理解する必要があります：被除数の次数が除数の次数よりも高い、または等しい限り、任意のベクトルの除算が可能です。被除数の次数が除数の次数よりも低い場合、被除数はもはや除数によって割ることができません。

例えば、式 x<sup>6</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup> を考えてみましょう。これは、被除数の次数が6で、除数の次数が5よりも高いため、さらに簡約されます。次に、式 x<sup>5</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup> を考えてみましょう。これも、被除数の次数が5、除数の次数も5であるため、さらに簡約されます。

しかし、式 x<sup>4</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup> を考えると、被除数の次数が4で、除数の次数が5よりも低いため、これ以上簡約されません。

この情報に基づいて、私たちはセット {0,1,x,x + 1,x<sup>2</sup>,x<sup>2</sup> + 1,x<sup>2</sup> + x,x<sup>2</sup> + x + 1} に対する第二の操作を見つける準備ができました。

私は既に、第二の操作は、ある既約多項式によるベクトル乗算として理解されるべきだと述べました。この既約多項式は、第二の操作が **S** 上のアーベル群を定義し、分配条件と一致することを保証する必要があります。では、その既約多項式は何であるべきでしょうか？

セット内のすべてのベクトルが次数2以下であるため、既約多項式は次数3であるべきです。セット内の2つのベクトルの乗算が次数3以上の多項式を生じる場合、次数3の多項式によるモジュロは常に次数2以下の多項式を生じることを私たちは知っています。これは、次数3以上の任意の多項式が常に次数3の多項式によって割り切れるためです。さらに、除数として機能する多項式は既約でなければなりません。

次数3のいくつかの既約多項式があり、それらのそれぞれが私たちのセットSと2による加算モジュロと組み合わせて異なるフィールドを定義します。これは、暗号学で拡張フィールド2<sup>m</sup>を使用する際に複数のオプションがあることを意味します。

私たちの例では、多項式 x<sup>3</sup> + x + 1 を選択すると仮定しましょう。これは実際には既約であり、整数を使用して因数分解することはできません。さらに、2つの要素の乗算は常に次数2以下の多項式を生じることを保証します。
多項式 x<sup>3</sup> + x + 1 を除数として使用する第二の操作の例を通して、その動作を説明しましょう。集合 **S** の要素 x<sup>2</sup> + 1 と x<sup>2</sup> + x を乗算するとします。次に、式 [(x<sup>2</sup> + 1) • (x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 を計算する必要があります。これは以下のように簡略化できます：
* [(x<sup>2</sup> + 1) • (x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 =
* [x<sup>2</sup> • x<sup>2</sup> + x<sup>2</sup> • x + 1 • x<sup>2</sup> + 1 • x] mod x<sup>3</sup> + x + 1 = 
* [x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x] mod x<sup>3</sup> + x + 1

[x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x] mod x<sup>3</sup> + x + 1 は、被除数の次数（4）が除数（3）よりも高いため、簡約化できることがわかります。

まず、式 x<sup>3</sup> + x + 1 が x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x に x 回合うことがわかります。これは、x<sup>3</sup> + x + 1 に x を乗算することで確認できます。これは x<sup>4</sup> + x<sup>2</sup> + x であり、後者の項は被除数と同じ次数、つまり 4 であるため、これが機能することがわかります。この除算の余りを x によって以下のように計算できます：

* [(x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x) – (x<sup>4</sup> + x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 = 
* [x<sup>3</sup>] mod x<sup>3</sup> + x + 1 =
* x<sup>3</sup>

したがって、x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x を x<sup>3</sup> + x + 1 で x 回除算した後、余りは x<sup>3</sup> になります。これをさらに x<sup>3</sup> + x + 1 で除算できるでしょうか？
直感的には、x<sup>3</sup> + x + 1がより大きく見えるため、x<sup>3</sup>はx<sup>3</sup> + x + 1で割ることができなくなると言いたくなるかもしれません。しかし、以前にベクトルの除算についての議論を思い出してください。被除数の次数が除数の次数以上である限り、式はさらに簡約できます。具体的には、式x<sup>3</sup> + x + 1はx<sup>3</sup>に正確に1回入ります。余りは次のように計算されます：
[(x<sup>3</sup>) – (x<sup>3</sup> + x + 1)] mod x<sup>3</sup> + x + 1 = 
[x + 1] mod x<sup>3</sup> + x + 1 = 
x + 1

なぜ(x<sup>3</sup>) – (x<sup>3</sup> + x + 1)がx + 1と評価され、-x – 1ではないのか疑問に思うかもしれません。私たちのフィールドの最初の操作がモジュロ2で定義されていることを思い出してください。したがって、2つのベクトルの減算は、2つのベクトルの加算とまったく同じ結果をもたらします。

x<sup>2</sup> + 1とx<sup>2</sup> + xの乗算をまとめると：これら2つの項を乗算すると、x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + xの4次多項式が得られ、これをx<sup>3</sup> + x + 1でモジュロ削減する必要があります。4次多項式は、x<sup>3</sup> + x + 1で正確にx + 1回割ることができます。x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + xをx<sup>3</sup> + x + 1で正確にx + 1回割った後の余りはx + 1です。これは実際には私たちのセット{0,1,x,x + 1,x<sup>2</sup>,x<sup>2</sup> + 1,x<sup>2</sup> + x,x<sup>2</sup> + x + 1}の要素です。

なぜ、上記の例のような多項式のセットを基にした2の拡張フィールドが暗号学に役立つのでしょうか？その理由は、そのようなセットの多項式の係数を、特定の長さのバイナリ文字列の要素として、0または1として見ることができるからです。たとえば、上記の例のセット**S**は、長さ3のすべてのバイナリ文字列（000から111まで）を含むセットSとして代わりに見ることができます。それから、**S**上の操作は、これらのバイナリ文字列上で操作を実行し、同じ長さのバイナリ文字列を生成するためにも使用できます。

## 抽象代数の実践
<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>
形式的な言語や議論の抽象性にもかかわらず、群の概念は理解しにくいものではないはずです。それは単に、ある二項演算とその演算が適用される要素の集合であり、その二項演算の実行が四つの一般的な条件を満たすものです。アーベル群は、交換可能性として知られる追加の条件を持つだけです。さらに、巡回群は、生成元を持つ特別な種類のアーベル群です。体は、基本的な群の概念から派生したより複雑な構造に過ぎません。

しかし、実用的な観点から見ると、この時点で疑問に思うかもしれません：誰が気にするのでしょうか？演算子を持つ要素の集合が群、またはアーベル群や巡回群であることを知っていることが、現実世界で何か関連があるのでしょうか？何かが体であることを知っていることは？

あまり詳しくは述べませんが、答えは「はい」です。群は19世紀にフランスの数学者エヴァリスト・ガロアによって初めて作られました。彼はそれらを使用して、五次以上の多項式方程式を解くことについての結論を導き出しました。

それ以来、群の概念は数学やその他の分野の多くの問題を解明するのに役立ってきました。例えば、物理学者マレー・ゲルマンは、実験で実際に観測される前に粒子の存在を予測することができました。別の例として、化学者は群論を使用して分子の形を分類します。数学者は、壁紙という具体的なものについて結論を導くために群の概念を使用したことさえあります！

本質的に、ある演算子を持つ要素の集合が群であることを示すことは、あなたが説明しているものが特定の対称性を持っていることを意味します。一般的な意味での対称性ではなく、より抽象的な形での対称性です。そしてこれは、特定のシステムや問題に対する重要な洞察を提供することができます。抽象代数からのより複雑な概念は、私たちに追加情報を与えてくれます。

最も重要なことは、数論的群や体の重要性を、特に公開鍵暗号法の応用を通じて実践的に見ることができるということです。例えば、フィールドに関する私たちの議論で、拡張フィールドがRijndael Cipherでどのように使用されているかをすでに見てきました。その例は*第5章*で詳しく説明します。

## さらなる探求
<chapterId>ab51038d-82bd-5c5d-a759-276cfbf7fbce</chapterId>

抽象代数に関するさらなる議論については、Socraticaによる抽象代数に関する優れたビデオシリーズをお勧めします。「抽象代数とは何か？」「群の定義（拡張）」「環の定義（拡張）」「体の定義（拡張）」というビデオを特にお勧めします。これら4つのビデオは、上述の議論の多くについて追加の洞察を提供します。（環については議論しませんでしたが、体は特別なタイプの環です。）

現代数論に関するさらなる議論については、暗号学に関する多くの高度な議論を参照することができます。Jonathan KatzとYehuda Lindellの「Introduction to Modern Cryptography」やChristof PaarとJan Pelzlの「Understanding Cryptography」をさらなる議論のための提案として挙げます。

### 注釈
[^1]: この関数は次のように機能します。任意の整数Nは素数の積に因数分解することができます。特定のNが次のように因数分解されると仮定します：p<sub>1</sub><sup>e1</sup> • p<sub>2</sub><sup>e2</sup> …. • p<sub>m</sub><sup>em</sup> ここで、すべてのpは素数であり、すべてのeは1以上の整数です。すると、φ(N) = Sum<sub>i=1…m</sub>[p<sub>i</sub><sup>ei</sup> – p<sub>i</sub><sup>ei - 1</sup>] [^1]。
[^2]: 拡張体は非常に直感に反します。整数の要素を持つ代わりに、多項式の集合を持ちます。さらに、ある既約多項式によるモジュロで演算が行われます [^2]。

[^3]: [YouTubeビデオを見る](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be) [^3]。

[^4]: Socratica, [抽象代数](https://www.socratica.com/subject/abstract-algebra) [^4]。

[^5]: Katz and Lindell, *現代暗号学への入門*, 第2版, 2015年 (CRC Press: Boca Raton, FL)。Paar and Pelzl, *暗号理解*, 2010年 (Springer-Verlag: Berlin) [^5]。


# 対称暗号
<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

暗号学の2つの主要な分野の一つが対称暗号です。これには暗号化スキームだけでなく、認証や完全性に関するスキームも含まれます。1970年代まで、暗号学は対称暗号化スキームで構成されていたでしょう。

主な議論は、対称暗号化スキームを見て、ストリーム暗号とブロック暗号という重要な区別を行うことから始まります。次に、メッセージの完全性と真正性を保証するスキームであるメッセージ認証コードについて説明します。最後に、対称暗号化スキームとメッセージ認証コードを組み合わせて、安全な通信を保証する方法を探ります。

この章では、実際の対称暗号スキームについて概説しています。次の章では、実際のストリーム暗号とブロック暗号、具体的にはRC4とAESを用いた暗号化について詳細な解説を提供します。

対称暗号についての議論を始める前に、この章および後続の章でのアリスとボブのイラストについて簡単にコメントしたいと思います。


## アリスとボブ
<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

暗号学の原理を説明する際、人々はしばしばアリスとボブを含む例を頼りにします。私もそうします。

暗号学に新しい方は、アリスとボブの例が暗号学の原理や構造を簡略化した環境で説明するためのものであることを理解することが重要です。しかし、これらの原理や構造は、実生活のはるかに広範な文脈に適用可能です。

暗号学におけるアリスとボブを含む例について心に留めておくべき5つの重要な点は以下の通りです：

1. 企業や政府機関など、他のタイプのアクターを含む例に簡単に翻訳することができます。
2. 3人以上のアクターを含むように簡単に拡張することができます。
3. 例では、BobとAliceは通常、各メッセージの作成とそのメッセージに対する暗号化スキームの適用に積極的に参加しています。しかし、実際には、電子通信は大部分が自動化されています。例えば、トランスポート層セキュリティを使用してウェブサイトを訪問する場合、暗号化は通常、あなたのコンピュータとウェブサーバーによって全て処理されます。4. 電子通信の文脈では、通信チャネルを介して送信される「メッセージ」は通常、TCP/IPパケットです。これらは、電子メール、Facebookメッセージ、電話会話、ファイル転送、ウェブサイト、ソフトウェアのアップロードなどに属することがあります。これらは伝統的な意味でのメッセージではありません。それでも、暗号学者はしばしば、例えばメッセージが電子メールであると簡単に述べることで、この現実を単純化します。
5. 例は通常、電子通信に焦点を当てていますが、手紙などの伝統的な通信形態にも拡張することができます。

## 対称暗号化スキーム
<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

**対称暗号化スキーム**を、3つのアルゴリズムを持つ任意の暗号化スキームとして緩く定義することができます：

1. **鍵生成アルゴリズム**は、秘密鍵を生成します。
2. **暗号化アルゴリズム**は、秘密鍵と平文を入力として受け取り、暗号文を出力します。
3. **復号アルゴリズム**は、秘密鍵と暗号文を入力として受け取り、元の平文を出力します。

通常、暗号化スキーム（対称であれ非対称であれ）は、正確な仕様ではなく、コアアルゴリズムに基づいた暗号化のテンプレートを提供します。

例えば、対称暗号化スキームであるSalsa20を考えてみましょう。これは128ビットおよび256ビットの鍵長の両方で使用できます。鍵長に関する選択は、アルゴリズムの細部（具体的にはアルゴリズムのラウンド数）に影響を与えます。

しかし、128ビットの鍵を使用してSalsa20を使用することが、256ビットの鍵を使用する場合と異なる暗号化スキームであるとは言わないでしょう。コアアルゴリズムは同じままです。コアアルゴリズムが変更された場合にのみ、本当に2つの異なる暗号化スキームについて話すでしょう。

対称暗号化スキームは、通常、2種類のケースで有用です：(1) 2人以上のエージェントが距離を置いて通信し、その通信の内容を秘密に保ちたい場合、および(2) 1人のエージェントがメッセージの内容を時間を超えて秘密に保ちたい場合。

*図1* 以下に、状況(1)の描写があります。Bobは距離を置いてAliceにメッセージMを送りたいが、他の人にそのメッセージを読まれたくありません。

Bobは最初に、秘密鍵KでメッセージMを暗号化します。その後、暗号文CをAliceに送信します。Aliceが暗号文を受け取ると、鍵Kを使用してそれを復号し、平文を読むことができます。良い暗号化スキームでは、暗号文Cを傍受した攻撃者がメッセージMについて実質的に重要なことを何も学ぶことができないはずです。

*図2* 以下に、状況(2)の描写があります。Bobは、特定の情報を他人が閲覧するのを防ぎたいと考えています。典型的な状況は、Bobが従業員であり、外部の人や同僚に読まれるべきではない機密データをコンピュータに保存している場合です。
Bobは、時刻T<sub>0</sub>にメッセージMを鍵Kで暗号化して暗号文Cを生成します。時刻T<sub>1</sub>で、彼は再びメッセージが必要になり、鍵Kで暗号文Cを復号します。その間に暗号文Cに遭遇したかもしれない任意の攻撃者も、それからMについて何か重要なことを推測することはできなかったはずです。
*図1: 空間を越えた秘密*

![図1: 空間を越えた秘密](assets/Figure4-1.webp "図1: 空間を越えた秘密")

*図2: 時間を越えた秘密*

![図2: 時間を越えた秘密](assets/Figure4-2.webp "図2: 時間を越えた秘密")


## 例: シフト暗号
<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

第2章では、非常に単純な対称暗号化スキームの例としてシフト暗号に遭遇しました。ここで再び見てみましょう。

英語のアルファベットのすべての文字を、順番に数値のセット{0,1,2…,25}と等価とする辞書*D*を想定します。可能なメッセージのセット**M**を仮定します。シフト暗号は、次のように定義される暗号化スキームです：

- 可能な鍵のセット**K**、ここで**K** = {0,1,2,…,25}からランダムに鍵kを選択します
- メッセージm є **M**を次のように暗号化します：
    - mを個々の文字m<sub>0</sub>, m<sub>1</sub>,….m<sub>i</sub>….,m<sub>l</sub>に分割します
    - *D*に従って各m<sub>i</sub>を数値に変換します
    - 各m<sub>i</sub>について、c<sub>i</sub> = [(m<sub>i</sub> + k) mod 26]
    - *D*に従って各c<sub>i</sub>を文字に変換します
    - それからc<sub>0</sub>, c<sub>1</sub>,….,c<sub>l</sub>を組み合わせて暗号文cを生成します
- 暗号文cを次のように復号します：
    - *D*に従って各c<sub>i</sub>を数値に変換します
    - 各c<sub>i</sub>について、m<sub>i</sub> = [(c<sub>i</sub> – k) mod 26]
    - *D*に従って各m<sub>i</sub>を文字に変換します
    - それからm<sub>0</sub>, m<sub>1</sub>,….,m<sub>l</sub>を組み合わせて元のメッセージmを生成します

シフト暗号が対称暗号化スキームであるとされるのは、暗号化と復号の両プロセスで同じ鍵が使用されるためです。例えば、シフト暗号を使用してメッセージ「DOG」を暗号化したいとし、ランダムに「24」という鍵を選択したとします。この鍵でメッセージを暗号化すると「BME」が得られます。元のメッセージを取り出す唯一の方法は、復号プロセスにも同じ鍵「24」を使用することです。
このシフト暗号は、**単一換字式暗号**の一例です：暗号文アルファベットが固定されている暗号化方式です（つまり、一つのアルファベットのみが使用されます）。復号アルゴリズムが決定的であると仮定すると、置換暗号文の各記号は、平文の一つの記号に最大で関連付けられます。
1700年代まで、多くの暗号化の応用は単一換字式暗号に大きく依存していましたが、しばしばこれらはシフト暗号よりもはるかに複雑でした。例えば、暗号文アルファベット内で各文字が一度だけ出現するという制約の下で、元のテキストの文字ごとにアルファベットからランダムに文字を選択することができます。これは、コンピューター時代以前には非常に多い、階乗26の可能な秘密鍵を意味します。

暗号学では**cipher**（暗号）という用語に頻繁に出会うことになります。この用語がさまざまな意味を持つことを認識してください。実際、暗号学内でこの用語の少なくとも5つの異なる意味を知っています。

場合によっては、シフト暗号や単一換字式暗号でのように、暗号化方式を指すことがあります。しかし、この用語は特に暗号化アルゴリズム、秘密鍵、またはそのような暗号化方式の任意の暗号文を指すこともあります。

最後に、cipherという用語は、暗号化スキームを構築できるコアアルゴリズムを指すこともあります。これにはさまざまな暗号化アルゴリズムだけでなく、他のタイプの暗号化スキームも含まれます。この用語の意味は、ブロック暗号のコンテキスト（下記の「ブロック暗号」セクションを参照）で関連性があります。

**encipher**（暗号化する）や**decipher**（復号する）という用語にも出会うかもしれません。これらの用語は単に暗号化と復号の同義語です。

## Brute force attacks and Kerckhoff's principle
<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

シフト暗号は、現代の世界では非常に安全性が低い対称暗号化方式です。<sup>[1](#footnote1)</sup> 攻撃者は、どの結果が意味をなすかを見るために、26の可能な鍵すべてで暗号文の復号を試みることができます。このタイプの攻撃、つまり攻撃者が何が機能するかを見るために鍵を順番に試すことは、**ブルートフォース攻撃**または**全鍵探索攻撃**として知られています。

任意の暗号化方式が最小限のセキュリティ概念を満たすためには、ブルートフォース攻撃が非現実的であるほど大きな鍵空間、または**鍵空間**を持っていなければなりません。すべての現代の暗号化方式はこの基準を満たしています。これは**十分な鍵空間原則**として知られています。類似の原則は、異なるタイプの暗号化スキームにも通常適用されます。

現代の暗号化方式の巨大な鍵空間のサイズを感じるために、ファイルが高度暗号化標準を使用して128ビットで暗号化されていると仮定します。これは、攻撃者がブルートフォース攻撃のために通過する必要がある2<sup>128</sup>の鍵のセットを持っていることを意味します。この戦略で0.78%の成功率を得るには、攻撃者はおよそ2.65 x 10<sup>36</sup>の鍵を通過する必要があります。
攻撃者が1秒間に10京（すなわち、10<sup>16</sup>）の鍵を試みることができると楽観的に仮定した場合、鍵空間内の全鍵の0.78%をテストするには、彼女の攻撃は2.65 x 10<sup>20</sup>秒続かなければなりません。これは約8.4兆年に相当します。したがって、現代の128ビット暗号化方式では、非常に強力な敵によるブルートフォース攻撃も現実的ではありません。これが適切な鍵空間原理が働いている例です。

攻撃者が暗号化アルゴリズムを知らない場合、シフト暗号はより安全になりますか？おそらくそうですが、それほどではありません。

いずれにせよ、現代の暗号学では、任意の対称暗号化方式のセキュリティは、秘密鍵を秘密に保つことのみに依存していると常に仮定されます。攻撃者は、メッセージ空間、鍵空間、暗号文空間、鍵選択アルゴリズム、暗号化アルゴリズム、および復号アルゴリズムを含む、他のすべての詳細を知っていると想定されます。

対称暗号化方式のセキュリティが秘密鍵の秘密にのみ依存できるという考え方は、**ケルクホフスの原則**として知られています。

ケルクホフスが当初意図したように、この原則は対称暗号化方式にのみ適用されます。しかし、より一般的なバージョンの原則は、他のすべての現代の暗号化方式にも適用されます：任意の暗号化方式の設計は、それが安全であるために秘密である必要はなく、秘密は典型的には秘密鍵などの情報の文字列にのみ及ぶことができます。

ケルクホフスの原則は、4つの理由から現代の暗号学にとって中心的なものです。<sup>[2](#footnote2)</sup> 第一に、特定のタイプのアプリケーションに対する暗号化方式の数は限られています。たとえば、ほとんどの現代の対称暗号化アプリケーションはリジンダル暗号を使用しています。したがって、方式の設計に関するあなたの秘密は非常に限られています。しかし、リジンダル暗号のいくつかの秘密鍵を秘密に保つことには、はるかに多くの柔軟性があります。

第二に、情報の文字列を交換することは、暗号化方式全体を交換することよりも簡単です。会社の従業員全員が同じ暗号化ソフトウェアを持ち、2人の従業員ごとに機密通信のための秘密鍵を持っていると仮定します。このシナリオでは鍵の妥協は面倒ですが、少なくともそのようなセキュリティ違反のあるソフトウェアを会社が保持することができます。会社が方式の秘密に依存していた場合、その秘密のいかなる違反もすべてのソフトウェアを交換する必要があります。

第三に、ケルクホフスの原則は、暗号化方式のユーザー間の標準化と互換性を可能にします。これは効率性に大きな利点をもたらします。たとえば、そのセキュリティが暗号化方式を秘密に保つことを要求した場合、毎日何百万人もの人々がGoogleのWebサーバーに安全に接続することを想像するのは難しいでしょう。

第四に、ケルクホフスの原則は、暗号化方式の公開審査を可能にします。このタイプの審査は、安全な暗号化方式を達成するために絶対に必要です。例示的に、対称暗号学の主要なコアアルゴリズムであるリジンダル暗号は、1997年から2000年にかけて国立標準技術研究所によって組織されたコンペティションの結果でした。

**セキュリティ・バイ・オブスキュリティ（曖昧さによるセキュリティ）**を達成しようとするシステムは、その設計および/または実装の詳細を秘密に保つことに依存するシステムです。暗号学において、これは具体的には暗号化方式の設計の詳細を秘密に保つことに依存するシステムです。したがって、セキュリティ・バイ・オブスキュリティはケルクホフスの原則と直接対立します。
オープン性が品質とセキュリティを強化する能力は、暗号学だけでなく、より広くデジタル世界にも及びます。例えば、DebianのようなフリーかつオープンソースのLinuxディストリビューションは、プライバシー、安定性、セキュリティ、柔軟性の面で、一般的にWindowsやMacOSといった他のOSよりもいくつかの利点を持っています。その理由は複数ありますが、最も重要な原則はおそらく、エリック・レイモンドが彼の有名なエッセイ「大聖堂とバザール」で述べたように、「十分な数の目があれば、すべてのバグは浅い」<sup>[3](#footnote3)</sup>というものです。この群衆の知恵のような原則が、Linuxに最も重要な成功をもたらしました。
暗号方式が「安全」または「不安全」であると断定的に言うことはできません。代わりに、暗号方式にはさまざまなセキュリティの概念があります。**暗号セキュリティの定義**は、(1) セキュリティ目標と、(2) 攻撃者の能力を指定する必要があります。特定のセキュリティの概念に対して暗号方式を分析することで、その応用と限界についての洞察を得ることができます。

ここでは暗号セキュリティのさまざまな概念の詳細には踏み込みませんが、対称および非対称方式（および他の暗号プリミティブのいくつかの形式）に関連するすべての現代の暗号セキュリティの概念に共通する二つの仮定を知っておくべきです：

* 攻撃者の方式に関する知識はケルクホッフスの原則に従います。
* 攻撃者は方式に対して実行可能なブルートフォース攻撃を行うことができません。具体的には、暗号セキュリティの概念の脅威モデルは通常、ブルートフォース攻撃を許可さえしません。なぜなら、これらは関連する考慮事項ではないと仮定しているからです。

## ストリーム暗号
<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

対称暗号方式は一般的に、ストリーム暗号とブロック暗号の二つのタイプに分けられます。しかし、この区別はやや問題があります。なぜなら、これらの用語を一貫性のない方法で使用する人がいるからです。次の数節で、私が最も適切だと思う方法でこの区別を説明します。しかし、多くの人が私が説明する方法とは異なる方法でこれらの用語を使用することに注意してください。

まず、ストリーム暗号について説明しましょう。**ストリーム暗号**は、暗号化が二つのステップで構成される対称暗号方式です。

最初に、プレーンテキストの長さの文字列がプライベートキーを介して生成されます。この文字列は**キーストリーム**と呼ばれます。

次に、キーストリームがプレーンテキストと数学的に組み合わされて暗号文を生成します。この組み合わせは通常、XOR操作です。復号化には、単に操作を逆にすればよいです。（注：A XOR B = B XOR Aの場合、AとBがビット文字列であるため、ストリーム暗号におけるXOR操作の順序は結果に影響しません。この性質は交換性として知られています。）

典型的なXORストリーム暗号は*図3*に示されています。まず、プライベートキーKを取り、それを使用してキーストリームを生成します。次に、キーストリームをプレーンテキストとXOR操作で組み合わせて暗号文を生成します。暗号文を受け取ったエージェントは、キーKを持っていれば簡単に復号化できます。彼女がする必要があるのは、指定された方式の手順に従って暗号文と同じ長さのキーストリームを作成し、それを暗号文とXORすることです。

*図3: XORストリーム暗号*

![図3: XORストリーム暗号](assets/Figure4-3.webp "図3: XORストリーム暗号")
暗号化スキームは、厳密な仕様ではなく、同じ核心アルゴリズムを用いた暗号化のためのテンプレートであることを忘れないでください。同様に、ストリーム暗号は、異なる長さの鍵を使用できる暗号化のためのテンプレートです。鍵の長さはスキームの一部の細かい詳細に影響を与えることがありますが、その本質的な形には影響しません。
シフト暗号は、非常に単純で安全性の低いストリーム暗号の一例です。単一の文字（秘密鍵）を使用して、メッセージの長さの文字列（鍵ストリーム）を生成できます。この鍵ストリームは、その後、平文と組み合わせて、モジュロ演算を介して暗号文を生成します。（このモジュロ演算は、文字をビットで表現する場合、XOR演算に簡略化できます）。

ストリーム暗号のもう一つの有名な例は、**Vigenere暗号**です。これは16世紀の終わりにBlaise de Vigenereが完全に開発したものです（ただし、それ以前に他の人々が多くの先行作業を行っていました）。これは**多表式換字暗号**の一例です：平文記号の暗号文アルファベットがテキスト内の位置に応じて変化する暗号化スキームです。単表式換字暗号とは対照的に、暗号文記号は複数の平文記号と関連付けられます。

暗号化がルネサンス期のヨーロッパで人気を博するにつれて、**暗号解読**も同様に人気を博しました。特に、**頻度分析**を使用して暗号文を解読することがありました。後者は、言語の統計的な規則性を利用して暗号文を解読するもので、9世紀にはすでにアラビアの学者によって発見されていました。これは、特に長いテキストで非常にうまく機能する技術です。そして、ヨーロッパでは1700年代になると、特に軍事およびセキュリティ設定で、最も洗練された単表式換字暗号も頻度分析にはもはや十分ではありませんでした。Vigenere暗号はセキュリティの大幅な進歩を提供したため、この時期に人気が出て、1700年代後半には広く普及しました。

非公式には、暗号化スキームは以下のように機能します：

1. 私的鍵として複数文字の単語を選択する
2. 任意のメッセージに対して、鍵単語の対応する文字をシフトとして使用して、メッセージの各文字にシフト暗号を適用する
3. 鍵単語を一巡したが、まだ平文を完全に暗号化していない場合は、再度、鍵単語の文字をテキストの残りの対応する文字にシフト暗号として適用する
4. このプロセスを続けて、メッセージ全体が暗号化されるまで続ける

例として、あなたの秘密鍵がGOLDであり、メッセージ"Cryptography"を暗号化したい場合、Vigenere暗号に従って以下のように進めます：

- c<sub>0</sub> = [(2 + 6) Mod 26] = 8 = I
- c<sub>1</sub> = [(17 + 14) Mod 26] = 5 = F
- c<sub>2</sub> = [(24 + 11) Mod 26] = 9 = J
- c<sub>3</sub> = [(15 + 3) Mod 26] = 18 = S
- c<sub>4</sub> = [(19 + 6) Mod 26] = 25 = Z
- c<sub>5</sub> = [(14 + 14) Mod 26] = 2 = C
- c<sub>6</sub> = [(6 + 11) Mod 26] = 17 = R
- c<sub>7</sub> = [(17 + 3) Mod 26] = 20 = U
- c<sub>8</sub> = [(0 + 6) Mod 26] = 6 = G
- c<sub>9</sub> = [(15 + 14) Mod 26] = 3 = D
- c<sub>10</sub> = [(7 + 11) Mod 26] = 18 = S
- c<sub>11</sub> = [(24 + 3) Mod 26] = 1 = B
- c = "IFJSZCRUGDSB"

もう一つの有名なストリーム暗号の例は、**ワンタイムパッド**です。ワンタイムパッドでは、平文メッセージと同じ長さのランダムビットの文字列を単純に作成し、XOR演算を通じて暗号文を生成します。したがって、ワンタイムパッドでは、秘密鍵とキーストリームが同等です。

シフト暗号やヴィジュネル暗号は現代では非常に安全性が低いですが、ワンタイムパッドは正しく使用された場合には非常に安全です。ワンタイムパッドの最も有名な応用例は、少なくとも1980年代までは、**ワシントン-モスクワホットライン**でした。<sup>[4](#footnote4)</sup>

ホットラインは、キューバ危機後に設置されたワシントンとモスクワ間の緊急事態に対する直接通信リンクです。この技術は年々変化しており、現在では直接の光ファイバーケーブルと2つの衛星リンク（冗長性のため）を含み、電子メールやテキストメッセージングが可能です。リンクの終点はアメリカ国内の様々な場所にあります。ペンタゴン、ホワイトハウス、レイヴンロック山が知られています。一般的な意見とは異なり、ホットラインは電話を使用したことがありません。

本質的に、ワンタイムパッドの仕組みは次のように機能しました。ワシントンとモスクワは、2セットのランダムな数字を持っていました。ロシア人によって作成された1セットのランダムな数字は、ロシア語のメッセージの暗号化と復号化に関連していました。アメリカ人によって作成された1セットのランダムな数字は、英語のメッセージの暗号化と復号化に関連していました。時々、信頼できる宅配便によって他方により多くのランダムな数字が届けられました。

それから、ワシントンとモスクワは、これらのランダムな数字を使用してワンタイムパッドを作成し、秘密裏に通信することができました。通信する必要があるたびに、メッセージのために次のランダムな数字の部分を使用します。

非常に安全であるにもかかわらず、ワンタイムパッドは実用的な制限に直面しています：鍵はメッセージと同じ長さでなければならず、ワンタイムパッドの一部を再利用することはできません。これは、ワンタイムパッドのどこにいるかを追跡し、大量のビットを保存し、時々相手とランダムビットを交換する必要があることを意味します。その結果、ワンタイムパッドは実際には頻繁に使用されません。

代わりに、実際に使用される主流のストリーム暗号は**擬似ランダムストリーム暗号**です。Salsa20やそれに密接に関連する変種であるChaChaは、一般的に使用される擬似ランダムストリーム暗号の例です。

これらの擬似ランダムストリーム暗号では、まず平文の長さよりも短い鍵Kをランダムに選択します。このようなランダム鍵Kは、通常、コンピュータが時間の経過とともに収集する予測不可能なデータ、例えばネットワークメッセージ間の時間、マウスの動きなどに基づいて作成されます。
このランダムな鍵Kは、メッセージと同じ長さの擬似ランダム鍵ストリームを生成する拡張アルゴリズムに挿入されます。鍵ストリームがどれだけの長さである必要があるかを正確に指定することができます（例：500ビット、1000ビット、1200ビット、29,117ビットなど）。擬似ランダム鍵ストリームは、同じ長さのすべての文字列のセットから完全にランダムに選ばれたかのように*見えます*。したがって、擬似ランダム鍵ストリームを使用した暗号化は、ワンタイムパッドを使用したかのように見えます。しかし、もちろんそうではありません。

私たちの秘密鍵は鍵ストリームよりも短く、暗号化/復号化プロセスが機能するためには拡張アルゴリズムが決定論的である必要があるため、その特定の長さの鍵ストリームが私たちの拡張操作から出力として得られたわけではありません。

例えば、私たちの秘密鍵が128ビットの長さを持ち、それを拡張アルゴリズムに挿入して、例えば2,500ビットのはるかに長い鍵ストリームを作成できるとします。拡張アルゴリズムが決定論的である必要があるため、私たちのアルゴリズムは最大で2,500ビットの長さを持つ文字列の1/2<sup>128</sup>を選択することができます。したがって、そのような鍵ストリームは同じ長さのすべての文字列から完全にランダムに選択されることは決してありません。

ストリーム暗号の定義には2つの側面があります：(1) 私鍵の助けを借りてプレーンテキストと同じ長さの鍵ストリームが生成されること、および(2) この鍵ストリームがプレーンテキストと組み合わされ、通常はXOR操作を介して暗号文を生成することです。

時々、人々は条件(1)をより厳格に定義し、鍵ストリームが特に擬似ランダムでなければならないと主張します。これは、シフト暗号もワンタイムパッドもストリーム暗号とは見なされないことを意味します。

私の見解では、条件(1)をより広く定義することは、暗号化スキームを整理するためのより簡単な方法を提供します。さらに、特定の暗号化スキームが実際には擬似ランダム鍵ストリームに依存していないことがわかったとしても、それをストリーム暗号と呼ぶのをやめる必要がないことを意味します。

## ブロック暗号
<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

**ブロック暗号**が一般的に理解される最初の方法は、ストリーム暗号よりも原始的なものとしてです：適切な長さの文字列に対して鍵の助けを借りて長さを保持する変換を実行するコアアルゴリズム。このアルゴリズムは、暗号化スキームや他の種類の暗号スキームの作成に使用できます。

しばしば、ブロック暗号は64、128、256ビットなどのさまざまな長さの入力文字列と、128、192、256ビットなどのさまざまな長さの鍵を取ることができます。これらの変数によってアルゴリズムのいくつかの詳細が変わるかもしれませんが、コアアルゴリズムは変わりません。もし変わるなら、私たちは2つの異なるブロック暗号について話していることになります。ここでのコアアルゴリズム用語の使用は、暗号化スキームに対しても同じです。

以下の*図4*でブロック暗号の動作が示されています。長さLのメッセージMと鍵Kがブロック暗号への入力として機能し、長さLのメッセージM’を出力します。ほとんどのブロック暗号では、鍵はMおよびM’と同じ長さである必要はありません。

*図4: ブロック暗号*

![図4: ブロック暗号](assets/Figure4-4.webp "図4: ブロック暗号")
ブロック暗号自体は暗号化スキームではありません。しかし、ブロック暗号は様々な**動作モード**を用いて、異なる暗号化スキームを生成することができます。動作モードは、ブロック暗号の外側にいくつかの追加操作を加えるだけです。
これがどのように機能するかを説明するために、128ビットの入力文字列と128ビットの秘密鍵を必要とするブロック暗号（BC）を想定してみましょう。下の図5は、そのブロック暗号を**電子コードブックモード**（**ECBモード**）と共に使用して暗号化スキームを作成する方法を示しています。（右側の省略符は、必要な限りこのパターンを繰り返すことができることを示しています）。

*図5: ECBモードを用いたブロック暗号*

![図5: ECBモードを用いたブロック暗号](assets/Figure4-5.webp "図5: ECBモードを用いたブロック暗号")

ブロック暗号を用いた電子コードブック暗号化のプロセスは以下の通りです。平文メッセージを128ビットブロックに分割できるか確認してください。できない場合は、メッセージに**パディング**を追加して、結果が128ビットのブロックサイズで均等に分割できるようにします。これが暗号化プロセスに使用されるデータです。

次に、データを128ビット文字列のチャンク（M<sub>1</sub>、M<sub>2</sub>、M<sub>3</sub>、など）に分割します。各128ビット文字列を128ビットキーを用いてブロック暗号に通し、128ビットの暗号文チャンク（C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>、など）を生成します。これらのチャンクを再結合すると、完全な暗号文が形成されます。

復号は単に逆のプロセスですが、受信者は復号されたデータからパディングを取り除き、元の平文メッセージを生成するための認識可能な方法が必要です。

比較的単純であるにもかかわらず、電子コードブックモードを用いたブロック暗号はセキュリティに欠けています。これは、**決定論的暗号化**につながるためです。同一の128ビットデータ文字列が全く同じ方法で暗号化されます。その情報は悪用される可能性があります。

代わりに、ブロック暗号から構築された任意の暗号化スキームは**確率的**であるべきです：つまり、任意のメッセージM、またはMの特定のチャンクの暗号化は、一般的には毎回異なる結果をもたらすべきです。<sup>[5](#footnote5)</sup>

**暗号ブロック連鎖モード**（**CBCモード**）は、ブロック暗号で最も一般的に使用されるモードかもしれません。正しく行われた場合、この組み合わせは確率的な暗号化スキームを生成します。以下の図6でこの動作モードの描写を見ることができます。

*図6: CBCモードを用いたブロック暗号*

![図6: CBCモードを用いたブロック暗号](assets/Figure4-6.webp "図6: CBCモードを用いたブロック暗号")

再び、ブロックサイズが128ビットであるとします。したがって、始めるにあたり、元の平文メッセージが必要なパディングを受けることを再度確認する必要があります。

次に、平文の最初の128ビット部分を128ビットの**初期化ベクトル**とXORします。その結果はブロック暗号に入れられ、最初のブロックの暗号文を生成します。128ビットの2番目のブロックについては、最初に平文を最初のブロックの暗号文とXORし、それをブロック暗号に挿入します。このプロセスを続けて、平文メッセージ全体を暗号化します。

終了したら、暗号化されたメッセージと暗号化されていない初期化ベクトルを受信者に送信します。受信者は初期化ベクトルを知る必要があります。そうでなければ、彼女は暗号文を復号できません。
この構造は、正しく使用された場合、電子コードブックモードよりもはるかに安全です。まず、初期化ベクトルがランダムまたは擬似ランダムな文字列であることを確認する必要があります。さらに、この暗号化スキームを使用するたびに異なる初期化ベクトルを使用するべきです。
言い換えれば、初期化ベクトルはランダムまたは擬似ランダムな**nonce**であるべきです。ここで**nonce**は「一度だけ使用される数値」を意味します。この習慣を守れば、ブロック暗号を使用したCBCモードは、同一の平文ブロックが毎回異なって暗号化されることを保証します。

最後に、**出力フィードバックモード**（**OFBモード**）に注目しましょう。このモードの描写は*図7*で見ることができます。

*図7: OFBモードを持つブロック暗号*

![図7: OFBモードを持つブロック暗号](assets/Figure4-7.webp "図7: OFBモードを持つブロック暗号")

OFBモードでは、初期化ベクトルも選択します。しかし、ここでは最初のブロックにおいて、初期化ベクトルがあなたのキーと共に直接ブロック暗号に挿入されます。その結果得られる128ビットは、次にキーストリームとして扱われます。このキーストリームは平文とXORされ、ブロックの暗号文を生成します。後続のブロックでは、前のブロックのキーストリームをブロック暗号の入力として使用し、手順を繰り返します。

注意深く見ると、OFBモードを持つブロック暗号から実際に作成されているのはストリーム暗号です。平文の長さになるまで128ビットのキーストリーム部分を生成し（最後の128ビットキーストリーム部分から必要ないビットを破棄します）、その後、キーストリームを平文メッセージとXORして暗号文を得ます。

ストリーム暗号に関する前のセクションでは、秘密鍵の助けを借りてキーストリームを生成すると述べました。正確には、秘密鍵だけでなく、初期化ベクトルのサポートを受けてキーストリームが生成される必要があります。

CBCモードと同様に、OFBモードでブロック暗号を使用するたびに擬似ランダムまたはランダムなnonceを初期化ベクトルとして選択することが重要です。そうでない場合、異なる通信で送信される同じ128ビットメッセージ文字列が同じ方法で暗号化されます。これはストリーム暗号で確率的暗号化を作成する方法の一つです。

一部のストリーム暗号は、キーストリームを作成するために秘密鍵のみを使用します。そのようなストリーム暗号の場合、通信の各インスタンスに対して秘密鍵を選択するためにランダムなnonceを使用することが重要です。そうでない場合、それらのストリーム暗号での暗号化の結果も決定論的になり、セキュリティ上の問題を引き起こします。

最も人気のある現代のブロック暗号は**Rijndael暗号**です。これは、1997年から2000年にかけて、古い暗号化標準である**データ暗号化標準**（**DES**）を置き換えるために、国立標準技術研究所（NIST）によって開催されたコンペティションで、15の提出作品の中から選ばれたものです。
Rijndael暗号は、鍵の長さとブロックサイズの異なる仕様で使用できるほか、運用モードも異なります。NISTコンペティションの委員会は、Rijndael暗号の制限されたバージョン—具体的には128ビットのブロックサイズと、128ビット、192ビット、または256ビットの鍵長を要求するもの—を**高度暗号標準**（**AES**）の一部として採用しました。これは対称暗号化アプリケーションの主要な標準です。それは非常に安全で、NSAでさえもトップシークレットの文書に256ビット鍵で使用することを明らかにしています。<sup>[6](#footnote6)</sup>
AESブロック暗号については、*第5章*で詳しく説明されます。

## 混乱の解消
<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

ブロック暗号とストリーム暗号の区別についての混乱は、時々人々がブロック暗号を具体的に*暗号化モードのブロック暗号*を指す用語として理解することから生じます。

前のセクションのECBモードとCBCモードを考えてみましょう。これらは特に、暗号化するデータがブロックサイズで割り切れる必要があること（つまり、元のメッセージにパディングを使用する必要があるかもしれません）を要求します。さらに、これらのモードのデータはブロック暗号によって直接操作されます（OFBモードのようにブロック暗号操作の結果と単に組み合わされるのではありません）。

したがって、代わりに、**ブロック暗号**を、一度にメッセージの固定長ブロックで操作する任意の暗号化スキームと定義することもできます（どのブロックもバイトより長くなければならず、そうでなければストリーム暗号に崩壊します）。暗号化するデータと暗号文は、このブロックサイズに均等に分割されなければなりません。通常、ブロックサイズは64、128、192、または256ビットの長さです。対照的に、ストリーム暗号は、一度に1ビットまたは1バイトのチャンクで任意のメッセージを暗号化できます。

このより具体的なブロック暗号の理解により、現代の暗号化スキームはストリーム暗号またはブロック暗号のいずれかであると確かに主張できます。ここから先は、特に指定されていない限り、ブロック暗号という用語をより一般的な意味で使用します。

前のセクションのOFBモードに関する議論は、もう1つ興味深い点を提起します。RijndaelのOFBのように、ブロック暗号から構築されたストリーム暗号もあります。Salsa20やChaChaのように、ブロック暗号から作られていないものもあります。後者を**原始ストリーム暗号**と呼ぶこともあります。（このようなストリーム暗号を指す標準化された用語は実際にはありません。）

人々がストリーム暗号とブロック暗号の利点と欠点について話すとき、彼らは通常、原始ストリーム暗号とブロック暗号に基づく暗号化スキームを比較しています。

ブロック暗号からストリーム暗号を常に簡単に構築できる一方で、原始ストリーム暗号から（CBCモードのような）暗号化モードのブロック構造を構築することは通常非常に困難です。

この議論から、*図8*を理解するべきです。これは対称暗号化スキームの概要を提供します。私たちは3種類の暗号化スキームを使用します：原始ストリーム暗号、ブロック暗号ストリーム暗号、およびブロックモードのブロック暗号（図では「ブロック暗号」と呼ばれます）。

*図8: 対称暗号化スキームの概要*

![図8: 対称暗号化スキームの概要](assets/Figure4-8.webp "図8: 対称暗号化スキームの概要")


## メッセージ認証コード
<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>
暗号化は秘密性に関係しています。しかし、暗号学はメッセージの完整性、真正性、および否認防止など、より広いテーマにも関係しています。いわゆる**メッセージ認証コード**（MAC）は、通信における真正性と完整性をサポートする対称鍵暗号スキームです。

通信において、秘密性以外に何が必要なのでしょうか？例えば、Bobが実質的に解読不可能な暗号を使用してAliceにメッセージを送信したとします。このメッセージを傍受した攻撃者は、内容に関して有意な洞察を得ることができません。しかし、攻撃者には少なくとも他に2つの攻撃ベクトルが利用可能です：

1. 彼女は暗号文を傍受し、その内容を変更して、変更された暗号文をAliceに送信することができます。
2. 彼女はBobのメッセージを完全にブロックし、自分自身で作成した暗号文を送信することができます。

これらのケースでは、攻撃者は暗号文（1）および（2）から内容に関する洞察を得ることはできないかもしれません。しかし、このような方法で依然として重大な損害を引き起こすことができます。ここでメッセージ認証コードが重要になります。

メッセージ認証コードは、3つのアルゴリズムを持つ対称暗号スキームとして緩く定義されています：鍵生成アルゴリズム、タグ生成アルゴリズム、および検証アルゴリズム。安全なMACは、攻撃者にとってタグが**実存的に偽造不可能**であることを保証します。つまり、彼らが秘密鍵を持っていない限り、メッセージに対して検証されるタグを成功裏に作成することはできません。

BobとAliceは、MACを使用して特定のメッセージの操作を防ぐことができます。一時的に秘密性には関心がないと仮定しましょう。彼らが保証したいのは、Aliceが受け取ったメッセージが実際にBobからのものであり、何らかの方法で変更されていないことです。

プロセスは*図9*に示されています。MACを使用するには、まず彼らの間で共有される秘密鍵Kを生成します。Bobは秘密鍵Kを使用してメッセージに対するタグTを作成します。その後、メッセージとメッセージタグをAliceに送信します。彼女は、秘密鍵、メッセージ、およびタグを検証アルゴリズムにかけることで、Bobが実際にタグを作成したことを検証できます。

*図9: 対称暗号スキームの概要*

![図9: 対称暗号スキームの概要](assets/Figure4-9.webp "図9: 対称暗号スキームの概要")

実存的偽造不可能性により、攻撃者はメッセージMをいかなる方法で変更したり、有効なタグを持つ自分自身のメッセージを作成することはできません。これは、攻撃者が同じ秘密鍵を使用するBobとAlice間の多くのメッセージのタグを観察していたとしても同様です。攻撃者ができるのは、せいぜいAliceがメッセージMを受け取るのをブロックすることです（これは暗号学が対処できない問題です）。

MACは、メッセージが実際にBobによって作成されたことを保証します。この真正性は、自動的にメッセージの完整性を意味します。つまり、Bobが何らかのメッセージを作成した場合、それは事実上、攻撃者によって何らかの方法で変更されていないということです。したがって、これ以降、認証に関するあらゆる懸念は、自動的に完整性に関する懸念を意味するべきです。

私が議論でメッセージの真正性と完整性の区別を描いた一方で、これらの用語を同義語として使用することも一般的です。それらは、特定の送信者によって作成され、何らかの方法で変更されていないメッセージのアイデアを指します。この精神において、メッセージ認証コードは頻繁に**メッセージ完整性コード**とも呼ばれます。

## 認証付き暗号
<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>
通信においては、通常、秘密保持と真正性の両方を保証したいため、暗号化方式とMAC方式が一緒に使用されます。
**認証付き暗号化方式**は、高度に安全な方法で暗号化とMACを組み合わせた方式です。具体的には、存在的偽造不可能性の基準と、非常に強力な秘密保持の概念、すなわち**選択暗号文攻撃**に対する耐性を満たす必要があります。<sup>[7](#footnote7)</sup>

暗号化方式が選択暗号文攻撃に対して耐性を持つためには、**非可塑性**の基準を満たす必要があります。つまり、攻撃者による暗号文の任意の変更は、無効な暗号文または元のものとは無関係な平文に復号される暗号文を生じさせるべきです。<sup>[8](#footnote8)</sup>

認証付き暗号化方式は、攻撃者によって作成された暗号文が常に無効である（タグが検証されないため）ことを保証するため、選択暗号文攻撃に対する耐性の基準を満たします。興味深いことに、存在的偽造不可能なMACと、より弱いセキュリティ概念である**選択平文攻撃セキュリティ**を満たす暗号化方式の組み合わせから、常に認証付き暗号化方式を作成できることが証明できます。

認証付き暗号化方式の構築の詳細には踏み込みませんが、その構築の2つの詳細を知っておくことが重要です。

まず、認証付き暗号化方式は、最初に暗号化を処理し、次に暗号文に対してメッセージタグを作成します。暗号文と平文のタグを組み合わせる方法や、最初にタグを作成してから平文とタグの両方を暗号化する方法は、安全ではないことがわかっています。さらに、両方の操作にはそれぞれランダムに選択された秘密鍵が必要であり、そうでなければセキュリティが大きく損なわれます。

前述の原則は、より一般的に適用されます：*基本的な暗号化方式を組み合わせるときは、常に異なる鍵を使用すべきです*。

認証付き暗号化方式は*図10*で示されています。ボブは最初に、ランダムに選択された鍵K<sub>C</sub>を使用してメッセージMから暗号文Cを作成します。次に、異なるランダムに選択された鍵K<sub>T</sub>を使用して暗号文をタグ生成アルゴリズムに通し、メッセージタグTを作成します。暗号文とメッセージタグの両方がアリスに送られます。

アリスは今、最初に暗号文Cと鍵K<sub>T</sub>を与えられたタグが有効かどうかを確認します。有効であれば、次に鍵K<sub>C</sub>を使用してメッセージを復号できます。彼女は通信における非常に強力な秘密保持の概念を保証されるだけでなく、メッセージがボブによって作成されたことも知ることができます。

*図10: 認証付き暗号化方式*

![図10: 認証付き暗号化方式](assets/Figure4-10.webp "図10: 認証付き暗号化方式")

MACはどのように作成されるのでしょうか？MACは複数の方法で作成できますが、一般的で効率的な方法の一つは、暗号学的ハッシュ関数を介して作成することです。

*第6章*で暗号学的ハッシュ関数についてより詳しく紹介します。今のところ、**ハッシュ関数**は任意のサイズの入力を取り、固定長の出力を生成する効率的に計算可能な関数であることを知っておいてください。例えば、人気のあるハッシュ関数**SHA-256**（セキュアハッシュアルゴリズム256）は、入力のサイズに関係なく常に256ビットの出力を生成します。SHA-256のようないくつかのハッシュ関数は、暗号学において有用な応用があります。
暗号化ハッシュ関数で生成される最も一般的なタグのタイプは、**ハッシュベースのメッセージ認証コード**（HMAC）です。このプロセスは*図11*で示されています。ある当事者が秘密鍵Kから2つの異なる鍵、内部鍵K<sub>1</sub>と外部鍵K<sub>2</sub>を生成します。その後、平文Mまたは暗号文Cが内部鍵と一緒にハッシュされます。その結果T'は、外部鍵と一緒にハッシュされ、メッセージタグTを生成します。
HMACを作成するために使用できるハッシュ関数には、さまざまなものがあります。最も一般的に使用されるハッシュ関数はSHA-256です。

*図11: HMAC*

![図11: HMAC](assets/Figure4-11.webp "図11: HMAC")


## 安全な通信セッション
<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

2つの当事者が通信セッションにいると仮定し、彼らは複数のメッセージを行き来させます。

認証された暗号化スキームにより、メッセージの受信者は、そのメッセージが通信セッションのパートナーによって作成されたことを確認できます（秘密鍵が漏洩していない限り）。これは単一のメッセージに対しては十分に機能します。しかし、通常、2つの当事者は通信セッションでメッセージを行き来させます。その設定では、前のセクションで説明された通常の認証された暗号化スキームは、セキュリティを提供するのに不十分です。

主な理由は、認証された暗号化スキームが、メッセージが実際にも通信セッション内でそれを作成したエージェントによって送信されたことを保証しないことです。以下の3つの攻撃ベクトルを考えてみてください：

1. **リプレイ攻撃**：攻撃者が以前に2つの当事者の間で傍受した暗号文とタグを再送信します。
2. **再順序攻撃**：攻撃者が異なる時間に2つのメッセージを傍受し、それらを逆の順序で受信者に送信します。
3. **リフレクション攻撃**：攻撃者がAからBへ送信されたメッセージを観察し、そのメッセージをAにも送信します。

攻撃者が暗号文を知らず、偽の暗号文を作成できないにもかかわらず、上記の攻撃は通信において重大な損害を引き起こす可能性があります。

例えば、2つの当事者間の特定のメッセージが金融資金の移動に関連しているとします。リプレイ攻撃により、資金が2回転送される可能性があります。バニラの認証された暗号化スキームは、このような攻撃に対する防御手段を持っていません。

幸いなことに、このような攻撃は、**識別子**と**相対的な時間指標**を使用することで、通信セッション内で容易に軽減できます。

識別子は暗号化前の平文メッセージに追加することができます。これにより、リフレクション攻撃を防ぐことができます。相対的な時間指標は、例えば、特定の通信セッション内のシーケンス番号であることができます。各当事者は、暗号化前にメッセージにシーケンス番号を追加するので、受信者はメッセージが送信された順序を知ることができます。これにより、再順序攻撃の可能性が排除されます。また、リプレイ攻撃も排除されます。攻撃者が送信する任意のメッセージには古いシーケンス番号があり、受信者はそのメッセージを再び処理しないことを知ります。

安全な通信セッションの仕組みを説明するために、再びアリスとボブを想定してください。彼らは合計で4つのメッセージを行き来させます。識別子とシーケンス番号を備えた認証された暗号化スキームがどのように機能するかは、下の*図11*で見ることができます。
通信セッションは、BobがメッセージタグT<sub>0,B</sub>を伴う暗号文C<sub>0,B</sub>をAliceに送信することで開始します。この暗号文にはメッセージの他に、識別子（BOB）とシーケンス番号（0）が含まれています。タグT<sub>0,B</sub>は、暗号文全体に対して作成されます。その後の通信で、AliceとBobはこのプロトコルを維持し、必要に応じてフィールドを更新します。
*図12: 安全な通信セッション*

![図12: 安全な通信セッション](assets/Figure4-12.webp "図12: 安全な通信セッション")


## ノート
<chapterId>b96d38dd-c9cb-56a7-8764-4af8526bc63f</chapterId>

[^1]: セウトニウスによると、ジュリアス・シーザーは軍事通信において、常にキー値が3であるシフト暗号を使用していました。したがって、Aは常にDに、Bは常にEに、Cは常にFになります。この特定のシフト暗号のバージョンは、キー値が一定であるため、現代の意味での暗号とは言えませんが、**シーザー暗号**として知られるようになりました。シーザー暗号は紀元前1世紀において、ローマの敵が暗号化に非常に不慣れであれば安全だったかもしれません。しかし、現代においては明らかに非常に安全な方式とは言えません [^1]。

[^2]: Jonathan KatzとYehuda Lindell, *現代暗号学への導入*, CRC Press (Boca Raton, FL: 2015), p. 7f [^2]。

[^3]: Eric Raymond, “The Cathedral and the Bazaar,” この論文は1997年5月27日にドイツのヴュルツブルクで開催されたLinux Kongressで発表されました。その後、いくつかのバージョンが利用可能となり、また本としても出版されています。私の引用は、改訂版の本: Eric Raymond, *The Cathedral and the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary*, (2001), O’Reilly: Sebastopol, CAからのものです [^3]。

[^4]: Crypto Museum, "Washington-Moscow hotline," 2013, [Crypto Museum](https://www.cryptomuseum.com/crypto/hotline/index.htm) で利用可能 [^4]。

[^5]: 確率的暗号化の重要性は、Shafi GoldwasserとSilvio Micaliによって最初に強調されました、“Probabilistic encryption,” *Journal of Co [^5]。



# RC4とAES
<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

この章では、現代のプリミティブストリーム暗号であるRC4（または"Rivest cipher 4"）と、現代のブロック暗号であるAESについての暗号化スキームの詳細を議論します。RC4暗号は暗号化方法として不評になっていますが、AESは現代の対称暗号化の標準です。これら2つの例は、対称暗号化が内部でどのように機能するかについてより良い理解を提供するはずです。


## RC4ストリーム暗号
<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>
現代の擬似乱数ストリーム暗号がどのように機能するかを理解するために、RC4ストリーム暗号に焦点を当てます。RC4は、WEPおよびWAPワイヤレスアクセスポイントセキュリティプロトコルやTLSで使用されていた擬似乱数ストリーム暗号です。RC4には多くの証明された弱点があり、現在は好まれなくなっています。実際に、インターネットエンジニアリングタスクフォースは、TLSのすべてのインスタンスにおいてクライアントとサーバーアプリケーションによるRC4スイートの使用を禁止しています。<sup>[3](#footnote3)</sup> それにもかかわらず、原始的なストリーム暗号がどのように機能するかを示す例としては適しています。

まず、baby RC4暗号を使用して平文メッセージを暗号化する方法を示します。平文メッセージが「SOUP」と仮定します。そこで、baby RC4暗号を使用した暗号化は、以下の四つのステップで進行します。

### ステップ 1

まず、S[0] = 0からS[7] = 7までの配列Sを定義します。ここでの配列は、インデックスによって整理された値の変更可能なコレクションを単に意味し、一部のプログラミング言語（例えば、Python）ではリストと呼ばれます。この場合、インデックスは0から7まで実行され、値も0から7まで実行されます。したがって、Sは以下の通りです：

- S = [0,1,2,3,4,5,6,7]

ここでの値はASCII数値ではなく、1バイト文字の10進数値表現です。したがって、値2は0000 0011と等しくなります。配列Sの長さは、したがって、8バイトです。

### ステップ 2

次に、1バイトから8バイトの間のキーを選択することにより、8バイト長のキーアレイKを定義します（バイトの分数は許可されません）。各バイトが8ビットであるため、キーの各バイトについて0から255までの任意の数を選択できます。

キーkを[14,48,9]と選択し、それが3バイトの長さを持つと仮定します。それから、キーアレイの各インデックスは、その特定のキー要素の10進数値に従って設定されます。キー全体を実行したら、最初から始めて、キーアレイの8つのスロットを埋めます。したがって、私たちのキーアレイは以下の通りです

- K = [14,48,9,14,48,9,14,48]

### ステップ 3

第三に、キーアレイKを使用して配列Sを変換するプロセスであるキースケジューリングを行います。プロセスは擬似コードで以下の通りです：

- 変数jとiを作成する
- 変数j = 0に設定する
- 0から7までの各iに対して：
	- j = j + S[i] + K[i] mod 8に設定する
	- S[i]とS[j]を交換する

配列Sの変換は*表1*によって示されます。

始めるにあたり、Sの初期状態が[0,1,2,3,4,5,6,7]で、jの初期値が0であることがわかります。これは、キーアレイ[14,48,9,14,48,9,14,48]を使用して変換されます。
forループはi = 0から始まります。上記の擬似コードによると、jの新しい値は6になります（j = j + S[0] + K[0] mod 8 = 0 + 0 + 14 mod 8 = 6 mod 8）。S[0]とS[6]を交換すると、1ラウンド後のSの状態は[6,1,2,3,4,5,0,7]になります。
次の行では、i = 1です。forループを再び通過すると、jは7の値を取得します（j = j + S[1] + K[1] mod 8 = 6 + 1 + 48 mod 8 = 55 mod 8 = 7 mod 8）。現在のSの状態、[6,1,2,3,4,5,0,7]からS[1]とS[7]を交換すると、2ラウンド後には[6,7,2,3,4,5,0,1]になります。

このプロセスを続けて、配列Sの最終行、[6,4,1,0,3,7,5,2]を生成します。

*表1: キースケジューリング表*

![表1: キースケジューリング表](assets/Table5-1.webp "Table 1: Key scheduling table")

### ステップ4

第四のステップとして、キーストリームを生成します。これは、送信したいメッセージと同じ長さの擬似ランダム文字列です。これが元のメッセージ「SOUP」を暗号化するために使用されます。メッセージと同じ長さのキーストリームが必要なので、4バイトのものが必要です。

キーストリームは、以下の擬似コードによって生成されます：

- 変数j、i、およびtを作成する
- j = 0に設定
- 平文の各iについて、i = 1から始めてi = 4まで、キーストリームの各バイトは次のように生成されます：
    - j = j + S[i] mod 8
	- S[i]とS[j]を交換
	- t = S[i] + S[j] mod 8
	- キーストリームのithバイト = S[t]

*表2*で計算を追うことができます。

Sの初期状態 = S = [6,4,1,0,3,7,5,2]。i = 1に設定すると、jの値は4になります（j = j + S[i] mod 8 = 0 + 4 mod 8 = 4）。次に、S[1]とS[4]を交換して、2行目でSの変換、[6,3,1,0,4,7,5,2]を生成します。次に、tの値は7になります（t = S[i] + S[j] mod 8 = 3 + 4 mod 8 = 7）。最終的に、キーストリームのバイトは、S[7]、つまり2になります。

次に、他のバイトを生成し続けると、次の4バイトが得られます：2、6、3、および7。これらの各バイトは、平文「SOUP」の各文字を暗号化するために使用できます。
まず、ASCIIテーブルを使用して、「SOUP」を基にしたバイト文字列の10進数値でエンコードすると、「83 79 85 80」となります。キーストリーム「2 6 3 2」との組み合わせにより、「85 85 88 82」となり、256でのモジュロ演算後も変わりません。ASCIIでは、暗号文「85 85 88 82」は「UUXR」に等しいです。

配列Sよりも長い単語を暗号化する場合はどうなるでしょうか？その場合、配列Sは上記に示された方法でプレーンテキストの各バイトiに対して変換し続け、プレーンテキストの文字数と等しいバイト数のキーストリームを持つまで続けます。

*表2: キーストリーム生成*

![表2: キーストリーム生成](assets/Table5-2.webp "表2: キーストリーム生成")

ここで議論した例は、RC4ストリーム暗号の薄められたバージョンに過ぎません。実際のRC4ストリーム暗号は、8バイトではなく256バイトの長さのS配列を持ち、キーは1から8バイトの間ではなく、1から256バイトの間であることができます。キーアレイとキーストリームは、S配列の256バイトの長さを考慮して生成されます。計算は非常に複雑になりますが、原則は同じです。標準的なRC4暗号を使用し、同じキー[14,48,9]で、プレーンテキストメッセージ「SOUP」は16進数形式で67 02 ed dfとして暗号化されます。

キーストリームがプレーンテキストメッセージや暗号文とは独立して更新されるストリーム暗号は、**同期ストリーム暗号**です。キーストリームはキーにのみ依存します。明らかに、RC4は同期ストリーム暗号の一例であり、キーストリームはプレーンテキストや暗号文とは関係がありません。前章で述べた私たちの原始的なストリーム暗号、シフト暗号、ヴィジュネル暗号、ワンタイムパッドもまた、同期型でした。

対照的に、**非同期ストリーム暗号**は、キーと暗号文の以前の要素の両方によってキーストリームが生成されます。このタイプの暗号は、**自己同期暗号**とも呼ばれます。

重要なことに、RC4で生成されたキーストリームはワンタイムパッドとして扱うべきであり、次回まったく同じ方法でキーストリームを生成することはできません。キーを毎回変更するのではなく、実用的な解決策はキーとナンスを組み合わせてバイトストリームを生成することです。

## 128ビットキーを使用したAES
<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

前章で述べたように、国立標準技術研究所（NIST）は1997年から2000年にかけて、新しい対称暗号標準を決定するためのコンペティションを開催しました。リジンダル暗号が優勝エントリーとなりました。この名前は、ベルギーの創作者であるVincent RijmenとJoan Daemenの名前をもじったものです。

リジンダル暗号はブロック暗号であり、異なる鍵長とブロックサイズの仕様を使用できるコアアルゴリズムがあります。それにより、異なる動作モードを使用して暗号化スキームを構築できます。
NISTコンペティションの委員会は、Rijndael暗号の制限バージョンを採用しました。具体的には、128ビットのブロックサイズと、128ビット、192ビット、または256ビットのキー長を要求するもので、これは高度暗号標準の一部として採用されました。このRijndael暗号の制限バージョンは、複数の動作モードでも使用できます。標準の仕様は、高度暗号標準（AES）として知られています。
Rijndael暗号、つまりAESの核心がどのように機能するかを示すために、128ビットキーでの暗号化プロセスを説明します。キーサイズは、各ブロックの暗号化に必要なラウンド数に影響を与えます。128ビットキーの場合、10ラウンドが必要です。192ビットおよび256ビットでは、それぞれ12ラウンドと14ラウンドが必要になります。

さらに、AESがECBモードで使用されると仮定します。これにより説明が少し簡単になり、Rijndaelアルゴリズムには影響しません。確かに、ECBモードは決定論的暗号化につながるため、実際には安全ではありません。AESで最も一般的に使用される安全なモードはCBCです。

キーをK<sub>0</sub>と呼びましょう。上記のパラメータを使用した構造は、図1に示すように、128ビットの平文メッセージの一部を表すM<sub>i</sub>と、128ビットの暗号文の一部を表すC<sub>i</sub>で構成されます。平文がブロックサイズで均等に分割できない場合は、最後のブロックにパディングが追加されます。

*図1: 128ビットキーを使用したAES-ECB*

![図1: 128ビットキーを使用したAES-ECB](assets/Figure5-1.webp "図1: 128ビットキーを使用したAES-ECB")

テキストの各128ブロックは、Rijndael暗号化スキームで10ラウンドを経ます。これには、各ラウンドに対して別のラウンドキー（K<sub>1</sub>からK<sub>10</sub>まで）が必要です。これらは、元の128ビットキーK<sub>0</sub>から、キー拡張アルゴリズムを使用して各ラウンドに対して生成されます。したがって、暗号化される各テキストブロックに対して、元のキーK<sub>0</sub>と10個の別々のラウンドキーを使用します。これら同じ11のキーは、暗号化が必要な各128ビットブロックの平文に対して使用されることに注意してください。

キー拡張アルゴリズムは長く複雑です。それを詳しく説明することはあまり教育的な利益がありません。もしご希望であれば、キー拡張アルゴリズムを自分で調べることができます。ラウンドキーが生成されると、Rijndael暗号は図2に示すように、最初の128ビットブロックの平文M<sub>1</sub>を操作します。これらのステップをこれから説明します。

*図2: Rijndael暗号によるM<sub>1</sub>の操作*

![図2: 128ビットキーを使用したAES-ECB](assets/Figure5-2.webp "図2: 128ビットキーを使用したAES-ECB")

### ラウンド0

Rijndael暗号のラウンド0は単純です。128ビットの平文と秘密キーの間のXOR操作によって、配列S<sub>0</sub>が生成されます。つまり、

- S<sub>0</sub> = M<sub>1</sub> XOR K<sub>0</sub>
ラウンド1では、配列 S<sub>0</sub> がまずラウンドキー K<sub>1</sub> とXOR演算を用いて組み合わされます。これにより、Sの新しい状態が生成されます。
次に、現在のSの状態に対してバイト置換操作が実行されます。これは、16バイトのS配列の各バイトを取り、**RijndaelのSボックス**と呼ばれる配列のバイトに置き換えることで機能します。各バイトはユニークな変換を持ち、その結果としてSの新しい状態が生成されます。RijndaelのSボックスは*図3*に表示されています。

*図3: RijndaelのSボックス*

![図3: RijndaelのSボックス](assets/Figure5-3.webp "図3: RijndaelのSボックス")

このSボックスは、Rijndael暗号で抽象代数が登場する場所の一つであり、特にガロア体が関係しています。

まず、可能な各バイト要素00からFFを8ビットベクトルとして定義します。このような各ベクトルは、剰余演算のための既約多項式が x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1 であるガロア体GF(2<sup>8</sup>)の要素です。これらの仕様を持つガロア体は、Rijndaelの有限体とも呼ばれます。

次に、フィールド内の可能な各要素に対して、**Nyberg Sボックス**と呼ばれるものを作成します。このボックスでは、各バイトがその乗法逆数（つまり、その積が1に等しくなるように）にマッピングされます。それから、Nyberg Sボックスの値をアフィン変換を使用してRijndaelのSボックスにマッピングします。

S配列に対する3番目の操作は、行のシフト操作です。これは、Sの状態を取り、16バイトすべてを行列にリストアップします。行列の充填は左上から始まり、上から下へと進み、列が埋まるたびに一列右にシフトして上に戻ります。

Sの行列が構築されると、4つの行がシフトされます。最初の行はそのままです。2行目は左に1つ移動します。3行目は左に2つ移動します。4行目は左に3つ移動します。プロセスの例は*図4*に示されています。Sの元の状態が上に、行のシフト操作の後の結果状態がそれに続いて表示されます。

*図4: 行のシフト操作*

![図4: 行のシフト操作](assets/Figure5-4.webp "図4: 行のシフト操作")

4番目のステップでは、再びガロア体が登場します。始めに、S行列の各列が*図5*に示される4 x 4行列の列と乗算されます。しかし、通常の行列乗算ではなく、既約多項式 x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1 によるベクトル乗算です。結果として得られるベクトル係数は、バイトの個々のビットを表します。

*図5: 列の混合行列*

![図5: 列の混合行列](assets/Figure5-5.webp "図5: 列の混合行列")

S行列の最初の列を上記の4 x 4行列と乗算すると、*図6*に示される結果が得られます。
*図6: 最初の列の乗算*
![図6: 最初の列の乗算](assets/Figure5-6.webp "図6: 最初の列の乗算")

次のステップとして、行列内の全ての項目を多項式に変換する必要があります。例えば、F1は1バイトを表し、x<sup>7</sup> + x<sup>6</sup> + x<sup>5</sup> + x<sup>4</sup> + 1になり、03は1バイトを表し、x + 1になります。

その後、全ての乗算はx<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1でモジュロ演算されます。これにより、列の4つのセルそれぞれに4つの多項式が加算されます。これらの加算を2でモジュロ演算した後、4つの多項式が得られます。これらの多項式はそれぞれ、Sの8ビット文字列、つまり1バイトを表します。ここでは、*図6*の行列上でこれらの計算を全て実行しませんが、それは広範囲にわたるためです。

最初の列が処理された後、S行列の他の3列も同様の方法で処理されます。最終的にこれにより、16バイトの行列が得られ、配列に変換することができます。

最終ステップとして、配列Sは再びラウンドキーとXOR演算で組み合わされます。これにより状態S<sub>1</sub>が生成されます。つまり、

- S<sub>1</sub> = S XOR K<sub>0</sub>

### 2ラウンド目から10ラウンド目

2ラウンド目から9ラウンド目は、1ラウンド目の繰り返しに過ぎません、*mutatis mutandis*。最終ラウンドは前のラウンドと非常に似ていますが、ミックスカラムステップが省略されます。つまり、10ラウンド目は以下のように実行されます：

- S<sub>9</sub> XOR K<sub>10</sub>
- バイト置換
- 行のシフト
- S<sub>10</sub> = S XOR K<sub>10</sub>

状態S<sub>10</sub>は、暗号文の最初の128ビットであるC<sub>1</sub>に設定されます。残りの128ビットの平文ブロックを処理することで、完全な暗号文Cが得られます。

### Rijndael暗号の操作

Rijndael暗号で見られる異なる操作の背後にある理由は何ですか？

詳細には入りませんが、暗号化スキームは、混乱と拡散の程度に基づいて評価されます。暗号化スキームが高い程度の**混乱**を持つ場合、それは暗号文が平文と大きく異なることを意味します。暗号化スキームが高い程度の**拡散**を持つ場合、それは平文の小さな変更が大きく異なる暗号文を生み出すことを意味します。

Rijndael暗号の操作の背後にある理由は、それらが高い程度の混乱と拡散の両方を生み出すことです。混乱はバイト置換操作によって生じ、拡散は行のシフトと列の混合操作によって生じます。

# 非対称暗号
<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

対称暗号と同様に、非対称スキームも秘密保持と認証の両方を保証するために使用できます。しかし、これらのスキームは一つではなく二つの鍵を使用します：プライベートキーとパブリックキー。
私たちの調査は、非対称暗号の発見、特にそれを促した問題点から始まります。次に、暗号化と認証における非対称スキームが高レベルでどのように機能するかについて議論します。その後、非対称認証スキームを理解する上で重要なハッシュ関数を紹介し、第4章で議論したハッシュベースのメッセージ認証コードなど、他の暗号文脈でも関連性があることを説明します。

## 鍵の配布と管理の問題
<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

ボブがジムのスポーツ用品店、北米に数百万の顧客を持つオンラインスポーツ用品小売業者から新しいレインコートを購入したいとします。これは彼の彼らからの最初の購入になり、クレジットカードを使用したいと考えています。したがって、ボブはまずジムのスポーツ用品店とアカウントを作成する必要があり、これには住所やクレジットカード情報などの個人情報の送信が必要になります。その後、レインコートの購入に必要な手続きを進めることができます。

ボブとジムのスポーツ用品店は、このプロセス全体を通じて通信が安全であることを確認したいと考えるでしょう。インターネットはオープンな通信システムであることを考慮すると、例えば、潜在的な攻撃者がボブのクレジットカードや住所の詳細を知ることができないようにしたり、彼の購入を繰り返したり、彼に代わって偽の購入を作成することができないようにしたいと思うでしょう。

前章で議論された高度な認証付き暗号化スキームは、確かにボブとジムのスポーツ用品店間の通信を安全にすることができます。しかし、そのようなスキームを実装するには明らかに実際的な障害があります。

これらの実際的な障害を説明するために、対称暗号のツールのみが存在した世界に住んでいたと仮定しましょう。その場合、ジムのスポーツ用品店とボブは、安全な通信を確保するために何をすることができるでしょうか？

そのような状況下では、彼らは安全に通信するためにかなりのコストを負担することになります。インターネットはオープンな通信システムであるため、彼らはそれを通じて鍵のセットを交換することはできません。したがって、ボブとジムのスポーツ用品店の代表者は、対面で鍵の交換を行う必要があります。

一つの可能性は、ジムのスポーツ用品店が特別な鍵交換場所を作成し、ボブや他の新規顧客が安全な通信のための鍵のセットを受け取ることができるようにすることです。これは明らかにかなりの組織的コストがかかり、新規顧客が購入を行う効率を大幅に低下させるでしょう。

または、ジムのスポーツ用品店は、非常に信頼できる宅配便を使ってボブに一対の鍵を送ることができます。これは、鍵交換場所を設けるよりも効率的かもしれません。しかし、これでも特に多くの顧客が一度または数回のみ購入する場合、かなりのコストがかかるでしょう。

次に、認証付き暗号化のための対称スキームも、ジムのスポーツ用品店がすべての顧客のために別々の鍵のセットを保管することを強制します。これは数千の顧客にとってはかなりの実際的な課題であり、ましてや数百万にとってはなおさらです。

この後者の点を理解するために、ジムのスポーツ用品店が各顧客に同じ一対の鍵を提供すると仮定してみましょう。これにより、各顧客（またはこの一対の鍵を入手できる他の誰か）は、ジムのスポーツ用品店とその顧客間のすべての通信を読んだり、さらには操作したりすることができます。その場合、通信に暗号を全く使用しないのと同じかもしれません。

顧客の一部にのみ鍵のセットを繰り返し使用することも、ひどいセキュリティ実践です。潜在的な攻撃者は、スキームのその特徴を利用しようと試みるかもしれません（攻撃者は、鍵以外のスキームについてすべて知っていると仮定されますが、これはケルクホフスの原則に従います）。

したがって、ジムのスポーツ用品店は、これらの鍵のペアがどのように配布されるかに関係なく、各顧客のために一対の鍵を保管する必要があります。これは明らかにいくつかの実際的な問題を提示します。

- ジムのスポーツ用品店は、各顧客のために数百万の鍵のペアを保管する必要があります。
これらの鍵は、ハッカーにとって確実な標的となるため、適切に保護されなければなりません。セキュリティの侵害が発生した場合、特別な鍵交換場所や宅配便による費用のかかる鍵交換を繰り返す必要があります。ジムのスポーツ用品店のどの顧客も、自宅で一対の鍵を安全に保管する必要があります。紛失や盗難が発生し、鍵交換を繰り返す必要が出てきます。顧客は、インターネット上で通信や取引を行いたい他のオンラインストアや他のタイプのエンティティについても、このプロセスを経る必要があります。

ここで述べた2つの主な課題は、1970年代まで非常に基本的な懸念事項でした。それらは、**鍵配布問題**と**鍵管理問題**として知られていました。

もちろん、これらの問題は常に存在しており、過去には頭痛の種となることがよくありました。例えば、軍隊は、大きなリスクとコストを伴いながら、現場の人員に安全な通信のための鍵が記載された本を常に配布しなければなりませんでした。しかし、世界が長距離のデジタル通信、特に非政府組織にとってのものへと移行していくにつれて、これらの問題は悪化していました。

これらの問題が1970年代に解決されなかった場合、ジムのスポーツ用品店での効率的で安全なショッピングはおそらく存在しなかったでしょう。実際、実用的で安全な電子メール、オンラインバンキング、オンラインショッピングを含む、現代のほとんどの世界は、おそらく遠い夢物語に過ぎなかったでしょう。ビットコインのようなものさえ、全く存在しえなかったでしょう。

では、1970年代に何が起こったのでしょうか？どうして私たちはオンラインで瞬時に購入を行い、ワールドワイドウェブを安全に閲覧することができるのでしょうか？どうして私たちはスマートフォンから世界中にビットコインを瞬時に送ることができるのでしょうか？

## 暗号学における新たな方向性
<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

1970年代には、鍵配布問題と鍵管理問題が、アメリカの学術的な暗号学者のグループ、ホイットフィールド・ディフィー、マーティン・ヘルマン、ラルフ・マークルの注目を集めました。彼らの多くの同僚からの厳しい懐疑論に直面しながら、彼らはそれに対する解決策を考案することに挑みました。

彼らの冒険の少なくとも一つの主な動機は、オープンなコンピュータ通信が私たちの世界に深い影響を与えるという先見の明でした。ディフィーとヘルマンは1976年に次のように述べています。

> コンピュータ制御の通信ネットワークの発展は、世界の反対側にいる人々やコンピュータ間の労力を要しない、安価な接触を約束します。これは、多くの郵便物や多くの外出を電気通信で置き換えることになります。多くのアプリケーションでは、これらの接触を盗聴や不正なメッセージの注入から保護する必要があります。しかし、現在、セキュリティ問題の解決は通信技術の他の分野よりも大きく遅れています。*現代の暗号学は要件を満たすことができず、その使用はシステムユーザーにとって非常に重大な不便を課すため、テレプロセッシングの多くの利点をなくしてしまいます。*<sup>[1](#footnote1)</sup>

ディフィー、ヘルマン、マークルの粘り強さが報われました。彼らの結果の最初の公表は、ディフィーとヘルマンによる1976年の論文「暗号学における新たな方向性」でした。この中で、彼らは鍵配布問題と鍵管理問題に対処する2つの独創的な方法を提示しました。
彼らが最初に提案した解決策は、不安全な通信チャネル上で1つ以上の対称キーを交換するためのルールのセットである、リモート*鍵交換プロトコル*でした。このプロトコルは現在、*Diffie-Helmann鍵交換*または*Diffie-Helmann-Merkle鍵交換*として知られています。<sup>[2](#footnote2)</sup>
Diffie-Helmann鍵交換では、2つの当事者が最初にインターネットのような不安全なチャネル上で公にいくつかの情報を交換します。その情報を基にして、彼らはそれぞれ独立して、安全な通信のための対称キー（または対称キーのペア）を作成します。両方の当事者が独立してキーを作成する一方で、公に共有した情報がこのキー作成プロセスが両方にとって同じ結果をもたらすことを保証します。

重要なことに、不安全なチャネル上で当事者によって公に交換される情報を誰もが観察できる一方で、情報交換に参加している2つの当事者だけがそれから対称キーを作成できます。

もちろん、これは完全に反直感的に聞こえます。どうして2つの当事者が公にいくつかの情報を交換し、それによって彼らだけが対称キーを作成できるのでしょうか？情報交換を観察する他の誰かが同じキーを作成できない理由は何でしょうか？

もちろん、これはいくつかの美しい数学に依存しています。Diffie-Helmann鍵交換は、トラップドアを持つ一方向関数を介して機能します。これら2つの用語の意味について順に説明しましょう。

ある関数f(x)と結果f(a) = yが与えられたとします。ここで、aはxの特定の値です。f(x)が**一方向関数**であるとは、aとf(x)が与えられたときにyの値を計算することは容易ですが、yとf(x)が与えられたときにaの値を計算することが計算上実行不可能である場合を指します。もちろん、一方向関数という名前は、そのような関数が一方向にしか計算が実用的でないという事実に由来します。

一部の一方向関数には、いわゆるトラップドアがあります。yとf(x)のみが与えられた状態でaを計算することが実際には不可能である一方で、ある特定の情報Zがあると、yからaを計算することが計算上実行可能になります。この情報Zは**トラップドア**として知られています。トラップドアを持つ一方向関数は、**トラップドア関数**として知られています。

ここではDiffie-Helmann鍵交換の詳細には踏み込みません。しかし、基本的には各参加者がいくつかの情報を作成し、その一部を公に共有し、一部を秘密に保持します。その後、各当事者は、自分の秘密の情報と他の当事者によって共有された公開情報を取り、プライベートキーを作成します。そして、何とかして、両方の当事者が同じプライベートキーを持つことになります。

Diffie Helmann鍵交換で2つの当事者間で公に共有される情報のみを観察する任意の当事者は、これらの計算を複製することができません。そうするためには、2つの当事者のいずれかからプライベート情報が必要になります。

1976年の論文で提示されたDiffie-Helmann鍵交換の基本バージョンはあまり安全ではありませんが、基本プロトコルの洗練されたバージョンは今日でも確かに使用されています。最も重要なことは、最新バージョンのトランスポート層セキュリティプロトコル（バージョン1.3）のすべての鍵交換プロトコルが、1976年にDiffieとHellmanによって提示されたプロトコルの豊かなバージョンであるということです。トランスポート層セキュリティプロトコルは、Webコンテンツを交換するための標準であるハイパーテキスト転送プロトコル（http）に従って情報を安全に交換するための主要なプロトコルです。
重要な点として、Diffie-Helmann鍵交換は非対称方式ではありません。厳密に言えば、それは対称鍵暗号の領域に属すると言えるでしょう。しかし、Diffie-Helmann鍵交換と非対称暗号化の両方が、トラップドアを持つ一方向数論関数に依存しているため、通常は一緒に議論されます。
DiffieとHelmannが1976年の論文で鍵の配布と管理の問題に対処するために提案した第二の方法は、もちろん非対称暗号化を通じてでした。

Diffie-Hellman鍵交換の提示とは対照的に、彼らは非対称暗号化スキームがどのように構築されうるかの一般的な輪郭のみを提供しました。彼らは、そのようなスキームで合理的なセキュリティに必要な条件を満たすことができる特定の一方向関数を提供しませんでした。

しかし、実用的な非対称スキームは、1年後に異なる3人の学術暗号学者および数学者によって見つかりました：Ronald Rivest、Adi Shamir、Leonard Adleman。<sup>[3](#footnote3)</sup> 彼らが紹介した暗号システムは、彼らの姓から**RSA暗号システム**として知られるようになりました。

非対称暗号化（およびDiffie Helmann鍵交換）で使用されるトラップドア関数は、主に2つの**計算上の困難な問題**に関連しています：素因数分解と離散対数の計算。

**素因数分解**は、その名が示すように、整数をその素因数に分解することを要求します。RSA問題は、素因数分解に関連する暗号システムの中で最もよく知られた例です。

**離散対数問題**は、巡回群で発生する問題です。特定の巡回群の生成元が与えられた場合、その生成元から群内の別の要素を生成するために必要な一意の指数を計算することを要求します。

離散対数ベースのスキームは、整数の乗法群と楕円曲線上の点を含む群という、2つの主要な種類の巡回群に依存しています。元々のDiffie Helmann鍵交換は、「暗号学における新しい方向性」で提示されたように、整数の巡回乗法群で動作します。Bitcoinのデジタル署名アルゴリズムおよび最近導入されたSchnorr署名スキーム（2021年）は、特定の楕円曲線巡回群の離散対数問題に基づいています。

次に、非対称設定における秘密保持と認証の概要について説明します。しかし、その前に、簡単な歴史的なメモをする必要があります。

現在、イギリスの暗号学者および数学者のグループが、Government Communications Headquarters (GCHQ)で働いている数年前に、上記の発見を独立して行っていたと考えられるようになりました。このグループには、James Ellis、Clifford Cocks、Malcolm Williamsonが含まれていました。

彼ら自身のアカウントとGCHQのそれによると、公開鍵暗号の概念は1969年にJames Ellisによって最初に考案されました。Clifford Cocksはその後、1973年にRSA暗号システムを発見し、Malcolm Williamsonは1974年にDiffie Helmann鍵交換の概念を発見したとされています。<sup>[4](#footnote4)</sup> しかし、彼らの発見は、GCHQで行われた作業の秘密性を考慮して、1997年まで公表されなかったとされています。


## 非対称暗号化と認証
<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

*図1*では、BobとAliceを助けを借りて、非対称暗号化の概要が提供されています。
Aliceはまず、公開鍵（K<sub>P</sub>）と秘密鍵（K<sub>S</sub>）からなる鍵のペアを作成します。ここで、K<sub>P</sub>の「P」は「public（公開）」を、「K<sub>S</sub>」の「S」は「secret（秘密）」を意味します。その後、Aliceはこの公開鍵を他人に自由に配布します。この配布プロセスの詳細については後ほど戻りますが、今のところBobを含む誰でも、Aliceの公開鍵K<sub>P</sub>を安全に入手できると仮定してください。
後になって、BobはAliceにメッセージMを書きたくなります。しかし、それには機密情報が含まれているため、Alice以外の誰にも内容が知られたくないと考えます。そこで、Bobは最初に公開鍵K<sub>P</sub>を使用してメッセージMを暗号化します。次に、結果として得られた暗号文CをAliceに送信します。Aliceは秘密鍵K<sub>S</sub>でCを復号して、元のメッセージMを生成します。

*図1: 非対称暗号化*

![図1: 非対称暗号化](assets/Figure6-1.webp "Figure 1: Asymmetric encryption")

BobとAliceの通信を盗聴する任意の敵は、Cを観察することができます。彼女はまた、K<sub>P</sub>と暗号化アルゴリズムE(·)を知っています。しかし、重要なことに、この情報では攻撃者が暗号文Cを実行可能に復号することはできません。復号には特にK<sub>S</sub>が必要であり、攻撃者はそれを持っていません。

対称暗号化スキームは、一般に、平文メッセージを有効に暗号化できる攻撃者（選択暗号文攻撃のセキュリティとして知られている）に対して安全である必要があります。しかし、攻撃者や他の誰かによるそのような有効な暗号文の作成を明示的に許可する目的で設計されているわけではありません。

これは、非対称暗号化スキームとは対照的であり、その全目的は攻撃者を含む誰でも有効な暗号文を生成できるようにすることです。したがって、非対称暗号化スキームは**複数アクセス暗号**としてラベル付けることができます。

何が起こっているのかをよりよく理解するために、Bobが電子的にではなく物理的な手紙を秘密裏に送りたいと考えたと想像してみてください。秘密を保つ一つの方法は、Aliceが安全な南京錠をBobに送るが、それを解除する鍵は彼女が保持することです。手紙を書いた後、Bobは手紙を箱に入れ、Aliceの南京錠でそれを閉じることができます。その後、鍵を持っているAliceに鍵のかかった箱を送ることができます。

Bobは南京錠をかけることができますが、箱を傍受する他の人も含め、誰もそれが確かに安全である場合は南京錠を解除することはできません。鍵を持っているAliceだけがそれを解除してBobの手紙の内容を見ることができます。

大まかに言えば、非対称暗号化スキームはこのプロセスのデジタルバージョンです。南京錠は公開鍵に似ており、南京錠の鍵は秘密鍵に似ています。しかし、南京錠がデジタルであるため、Aliceが秘密のメッセージを彼女に送りたいと思うかもしれない誰にでもそれを配布することははるかに簡単で、コストもかかりません。

非対称設定での認証には、**デジタル署名**を使用します。したがって、これらは対称設定のメッセージ認証コードと同じ機能を持っています。デジタル署名の概要は*図2*で提供されています。
Bobはまず、公開鍵（K<sub>P</sub>）と秘密鍵（K<sub>S</sub>）からなる鍵のペアを作成し、彼の公開鍵を配布します。BobがAliceに認証されたメッセージを送信したい場合、まず彼のメッセージMと秘密鍵を使用してデジタル署名Dを作成します。その後、Bobはそのメッセージとデジタル署名をAliceに送信します。Aliceはメッセージ、公開鍵、およびデジタル署名を検証アルゴリズムに挿入します。このアルゴリズムは、有効な署名に対してはtrueを、無効な署名に対してはfalseを生成します。
デジタル署名は、その名が明確に示すように、手紙や契約などにおける書面の署名のデジタル版です。実際、デジタル署名は通常、はるかに安全です。ある程度の努力をすれば、書面の署名を偽造することができます。これは、書面の署名が頻繁に厳密に検証されないという事実によって容易になります。しかし、安全なデジタル署名は、安全なメッセージ認証コードと同様に、**存在的に偽造不可能**です。つまり、安全なデジタル署名スキームでは、秘密鍵を持っていない限り、誰も検証手順を通過するメッセージの署名を現実的に作成することはできません。

*図2: 非対称認証*

![図2: 非対称認証](assets/Figure6-2.webp "図2: 非対称認証")

非対称暗号化と同様に、デジタル署名とメッセージ認証コードの間には興味深い対比があります。後者の場合、検証アルゴリズムは、安全な通信に通じている当事者の一方によってのみ使用できます。これは、秘密鍵が必要だからです。しかし、非対称設定では、Bobが作成したデジタル署名Sを誰でも検証できます。

これにより、デジタル署名は非常に強力なツールとなります。例えば、法的な目的で検証できる契約書に署名を作成する基盤となります。上記の交換でBobが契約書に署名を行っていた場合、AliceはメッセージM、契約書、および署名Sを法廷に示すことができます。その後、法廷はBobの公開鍵を使用して署名を検証することができます。<sup>[5](#footnote5)</sup>

別の例として、デジタル署名は、ソフトウェアおよびソフトウェア更新の配布を安全にする上で重要な側面です。このタイプの公開検証は、メッセージ認証コードを使用してのみ作成することはできません。

デジタル署名の力の最後の例として、Bitcoinを考えてみましょう。Bitcoinに関する最も一般的な誤解の一つは、特にメディアにおいて、トランザクションが暗号化されているということですが、それは違います。代わりに、Bitcoinトランザクションは、セキュリティを確保するためにデジタル署名を使用して機能します。

Bitcoinは、未使用トランザクション出力（またはUTXO）と呼ばれるバッチで存在します。特定のBitcoinアドレスで2ビットコインずつ3回の支払いを受け取ったとします。技術的には、そのアドレスに6ビットコインがあるわけではありません。代わりに、そのアドレスに関連付けられた暗号問題によってロックされた2ビットコインの3つのバッチを持っています。支払いを行う際には、トランザクションに必要な金額に応じて、これらのバッチの1つ、2つ、または全部を使用できます。

未使用トランザクション出力に対する所有権の証明は、通常、一つまたは複数のデジタル署名を介して示されます。Bitcoinは、未使用トランザクション出力に対する有効なデジタル署名を作成することが計算上不可能であるため、正確に機能します。これは、それらを作成するために必要な秘密情報を所有している場合に限ります。
現在、Bitcoinの取引では、取引に使用される未使用のトランザクション出力の起源など、ネットワークの参加者が検証する必要があるすべての情報が透明に含まれています。一部の情報を隠しても検証を可能にすることは可能です（Moneroなどの代替暗号通貨が行っているように）、しかし、これは特定のセキュリティリスクをもたらします。
デジタル署名とデジタルで捕捉された書面の署名について混乱が生じることがあります。後者の場合、書面の署名の画像をキャプチャして、雇用契約などの電子文書に貼り付けます。しかし、これは暗号学的な意味でのデジタル署名ではありません。後者は、秘密鍵を所持していることによってのみ生成できる長い数字に過ぎません。

対称鍵設定と同様に、非対称暗号化と認証スキームも一緒に使用することができます。同様の原則が適用されます。まず、暗号化とデジタル署名の作成には異なる秘密鍵・公開鍵ペアを使用するべきです。さらに、メッセージを暗号化してから認証するべきです。

重要なことは、多くのアプリケーションでは、通信プロセス全体を通じて非対称暗号化が使用されるわけではないということです。代わりに、通常は当事者間で実際に通信するために*対称鍵を交換する*ためにのみ使用されます。

例えば、オンラインで商品を購入する場合がこれに該当します。販売者の公開鍵を知っていれば、彼女はあなたにデジタル署名されたメッセージを送ることができ、あなたはその真正性を検証することができます。この基盤の上で、安全に通信するための対称鍵を交換するための複数のプロトコルのいずれかに従うことができます。

前述のアプローチが頻繁に使用される主な理由は、非対称暗号化が特定のレベルのセキュリティを提供するために対称暗号化よりもはるかに効率が悪いからです。これは、公開鍵暗号化の隣に対称鍵暗号化がまだ必要である理由の一つです。さらに、特定のアプリケーション、例えばコンピュータユーザーが自分のデータを暗号化する場合などでは、対称鍵暗号化がはるかに自然です。

では、デジタル署名と公開鍵暗号化は、鍵配布と鍵管理の問題をどのように解決するのでしょうか？

ここに一つの答えはありません。非対称暗号化はツールであり、そのツールを使用する方法は一つではありません。しかし、Jim's Sporting Goodsの以前の例を取り上げて、この例で問題が通常どのように対処されるかを示しましょう。

始めるにあたり、Jim's Sporting Goodsはおそらく**証明書機関**、公開鍵配布をサポートする組織にアプローチするでしょう。証明書機関は、Jim's Sporting Goodsに関するいくつかの詳細を登録し、公開鍵を付与します。それから、Jim's Sporting Goodsの公開鍵が証明書機関自身の公開鍵を使用してデジタル署名された**TLS/SSL証明書**として、Jim's Sporting Goodsに証明書を送ります。この方法で、証明書機関は特定の公開鍵が実際にJim's Sporting Goodsに属していることを確認します。

このプロセスを理解する鍵は、一般的にJim's Sporting Goodsの公開鍵がコンピュータにどこにも保存されていない一方で、認識された証明書機関の公開鍵はブラウザやオペレーティングシステムに実際に保存されているということです。これらは**ルート証明書**と呼ばれるものに保存されています。

したがって、Jim's Sporting GoodsがそのTLS/SSL証明書を提供すると、ブラウザやオペレーティングシステムのルート証明書を介して証明書機関のデジタル署名を検証することができます。署名が有効であれば、証明書の公開鍵が実際にJim's Sporting Goodsに属していることを比較的確信することができます。この基盤の上で、Jim's Sporting Goodsとの安全な通信のためのプロトコルを簡単に設定することができます。
Jim's Sporting Goodsの鍵配布は、大幅に簡素化されました。鍵管理も大幅に簡素化されたことは明らかです。何千もの鍵を保管する代わりに、Jim's Sporting Goodsは、公開鍵に対する署名を行うための秘密鍵を保管するだけで済みます。顧客がJim's Sporting Goodsのサイトにアクセスするたびに、この公開鍵から安全な通信セッションを確立できます。顧客は、オペレーティングシステムやブラウザに認識された証明書機関の公開鍵以外の情報を保管する必要はありません。

## ハッシュ関数
<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

ハッシュ関数は暗号学において至る所で使用されます。これらは対称暗号でも非対称暗号でもなく、独自の暗号学的カテゴリに分類されます。

第4章でハッシュベースの認証メッセージの作成において、既にハッシュ関数について触れました。デジタル署名の文脈でも重要ですが、少し異なる理由で：デジタル署名は通常、実際の（暗号化された）メッセージではなく、ある（暗号化された）メッセージのハッシュ値に対して行われます。このセクションでは、ハッシュ関数についてより詳細な紹介を行います。

ハッシュ関数を定義しましょう。**ハッシュ関数**とは、任意のサイズの入力を受け取り、固定長の出力を生成する効率的に計算可能な関数のことです。

**暗号学的ハッシュ関数**とは、単に暗号学のアプリケーションに有用なハッシュ関数のことです。暗号学的ハッシュ関数の出力は、通常**ハッシュ**、**ハッシュ値**、または**メッセージダイジェスト**と呼ばれます。

暗号学の文脈では、「ハッシュ関数」は通常、暗号学的ハッシュ関数を指します。ここからはその慣習に従います。

人気のあるハッシュ関数の例は**SHA-256**（セキュアハッシュアルゴリズム256）です。入力のサイズが（例えば、15ビット、100ビット、または10,000ビットであっても）、この関数は256ビットのハッシュ値を生成します。以下にSHA-256関数のいくつかの出力例を示します。

* "Hello": 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969
* "52398": a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90
* "Cryptography is fun": 3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c

すべての出力は正確に256ビットで、16進数形式で書かれています（各16進数は4ビットの二進数で表現できます）。ですから、たとえTolkienの*The Lord of the Rings*の本をSHA-256関数に入力しても、出力は依然として256ビットになります。

SHA-256のようなハッシュ関数は、暗号学において様々な目的で使用されます。ハッシュ関数に求められる特性は、特定のアプリケーションの文脈によって異なります。暗号学におけるハッシュ関数の一般的に望まれる2つの主要な特性は以下の通りです：<sup>[6](#footnote6)</sup>

1. 衝突耐性
2. 隠蔽性

ハッシュ関数Hが**衝突耐性**であるとは、x ≠ yであるにもかかわらず、H(x) = H(y)となる2つの値xとyを見つけることが実行不可能であることを意味します。
衝突耐性ハッシュ関数は、例えばソフトウェアの検証において重要です。Bitcoin Core 0.21.0のWindowsリリース（Bitcoinネットワークトラフィックを処理するサーバーアプリケーション）をダウンロードしたいとします。ソフトウェアの正当性を検証するために必要な主な手順は以下の通りです：
1. まず、一人以上のBitcoin Coreの貢献者の公開鍵をダウンロードして、デジタル署名を検証できるソフトウェア（例：Kleopetra）にインポートする必要があります。これらの公開鍵は[こちら](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt)で見つけることができます。複数の貢献者の公開鍵でBitcoin Coreソフトウェアを検証することが推奨されます。
2. 次に、インポートした公開鍵を検証する必要があります。少なくとも一つの手順として、見つけた公開鍵が他の場所で公開されているものと同じであることを検証するべきです。例えば、公開鍵をインポートした人々の個人的なウェブページ、Twitterページ、またはGithubページを参照することができます。通常、公開鍵の短いハッシュであるフィンガープリントを比較することによって、この公開鍵の比較が行われます。
3. 次に、[ウェブサイト](www.bitcoincore.org)からBitcoin Coreの実行ファイルをダウンロードする必要があります。Linux、Windows、MACオペレーティングシステム用のパッケージが利用可能です。
4. 次に、2つのリリースファイルを探す必要があります。最初のファイルには、ダウンロードした実行ファイルの公式SHA-256ハッシュと、リリースされた他のすべてのパッケージのハッシュが含まれています。もう一つのリリースファイルには、パッケージハッシュを含むリリースファイルに対する様々な貢献者からの署名が含まれています。これらのリリースファイルはBitcoin Coreのウェブサイトにあるべきです。
5. 次に、自分のコンピュータでBitcoin Coreウェブサイトからダウンロードした実行ファイルのSHA-256ハッシュを計算する必要があります。その後、この結果を実行ファイルの公式パッケージハッシュと比較します。これらは同じであるべきです。
6. 最後に、インポートした公開鍵の一つ以上が、公式パッケージハッシュを含むリリースファイル上のデジタル署名に対応していることを検証する必要があります（Bitcoin Coreのリリースは常に全員によって署名されるわけではありません）。これは、Kleopetraのようなアプリケーションで行うことができます。

このソフトウェア検証プロセスには2つの主な利点があります。第一に、Bitcoin Coreのウェブサイトからダウンロードする際の伝送エラーがなかったことを保証します。第二に、Bitcoin Coreのウェブサイトをハッキングするか、トラフィックを傍受することによって、攻撃者が変更された悪意のあるコードをダウンロードさせることができなかったことを保証します。

上記のソフトウェア検証プロセスは、これらの問題に対してどのように保護するのでしょうか？

インポートした公開鍵を入念に検証した場合、これらの鍵が実際に彼らのものであり、侵害されていないことをかなり確信することができます。デジタル署名には存在的偽造不可能性があるため、これらの貢献者だけがリリースファイルの公式パッケージハッシュにデジタル署名を行うことができたことを知っています。

ダウンロードしたリリースファイルの署名が確認できたとします。これで、ダウンロードしたWindows実行ファイルのローカルで計算したハッシュ値を、適切に署名されたリリースファイルに含まれるものと比較することができます。SHA-256ハッシュ関数が衝突耐性であることを知っているので、一致するということは、あなたの実行ファイルが公式の実行ファイルと完全に同じであることを意味します。

次に、ハッシュ関数の2番目の一般的な特性である隠蔽について考えてみましょう。任意のハッシュ関数Hは、非常に大きな範囲からランダムに選択された任意のxに対して、H(x)のみが与えられた場合にxを見つけることが不可能であるという隠蔽の特性を持っていると言われています。
以下に、私が書いたメッセージのSHA-256出力を示します。十分なランダム性を確保するため、メッセージの最後にはランダムに生成された文字列が含まれています。SHA-256には隠蔽性があるため、このメッセージを解読することは誰にもできません。
* b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded

しかし、SHA-256が弱くなるまであなたを不安にさせることはしません。私が書いた元のメッセージは以下の通りです：

* “This is a very random message, or well kind of random. This beginning part is not, but I will end with some relatively random characters to ensure a very unpredictable message. XLWz4dVG3BxUWm7zQ9qS”。

隠蔽性を持つハッシュ関数が使用される一般的な方法の一つは、パスワード管理です（このアプリケーションには衝突耐性も重要です）。FacebookやGoogleのようなまともなオンラインアカウントベースのサービスは、アカウントへのアクセスを管理するためにパスワードを直接保存しません。代わりに、そのパスワードのハッシュのみを保存します。ブラウザでパスワードを入力するたびに、最初にハッシュが計算されます。そのハッシュのみがサービスプロバイダーのサーバーに送信され、バックエンドデータベースに保存されているハッシュと比較されます。隠蔽性は、攻撃者がハッシュ値からそれを回復できないようにするのに役立ちます。

もちろん、ハッシュによるパスワード管理は、ユーザーが実際に難しいパスワードを選択する場合にのみ機能します。隠蔽性は、xが非常に大きな範囲からランダムに選択されると仮定しています。「1234」、「mypassword」、またはあなたの誕生日の日付のようなパスワードを選択することは、実際のセキュリティを提供しません。一般的なパスワードとそのハッシュの長いリストが存在し、攻撃者があなたのパスワードのハッシュを取得した場合に利用できます。これらのタイプの攻撃は**辞書攻撃**として知られています。攻撃者があなたの個人情報の一部を知っている場合、彼らはいくつかの情報に基づいた推測を試みるかもしれません。したがって、常に長く、安全なパスワード（できればパスワードマネージャーからの長くランダムな文字列）が必要です。

時には、衝突耐性と隠蔽の両方を持つハッシュ関数が必要なアプリケーションもありますが、必ずしもそうではありません。たとえば、私たちが議論したソフトウェア検証プロセスは、ハッシュ関数が衝突耐性を示すことのみを要求し、隠蔽は重要ではありません。

衝突耐性と隠蔽は、暗号学におけるハッシュ関数の主に求められる特性ですが、特定のアプリケーションでは他の種類の特性も望ましい場合があります。


### 注釈
[^1]: Whitfield DiffieとMartin Hellman, “New directions in cryptography,” *IEEE Transactions on Information Theory* IT-22 (1976), pp. 644–654, at p. 644 [^1].

[^2]: Ralph Merkleも“Secure communications over insecure channels”, *Communications of the Association for Computing Machinery*, 21 (1978), 294–99でキー交換プロトコルについて議論しています。Merkleがこの論文をDiffieとHellmanの論文より先に提出しましたが、後に公開されました。Merkleの解決策はDiffie-Hellmanのものとは異なり、指数関数的に安全ではありません [^2].

[^3]: Ron Rivest, Adi Shamir, そして Leonard Adleman, “A method for obtaining digital signatures and public-key cryptosystems”, *Communications of the Association for Computing Machinery*, 21 (1978), pp. 120–26 [^3].

[^4]: これらの発見の良い歴史は、Simon Singhによる*The Code Book*, Fourth Estate (London, 1999), 第6章によって提供されています [^4].
[^5]: 非否認性を達成しようとするあらゆる試みは、*第1章*で議論したもう一つのテーマであり、その基礎にはデジタル署名が関与する必要があります [^5]。
[^6]: 「隠蔽」という用語は一般的な言葉ではありませんが、Arvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller, Steven Goldfederによる*Bitcoin and Cryptocurrency Technologies*、Princeton University Press (Princeton, 2016)、第1章から特に取られています [^6]。

# RSA暗号システム
<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

対称暗号は通常、ほとんどの人にとって直感的に理解しやすいものですが、非対称暗号については通常そうではありません。前のセクションで提供された高レベルの説明には快適に感じるかもしれませんが、一方向関数が正確に何であり、どのようにして非対称スキームを構築するために使用されるかを疑問に思っているかもしれません。

この章では、非対称暗号に関するいくつかの謎を解き明かし、具体的な例、すなわちRSA暗号システムをより深く見ていきます。最初のセクションでは、RSA問題が基づいている因数分解問題を紹介します。その後、数論からのいくつかの重要な結果をカバーします。最後のセクションでは、この情報をまとめてRSA問題を説明し、これを使用して非対称暗号スキームを作成する方法を説明します。

この議論に深みを加えることは簡単な作業ではありません。かなりの数の数論定理と命題を紹介する必要があります。しかし、数学に嫌気がささないでください。この議論を進めることで、非対称暗号の基礎に何があるかの理解が大幅に向上し、それは価値のある投資です。

では、まず因数分解問題について見ていきましょう。

## 因数分解問題
<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

2つの数、例えばaとbを掛け合わせるとき、aとbを**因数**と呼び、結果を**積**と呼びます。数Nを2つ以上の因数の乗算に書き換える試みを**因数分解**または**分解**と呼びます。<sup>[1](#footnote1)</sup> これを必要とするあらゆる問題を**因数分解問題**と呼ぶことができます。

約2,500年前、アレクサンドリアのギリシャ数学者ユークリッドは整数の因数分解に関する重要な定理を発見しました。これは一般に**一意因数分解定理**と呼ばれ、以下のように述べられています：

*定理1*。1より大きいすべての整数Nは、素数であるか、または素因数の積として表現することができます。

この文の後半部分が意味するのは、1より大きい任意の非素数整数Nを取り、それを素数の乗算として書き出すことができるということです。以下は、非素数整数が素因数の積として書かれたいくつかの例です。

* 18 = 2 • 3 • 3 = 2 • 3<sup>2</sup>
* 84 = 2 • 2 • 3 • 7 = 2<sup>2</sup> • 3 • 7
* 144 = 2 • 2 • 2 • 2 • 3 • 3 = 2<sup>4</sup> • 3<sup>2</sup>
上記の整数3つについて、それぞれの素因数を計算することは、Nだけが与えられたとしても比較的簡単です。最小の素数である2から始め、整数Nがそれに何回割り切れるかを確認します。次に、Nが3、5、7などに割り切れるかを試します。このプロセスを、整数Nが素数のみの積として書かれるまで続けます。

例として、整数84を取り上げてみましょう。以下に、その素因数を決定するプロセスを示します。各ステップでは、残っている最小の素因数（左側）を取り出し、因数分解される残りの項を決定します。残りの項も素数になるまで続けます。各ステップで、84の現在の因数分解が最も右に表示されます。

* 素因数 = 2: 残りの項 = 42 	(84 = 2 • 42)
* 素因数 = 2: 残りの項 = 21 	(84 = 2 • 2 • 21)
* 素因数 = 3: 残りの項 = 7 		(84 = 2 • 2 • 3 • 7)
* 7は素数であるため、結果は 2 • 2 • 3 • 7、または 2<sup>2</sup> • 3 • 7 です。

今、Nが非常に大きいと仮定しましょう。Nをその素因数に分解することはどれほど難しいでしょうか？

それは実際にはNに依存します。例えば、Nが50,450,400だと仮定しましょう。この数は威圧的に見えるかもしれませんが、計算はそれほど複雑ではなく、手で簡単に行うことができます。上記と同様に、2から始めて順に進めます。以下に、上記と同様の方法でこのプロセスの結果を示します。

* 2: 25,225,200 	(50,450,400 = 2 • 25,225,200)  
* 2: 12,612,600 	(50,450,400 = 2<sup>2</sup> • 12,612,600)  
* 2: 6,306,300 		(50,450,400 = 2<sup>3</sup> • 6,306,300)  
* 2: 3,153,150 		(50,450,400 = 2<sup>4</sup> • 3,153,150)  
* 2: 1,576,575 		(50,450,400 = 2<sup>5</sup> • 1,576,575)  
* 3: 525,525 		(50,450,400 = 2<sup>5</sup> • 3 • 525,525)
* 3: 175,175 		(50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 175,175)
* 5: 35,035 		(50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5 • 35,035)
* 5: 7,007		    (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7,007)
* 7: 1,001 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7 • 1,001)
* 7: 143 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 143)
* 11: 13 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 11 • 13)
* 13が素数であるため、結果は2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 11 • 13です。

この問題を手で解くには時間がかかります。もちろん、コンピューターならこれを一瞬で行うことができます。実際、コンピューターは非常に大きな整数を一瞬で因数分解することがよくあります。

ただし、例外もあります。まず、2つの非常に大きな素数をランダムに選択するとします。これらをpとqとラベル付けするのが一般的で、ここではその慣習に従います。

具体的に言うと、pとqがともに1024ビットの素数であり、表現するには少なくとも1024ビットが必要であるとしましょう（つまり、最初のビットは1でなければなりません）。たとえば、37は素数の一つにはなり得ません。確かに、37を1024ビットで表現することはできます。しかし、明らかにそれを表現するためにこれほど多くのビットは*必要ありません*。37は6ビット以上ある任意の文字列で表現できます。（6ビットでは、37は100101として表されます）。

上記の条件下で選択された場合、pとqがいかに大きいかを理解することが重要です。例として、下に表現に少なくとも1024ビットが必要なランダムな素数を選びました。

* 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

pとqの素数をランダムに選択した後、それらを乗算して整数Nを得るとします。したがって、この後者の整数は、表現に少なくとも2048ビットが必要な2048ビット数です。これは、pやqのいずれよりもはるかに大きいです。
コンピュータにNを与え、Nの1024ビットの素因数2つを見つけるように依頼したとします。コンピュータがpとqを発見する確率は極めて小さいです。実用上は不可能と言ってもよいでしょう。これは、スーパーコンピュータやスーパーコンピュータのネットワークを使用したとしても同様です。

まず、コンピュータが1024ビットの数値を順に試し、それぞれが素数であり、Nの因数であるかどうかをテストすることで問題を解決しようとするとします。テストされる素数のセットは、およそ1.265 • 10<sup>305</sup>です。<sup>[2](#footnote2)</sup>

地球上のすべてのコンピュータを使ってこの方法で1024ビットの素数を見つけてテストしようとしても、Nの素因数を成功裏に見つける確率が10億分の1である場合、その計算期間は宇宙の年齢よりもはるかに長くなるでしょう。

実際には、コンピュータは先に述べた粗い手順よりもよくできます。コンピュータがより迅速に因数分解を行うために適用できるいくつかのアルゴリズムが存在します。しかし、ポイントは、これらのより効率的なアルゴリズムを使用しても、コンピュータのタスクは依然として計算上不可能であるということです。<sup>[3](#footnote3)</sup>

重要なのは、ここで述べた条件下での因数分解の難しさは、素因数を計算するための計算効率の良いアルゴリズムが存在しないという仮定に基づいていることです。実際に効率的なアルゴリズムが存在しないことを証明することはできません。それでも、この仮定は非常に妥当です：何百年にもわたる広範な努力にもかかわらず、我々はまだそのような計算効率の良いアルゴリズムを見つけていません。

したがって、特定の状況下での因数分解問題は、難問であると合理的に仮定することができます。具体的には、pとqが非常に大きな素数である場合、それらの積Nを計算することは難しくありませんが、Nのみが与えられた場合の因数分解は実際には不可能です。


## 数論の結果
<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

残念ながら、因数分解問題は非対称暗号スキームに直接使用することはできません。しかし、より複雑だが関連する問題、すなわちRSA問題をこの目的で使用することができます。

RSA問題を理解するためには、数論からのいくつかの定理と命題を理解する必要があります。これらは、このセクションで3つのサブセクションに分けて提示されます：(1) Nの位数、(2) Nに関する可逆性、(3) オイラーの定理。

この3つのサブセクションのいくつかの内容は、*第3章*ですでに紹介されています。しかし、便宜上、ここでその内容を再述します。


### Nの位数

整数aが整数Nと**互いに素**または**相対素**である場合、それらの間の最大公約数は1です。1は慣習的に素数ではありませんが、すべての整数の互いに素です（-1も同様です）。

例えば、a = 18およびN = 37の場合を考えてみましょう。これらは明らかに互いに素です。18と37の両方を割り切る最大の整数は1です。対照的に、a = 42およびN = 16の場合を考えてみましょう。これらは明らかに互いに素ではありません。両方の数は2で割り切ることができ、これは1より大きいです。
Nの順序を次のように定義することができます。Nが1より大きい整数であると仮定します。**Nの順序**とは、各互いに素なaについて次の条件が成り立つような、Nと互いに素な全ての数の数です：1 ≤ a < N。
例えば、N = 12の場合、1, 5, 7, 11のみが上記の要件を満たす唯一の互いに素な数です。したがって、12の順序は4に等しいです。

Nが素数であると仮定します。その場合、Nより小さく1以上の任意の整数はそれと互いに素です。これには次の集合の全ての要素が含まれます：{1,2,3….,N – 1}。したがって、Nが素数の場合、Nの順序はN – 1です。これは命題1で述べられており、φ(N)がNの順序を示します。

**命題1**。Nが素数の場合、φ(N) = N – 1

Nが素数でない場合、**オイラーのφ関数**を使用してその順序を計算できます。小さな整数の順序を計算するのは比較的簡単ですが、オイラーのφ関数は特に大きな整数に対して特に重要になります。オイラーのφ関数の命題は以下の通りです。

*定理2*。Nをp<sub>1</sub><sup>e_1</sup> • p<sub>2</sub><sup>e_2</sup> • … • p<sub>i</sub><sup>e_i</sup> • … • p<sub>n</sub><sup>e_n</sup>とし、集合{p<sub>i</sub>}がNの全ての異なる素因数を含み、各e_iが素因数p<sub>i</sub>がNに対して何回発生するかを示すとします。すると、φ(N) = p<sub>1</sub><sup>e_1 - 1</sup> • (p<sub>1</sub> - 1) • p<sub>2</sub><sup>e_2 - 1</sup> • (p<sub>2</sub> - 1) • … • p<sub>n</sub><sup>e_n - 1</sup> • (p<sub>n</sub> - 1)。

*定理2*は、非素数Nをその異なる素因数に分解すると、Nの順序を簡単に計算できることを示しています。

例えば、N = 270と仮定します。これは明らかに素数ではありません。Nをその素因数に分解すると、式は次のようになります：2 • 3<sup>3</sup> • 5。オイラーのφ関数によると、Nの順序は次の通りです：

* φ(N) = 2<sup>1 – 1</sup> (2 – 1) + 3<sup>3 – 1</sup> (3 – 1) + 5<sup>1 – 1</sup> (5 – 1) = 1 (1) + 9 (2) + 1 (4) = 1 + 18 + 4 = 23
次に、Nが2つの素数、pとqの積であると仮定します。上記の*定理2*は、Nの位数が以下のようになると述べています：p<sup>1 – 1</sup> (p – 1) x q<sup>1 – 1</sup> (q – 1) = (p – 1) x (q – 1)。これは特にRSA問題において重要な結果であり、以下の*命題2*で述べられています。
*命題2*。もしNが2つの素数、pとqの積である場合、Nの位数は積(p – 1) x (q – 1)になります。

例を挙げてみましょう。N = 119とします。この整数は2つの素数、すなわち7と17に因数分解することができます。したがって、オイラーのφ関数は119の位数が以下のようになることを示唆しています：

* φ(119) = (7 – 1) • (17 – 1) = 6 • 16 = 96。

言い換えると、整数119は1から119までの範囲に96個の互いに素な数を持っています。実際、この集合には7または17の倍数でない1から119までのすべての整数が含まれています。

ここから、Nの位数を決定する互いに素な集合を**C<sub>N</sub>**と表記しましょう。例えばN = 119の場合、集合**C<sub>119</sub>**は完全にリストするにはあまりにも大きすぎます。しかし、いくつかの要素は以下の通りです：**C<sub>119</sub>** = {1,2,….6,8….13,15,16,18,….,33,35….,96}。

### Nに関する可逆性

整数aが**Nに関して可逆**であるとは、a x b modulo N = 1 modulo Nとなるような少なくとも1つの整数bが存在する場合を指します。このような任意の整数bは、Nによる削減のaの**逆数**（または**乗法的逆数**）として言及されます。

例えば、a = 5およびN = 11の場合を考えてみましょう。5に乗算することで、5 x b mod 11 = 1 mod 11となるような多くの整数があります。例えば、整数20と31を考えてみましょう。これらの整数が両方とも11に対する削減のための5の逆数であることは容易にわかります。

* 5 x 20 mod 11 = 100 mod 11 = 1 mod 11
* 5 x 31 mod 11 = 155 mod 11 = 1 mod 11

5には11に対する削減のための多くの逆数がありますが、11より小さい唯一の正の逆数が存在することを示すことができます。実際、これは私たちの特定の例に限らず、一般的な結果です。

*命題3*。もし整数aがNに関して可逆である場合、aの正の逆数が正確に1つだけNより小さい必要があります。（したがって、このaの唯一の逆数は集合{1,…,N – 1}から来なければなりません）。
命題3から、aの一意の逆数をa<sup>-1</sup>と表記しましょう。a = 5、N = 11の場合、5 x 9 mod 11 = 45 mod 11 = 1 mod 11であることから、a<sup>-1</sup> = 9であることがわかります。
例で見たように、aの他の逆数を11で割った余りである9を得ることもできます。例えば、20 mod 11 = 31 mod 11 = 9 mod 11です。したがって、整数a > NがNに対して逆数可能である場合、a mod NもNに対して逆数可能でなければなりません。

aの逆数がNに対する剰余で存在するとは限りません。例えば、a = 2、N = 8の場合を考えてみましょう。2 x b mod 8 = 1 mod 8となるようなb、特にa<sup>-1</sup>は存在しません。これは、bのどんな値も常に2の倍数を生み出すため、8で割った余りが1になることは決してありません。

ある整数aが与えられたNに対して逆数を持つかどうかをどのようにして知ることができるのでしょうか？上記の例で気づいたかもしれませんが、2と8の最大公約数は1より大きい、つまり2です。これは、次の一般的な結果を示しています：

*命題4*。整数aがNに対する剰余で逆数を持ち、具体的にはNより小さい一意の正の逆数を持つのは、aとNの最大公約数が1（つまり、互いに素である）の場合に限ります。

a = 5、N = 11の場合、5 x 9 mod 11 = 45 mod 11 = 1 mod 11であることから、a<sup>-1</sup> = 9であると結論付けました。逆もまた真であることに注意してください。つまり、a = 9、N = 11の場合、a<sup>-1</sup> = 5です。

### オイラーの定理

RSA問題に移る前に、もう1つ重要な定理、すなわち**オイラーの定理**を理解する必要があります。それは以下のように述べています：

*定理3*。2つの整数aとNが互いに素である場合、a<sup>φ(N)</sup> mod N = 1 mod Nです。

これは注目すべき結果ですが、最初は少し混乱するかもしれません。それを理解するために例を挙げてみましょう。

a = 5、N = 7とします。これらはオイラーの定理が要求するように、確かに互いに素です。7の位数が6であることがわかります。なぜなら、7は素数であるためです（**命題1**を参照）。

オイラーの定理が現在述べているのは、5<sup>6</sup> mod 7が1 mod 7でなければならないということです。以下は、これが実際に真であることを示す計算です。

* 5<sup>6</sup> mod 7 = 15,625 mod 7 = 1 mod N

整数7は15,624を合計2,233回割ります。したがって、16,625を7で割った余りは1です。

次に、オイラーのファイ関数を使用して、以下の*命題5*を導出できます。
*命題 5*。任意の正の整数 a と b に対して、φ(a • b) = φ(a) • φ(b) が成り立ちます。
この理由を示すことはしませんが、p と q が素数である場合に φ(p • q) = φ(p) • φ(q) = (p – 1) • (q – 1) となることから、この命題の証拠を既に見ていることに注意してください。これは*命題 2*で述べられています。

オイラーの定理と*命題 5*の組み合わせは重要な意味を持ちます。例えば、以下の式で何が起こるかを見てください。ここで、a と N は互いに素です。

* a<sup>2 • φ(N)</sup> mod N = a<sup>φ(N)</sup> • a<sup>φ(N)</sup> mod N = 1 • 1 mod N = 1 mod N
* a<sup>φ(N) + 1</sup> mod N = a<sup>φ(N)</sup> • a<sup>1</sup> mod N = 1 • a<sup>1</sup> mod N = a mod N
* a<sup>8 • φ(N) + 3</sup> mod N = a<sup>8 • φ(N)</sup> • a<sup>3</sup> mod N = 1 • a<sup>3</sup> mod N = a<sup>3</sup> mod N

したがって、オイラーの定理と*命題 5*の組み合わせにより、多くの式を単純に計算することができます。一般的に、この洞察を*命題 6*としてまとめることができます。

*命題 6*。a<sup>x</sup> mod N = a<sup>x mod φ(N)</sup>

今、最後の難しいステップで全てをまとめる必要があります。

N が集合 **C<sub>N</sub>** の要素を含む順序 φ(N) を持つように、整数 φ(N) もまた順序と互いに素な集合を持つべきであることがわかります。φ(N) = R としましょう。すると、φ(R) の値と互いに素な集合 **C<sub>R</sub>** も存在することがわかります。

ここで、集合 **C<sub>R</sub>** から整数 e を選択するとしましょう。*命題 3* から、この整数 e は R より小さい一意の正の逆数を持つことがわかります。つまり、e は集合 **C<sub>R</sub>** から一意の逆数を持ちます。この逆数を d と呼びましょう。逆数の定義から、e • d = 1 mod R となります。

この結果を使って、元の整数 N についての声明を行うことができます。これは*命題 7*に要約されています。

*命題 7*。e • d mod φ(N) = 1 mod φ(N) と仮定します。すると、集合 **C<sub>N</sub>** の任意の要素 a に対して、a<sup>e • d mod φ(N)</sup> = a<sup>1 mod φ(N)</sup> = a mod N となります。

これで、RSA 問題を明確に述べるために必要な数論的な結果を全て得ました。

## RSA暗号システム
<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>
RSA問題を説明する準備ができました。p、q、N、φ(N)、e、d、およびyからなる変数のセットを作成するとします。このセットをΠと呼びます。これは以下のように作成されます：
1. 同じサイズの2つのランダムな素数pとqを生成し、それらの積Nを計算します。
2. Nの位数、φ(N)を次の積で計算します：(p - 1) • (q - 1)。
3. e > 2で、φ(N)より小さく、φ(N)と互いに素であるようなeを選択します。
4. e • d mod φ(N) = 1となるようにdを計算します。
5. Nより小さく、Nと互いに素であるランダムな値yを選択します。

RSA問題は、Πに関する情報のサブセット、すなわち変数N、e、およびyのみが与えられた状態で、x<sup>e</sup> = yとなるようなxを見つけることです。pとqが非常に大きい場合、通常は1024ビットのサイズであることが推奨されますが、RSA問題は難しいと考えられています。これまでの議論を踏まえると、その理由がわかります。

x<sup>e</sup> mod N = y mod Nの場合、xを計算する簡単な方法は単にy<sup>d</sup> mod Nを計算することです。次の計算により、y<sup>d</sup> mod N = x mod Nであることがわかります：

* y<sup>d</sup> mod N = x<sup>e • d</sup> mod N = x<sup>e • d mod φ(N)</sup> mod N = x<sup>1 mod φ(N)</sup> mod N = x mod N。

問題は、問題でdの値が与えられていないため、直接y<sup>d</sup> mod Nを計算してx mod Nを生成することができないことです。

しかし、Nの位数、φ(n)から間接的にdを計算することができるかもしれません。なぜなら、e • d mod φ(N) = 1 mod φ(N)であることがわかっているからです。しかし、問題の仮定により、φ(N)の値も与えられていません。

最終的に、素因数pとqを用いて間接的に位数を計算し、結果としてdを計算することができます。しかし、仮定により、pとqの値も私たちには提供されていませんでした。

厳密に言えば、RSA問題内の因数分解問題が難しいとしても、RSA問題自体が難しいとは証明できません。因数分解を通じてではない他の方法でRSA問題を解くことができるかもしれません。しかし、一般的には、RSA問題内の因数分解問題が難しい場合、RSA問題自体も難しいと考えられています。

RSA問題が実際に難しい場合、それはトラップドアを持つ一方向関数を生成します。ここでの関数はf(g) = g<sup>e</sup> mod Nです。f(g)の知識があれば、誰でも特定のg = xに対する値yを簡単に計算できます。しかし、値yと関数f(g)の値を知っているだけでは、特定の値xを計算することは実際には不可能です。例外は、情報d、つまりトラップドアが与えられた場合です。その場合、単にy<sup>d</sup>を計算してxを得ることができます。

RSA問題を具体的な例で説明しましょう。上記の条件下で難しいと考えられるRSA問題を選択することはできません。なぜなら、数字が扱いにくいからです。代わりに、この例はRSA問題が一般的にどのように機能するかを示すためのものです。
まず、ランダムな素数13と31を選んだと仮定します。したがって、p = 13、q = 31です。これら2つの素数の積Nは403になります。403の位数は簡単に計算できます。それは(13 - 1) • (31 - 1) = 360に相当します。
次に、RSA問題のステップ3に従って、360より大きく2より大きい互いに素な数を選ぶ必要があります。この値をランダムに選ぶ必要はありません。103を選んだと仮定します。これは、103との最大公約数が1であるため、360の互いに素です。

ステップ4では、103 • d mod 360 = 1となるような値dを計算する必要があります。Nの値が大きい場合、これは手作業では容易ではありません。これには**拡張ユークリッドアルゴリズム**と呼ばれる手順を使用する必要があります。

ここでは手順を示しませんが、e = 103のときに値7を得ます。以下の計算を通じて、値のペア103と7が一般条件e • d mod φ(n) = 1を満たしていることを確認できます。

* 103 • 7 mod 360 = 721 mod 360 = 1 mod 360

重要なことに、*命題4*によれば、1から360の間の他の整数dでは、103 • d = 1 mod 360という結果を得ることはできないことがわかります。さらに、この命題は、eに異なる値を選択すると、dに対して異なるユニークな値が得られることを意味します。

RSA問題のステップ5では、403のより小さい互いに素な正の整数yを選択する必要があります。y = 2<sup>103</sup>と設定したと仮定します。103による2の指数化は以下の結果をもたらします。

* 2<sup>103</sup> mod 403 = 10,141,204,801,825,835,211,973,625,643,008 mod 403 = 349 mod 403

この特定の例でのRSA問題は次のとおりです：N = 403、e = 103、およびy = 349 mod 403が与えられています。x<sup>103</sup> = 349 mod 403となるようなxを計算する必要があります。つまり、103による指数化の前の元の値が2であったことを見つける必要があります。

d = 7であることがわかっていれば、xを以下のように簡単に（少なくともコンピュータにとっては）計算できます。

* x = y<sup>7</sup> mod 403 = 349<sup>7</sup> mod 403 = 630,634,881,591,804,949 mod 403 = 2 mod 403

問題は、d = 7であるという情報が提供されていないことです。もちろん、103 • d = 1 mod 360であるという事実からdを計算することができます。問題は、Nの位数が360であるという情報も提供されていないことです。最後に、(p – 1) • (q – 1)の積を計算することによって403の位数も計算できますが、p = 13およびp = 31であるとも言われていません。
もちろん、この例でのRSA問題をコンピュータが比較的容易に解決できるのは、関与する素数が大きくないからです。しかし、素数が非常に大きくなると、実質的に不可能なタスクに直面します。
これで、RSA問題とそれが困難である条件のセット、およびその背景にある数学を紹介しました。これらはどのようにして非対称暗号化に役立つのでしょうか？具体的には、特定の条件下でのRSA問題の困難さをどのようにして暗号化スキームやデジタル署名スキームに変換できるのでしょうか？

一つのアプローチは、RSA問題を取り、直接的な方法でスキームを構築することです。例えば、RSA問題で説明されているように変数Πのセットを生成し、pとqが十分に大きいことを確認します。公開鍵を(N, e)と設定し、この情報を世界と共有します。上述のように、p、q、φ(n)、およびdの値は秘密にしておきます。実際には、dがあなたの秘密鍵です。

**C<sub>N</sub>**の要素であるメッセージmを送りたい人は、単に次のようにして暗号化できます：c = m<sup>e</sup> mod N。（ここでの暗号文cは、RSA問題の値yに相当します。）このメッセージを解読するには、単にc<sup>d</sup> mod Nを計算するだけです。

同じ方法でデジタル署名スキームを作成しようとするかもしれません。デジタル署名Sを付けたメッセージmを誰かに送りたいとします。S = m<sup>d</sup> mod Nと設定し、ペア(m,S)を受信者に送ればよいのです。誰でもS<sup>e</sup> mod N = m mod Nであるかどうかを確認することでデジタル署名を検証できます。しかし、攻撃者はdを持っていないため、メッセージに対して有効なSを作成するのは非常に困難です。

残念ながら、RSA問題というそれ自体が困難な問題を、暗号化スキームに変換することはこれほど単純ではありません。直接的な暗号化スキームでは、メッセージとしてNの互いに素な数を選択することしかできません。これでは標準的な通信に十分なメッセージが得られません。さらに、これらのメッセージはランダムに選択されなければなりません。これはやや非現実的に思えます。最後に、同じメッセージが二度選択されると、全く同じ暗号文が生成されます。これは任意の暗号化スキームで極めて望ましくなく、暗号化の厳格な現代の安全性の概念を満たしていません。

直接的なデジタル署名スキームにとって問題はさらに悪化します。現状では、攻撃者はNの互いに素な署名を最初に選択し、対応する元のメッセージを計算することで、容易にデジタル署名を偽造できます。これは明らかに実存的偽造不可能性の要件を破っています。

それでも、少しの賢い複雑さを加えることで、RSA問題を使用して安全な公開鍵暗号化スキームおよび安全なデジタル署名スキームを作成できます。ここではそのような構築の詳細には入りません。<sup>[4](#footnote4)</sup> 重要なことに、しかし、この追加の複雑さはこれらのスキームが基づいている基本的なRSA問題を変えるものではありません。
[^2]: 素数定理によると、N以下の素数の数はおおよそN/ln(N)です。これは、1024ビットの長さの素数の数を2^1024/ln(2^1024) - 2^1023/ln(2^1023)で近似できることを意味しており、これはおおよそ1.265 x 10^305に等しい[^2]。

# 貢献
<partId>4556aab1-4876-552a-b6db-df6837bbf27a</partId>

## 概要
<chapterId>ff08a57b-740f-5d7e-8cf2-81db0908166e</chapterId>

どんな貢献も大歓迎です。貢献する前に、私の本に対する現在の計画と貢献のためのガイドラインを以下で確認してください。

### 現在の計画

本のさらなる開発に関する私の現在の計画は以下の通りです：

- 実用的な暗号アプリケーションの詳細に入る最終章を作成する。例えば、トランスポート層セキュリティ、オニオンルーティング、ビットコインでの価値交換など
- 書かれた議論をサポートするために、より良く、より多くの図やダイアグラムを作成する
- 単なるMarkdownではなく、LaTeX Mathやその他の組版アプリケーションを使用して、公式の表記を行う

### 貢献のためのガイドライン

既存のテキストに対する小さな修正や提案がある場合は、プルリクエストを作成するか、問題を提起してください。プルリクエストを作成する場合は、以下のガイドラインに注意してください：

- リポジトリのフォーク内で別のブランチ上にコミットを作成する
- コミットを明確にラベル付けする
- レビュープロセスを容易にするために、論理的に異なる問題に対して別々のコミットを作成する

本に関してより大きな提案がある場合は、問題を提起するか、直接**jaburgers@protonmail.com**までご連絡ください。

### ライセンス

このリポジトリの作業は、クリエイティブ・コモンズ 表示-非営利-改変禁止 4.0 国際ライセンス（CC BY-NC-ND 4.0）の下でライセンスされています。

ライセンスの短い説明は[こちら](https://creativecommons.org/licenses/by-nc-nd/4.0/)で見つけることができます。

ライセンスの完全なバージョンは[こちら](https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode)で見つけることができます。

## 表記法
<chapterId>07250f8d-ad7c-5531-a70c-4417d6d1b865</chapterId>

### 主要用語

プライマーで導入される主要用語は、太字で示されます。例えば、**Rijndael暗号**としてRijndael暗号の導入が行われます。

主要用語は、それが固有名詞であるか、議論からその意味が明らかである場合を除き、明確に定義されます。

定義は通常、主要用語の導入時に与えられますが、時には定義を後の時点まで留保する方が便利な場合もあります。

### 強調された単語やフレーズ

単語やフレーズはイタリック体で強調されます。例えば、"Remember your password"というフレーズは、*パスワードを覚えておいてください*となります。

### 公式の表記

公式の表記は主に変数、確率変数、集合に関するものです。

* 変数：これらは通常、小文字の文字（例："x" や "y"）で示されます。明確さのために時々大文字化されることもあります（例："M" や "K"）。
* 確率変数：これらは常に大文字の文字（例："X" や "Y"）で示されます。
* 集合：これらは常に太字の大文字（例：**S**）で示されます。