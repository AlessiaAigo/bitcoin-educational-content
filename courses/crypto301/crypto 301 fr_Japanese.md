名前：暗号学入門
目標：暗号学的な観点からビットコインウォレットの作成を理解する
目的：
  - ビットコインに関連する暗号学の用語を解明する
  - ビットコインウォレットの作成をマスターする
  - ビットコインウォレットの構造を理解する
  - アドレスと派生パスを理解する

# 暗号学の中心への旅

ビットコインに魅了されていますか？ビットコインウォレットの動作原理について知りたいですか？暗号学の中心への魅惑的な旅に備えてください！私たちの専門家であるロワイックが、ハッシュ、キーの派生、楕円曲線などの技術的な用語の背後にある謎を明らかにしながら、ビットコインウォレットの作成の奥深さを案内します。

このトレーニングでは、ビットコインウォレットの構造を理解するための知識だけでなく、暗号学の魅力的な世界により深く没頭する準備もできます。さあ、この旅に出る準備はできましたか？私たちに参加して、あなたの好奇心をスキルに変えましょう！

+++

# 紹介

## 暗号学入門

### このトレーニングはあなたに適していますか？はい！

![Rogzyによる紹介](https://youtu.be/ul8zU5QWIXg)

私たちは、暗号学とHDウォレットの紹介をテーマにした新しいトレーニング「Crypto 301：暗号学とHDウォレットの入門」を、専門家のロワイック・モレルが主催することを大変喜んでお知らせします。このコースでは、データの暗号化とセキュリティを保証する数学の基礎である暗号学の魅力的な世界に没頭します。

私たちの日常生活や特にビットコインの世界では、暗号学は重要な役割を果たしています。プライベートキー、パブリックキー、アドレス、派生パス、シード、エントロピーなど、これらに関連する概念は、ビットコインウォレットの使用と作成の中心にあります。このコースでは、ロワイックが詳細に説明し、プライベートキーの生成方法とアドレスとの関連性を説明します。また、ロワイックは楕円曲線の数学的な詳細を1時間かけて説明します。さらに、ウォレットのセキュリティにHMAC SHA512を使用する重要性や、シードとニーモニックフレーズの違いについても理解するでしょう。
このトレーニングの最終目標は、HDウォレットの作成プロセスと使用される暗号化手法を技術的に理解できるようにすることです。年月が経つにつれて、Bitcoinウォレットは、特定のBIPによってより使いやすく、より安全で標準化されるように進化してきました。Loïcは、これらのBIPを理解するために、Bitcoinの開発者と暗号学者の選択肢を把握するのを助けます。私たちの大学が提供するすべてのトレーニングと同様に、このトレーニングも完全に無料でオープンソースです。つまり、自由に再利用して自由に使用することができます。このエキサイティングなコースの終わりには、皆さんからのフィードバックをお待ちしています。
### 教授による挨拶！

![intro par loïc](https://youtu.be/mwuxXLk4Kws)

こんにちは、皆さん、私はLoïc Morelです。Bitcoinウォレットで使用される暗号化技術の技術的な探求を通じて、皆さんをガイドします。

私たちの旅は、暗号化ハッシュ関数の深淵に飛び込むことから始まります。私たちは、不可欠なSHA256の内部構造を解明し、派生に特化したさまざまなアルゴリズムを探求します。

次に、デジタル署名の神秘的な世界を解読することで冒険を続けます。楕円曲線の魔法がこれらの署名にどのように適用されるかを発見し、秘密鍵から公開鍵を計算する方法について明らかにします。そしてもちろん、デジタル署名のプロセスについても取り上げます。

その後、Bitcoinウォレットの進化を振り返り、エントロピーと乱数の概念に踏み込みます。有名なニーモニックフレーズを復習しながら、パスフレーズについても触れます。さらに、128回のサイコロの投げでシードを生成するというユニークな体験もできます！

これらの堅固な基礎を持っていれば、Bitcoinウォレットの作成に向けて準備が整います。シードとマスターキーの生成から、拡張キーの研究、子キーペアの派生まで、各ステップを詳しく解説します。また、ウォレットの構造と派生パスについても議論します。

最後に、Bitcoinアドレスを調査することで、私たちの旅を締めくくります。アドレスの生成方法とBitcoinウォレットの動作における重要な役割について説明します。

私と一緒にこの魅力的な旅に出発し、かつてないほどの方法で暗号化の世界を探求しましょう。あらかじめ持っている概念を捨て、Bitcoinとその基本構造を理解する新しい方法に心を開いてください。

# ハッシュ関数

## Bitcoinに関連する暗号化ハッシュ関数の紹介
![2.1 - cryptographic hash functions](https://youtu.be/dvnGArYvVr8)
今日のセッションでは、ビットコインプロトコルのセキュリティにおいて重要な要素である、ハッシュ関数の暗号学的な世界について詳しく説明します。ハッシュ関数は、情報を一意かつ固定サイズのデジタルフィンガープリント（ハッシュ、フィンガープリント、またはコンデンセートとも呼ばれる）に変換する、非常に効率的な暗号解読ロボットのようなものです。

要約すると、ハッシュ関数は任意のサイズのメッセージを入力として受け取り、固定サイズのフィンガープリントに変換します。

ハッシュ関数の特性を説明するには、2つの重要な品質、つまり不可逆性と偽造への耐性を理解する必要があります。

不可逆性またはプレイイメージへの耐性は、入力から出力を計算することは簡単ですが、出力から入力を復元することは不可能であるということです。これは一方向関数です。

![image](assets/image/section1/0.JPG)

偽造への耐性は、入力の最小の変更でも大きく異なる出力が得られるという事実によって生じます。これらの関数は、ダウンロードしたソフトウェアの整合性を検証するのに使用されます。

![image](assets/image/section1/1.JPG)

これらの関数が持つもう一つの重要な特徴は、衝突耐性と第二のプレイイメージへの耐性です。衝突とは、異なる入力が同じ出力を生成することです。ハッシュの世界では衝突は避けられないかもしれませんが、優れた暗号ハッシュ関数は衝突を極力少なくします。リスクはゼロと見なせるほど低くなければなりません。まるで各ハッシュが巨大な都市の家のようでありながら、優れたハッシュ関数は各家に固有の住所を持つようにします。
第二のプレイイメージへの耐性は、衝突への耐性に依存します。衝突への耐性があれば、第二のプレイイメージへの耐性もあります。
与えられた入力情報に対して、出力のハッシュで衝突する異なる第二の入力を見つける必要があります。第二のプレイイメージへの耐性は、衝突への耐性と似ていますが、入力が与えられるという点が異なります。
今度は、陳腐化したハッシュ関数の波乱に満ちた流れに乗りましょう。SHA0、SHA1、およびMD5は、暗号ハッシュの海で錆びた貝殻と見なされています。これらは、衝突耐性を失ったため、しばしば推奨されません。引き出しの原理は、出力サイズの制限により、衝突回避が不可能であることを説明しています。ハッシュ関数が真に安全と見なされるためには、衝突、第二原像、および原像に耐える必要があります。

ビットコインプロトコルの重要な要素であるSHA-256ハッシュ関数は、船の船長です。SHA-512などの他の関数は、HMACとPBKDFの派生に使用されます。さらに、RIPMD160は、フィンガープリントを160ビットに縮小するために使用されます。HASH256とHASH160について話すとき、私たちはSHA-256とRIPMDを使用したダブルハッシュの使用を指しています。

HASH256は、メッセージをSHA256関数で2回ハッシュすることです。
$$
SHA256(SHA256(message))
$$
HASH160は、メッセージを最初にSHA256関数でハッシュし、次にRIPMD160を使用して2回ハッシュすることです。
$$
RIPMD160(SHA256(message))
$$
HASH160の使用は特に有利であり、SHA-256のセキュリティを享受しながらフィンガープリントのサイズを縮小することができます。

要約すると、暗号ハッシュ関数の究極の目標は、任意のサイズの情報を固定サイズのフィンガープリントに変換することです。安全と認識されるためには、逆変換不可能性、改竄耐性、衝突耐性、および第二原像耐性を持つ必要があります。

![image](assets/image/section1/2.JPG)

この探索の結果、暗号ハッシュ関数の謎を解き明かし、ビットコインプロトコルでの使用方法を明らかにし、それらの特定の目標を詳細に説明しました。ハッシュ関数が安全と見なされるためには、原像、第二原像、衝突、および改竄に耐性がある必要があります。また、ビットコインプロトコルで使用されるさまざまなハッシュ関数の範囲を見てきました。次のセッションでは、SHA256ハッシュ関数の核心に飛び込み、そのユニークな特性を与える魅力的な数学を探求します。

## SHA256の仕組み

![SHA256の仕組み](https://youtu.be/74SWg_ZbUj4)

ハッシュ関数の暗号的な迷宮を魅力的に旅する私たちの冒険の続きへようこそ。今日は、以前に紹介した複雑で巧妙なプロセスであるSHA256の謎を解き明かします。
再度説明しますが、SHA256ハッシュ関数の目的は、任意のサイズのメッセージを入力として受け取り、256ビットのハッシュを出力することです。
### 前処理

SHA256の前処理から始めましょう。

#### パディングビット

この最初のステップの目的は、メッセージを512ビットの倍数に均等化することです。そのために、メッセージにパディングビットを追加します。

Mを初期メッセージのサイズとします。
1はセパレータ用のビットです。
Pはパディングに使用されるビット数であり、64は前処理の2番目のフェーズに割り当てられるビット数です。
合計は512ビットの倍数でなければなりません。

![image](assets/image/section1/3.JPG)

入力メッセージが950ビットの場合の例：

```
ステップ1：サイズを決定する。理想的な最終ビット数。
(M + 64 + 1) (M = 950)の最初の512の倍数は1024です。
1024 = 2 * 512
したがって、n = 2。

ステップ2：Pを決定する。最終ビット数に到達するために必要なパディングビットの数。
-> M + 1 + P + 64 = n * 512
-> M + 1 + P + 64 = 2 * 512
-> 940 + 1 + P + 64 = 1024
-> P = 1024 - 1 - 64 - 950
-> P = 9

したがって、512の倍数に均等化するために9ビットのパディングを追加する必要があります。
```

そして、初期メッセージの直後に、セパレータ1とP（この例では9個の0）を追加します。

```
message + 1 000 000 000
```

#### サイズのパディング

次に、前処理の2番目のフェーズに移ります。これは、初期メッセージのサイズをビットで表したバイナリ表現を追加することを意味します。

950ビットの入力の例を再度見てみましょう：

```
数字950のバイナリ表現は：11 1011 0110

前のステップで予約した64ビットを使用します。64ビットを均等化するためにゼロを追加し、初期メッセージ、パディングビット、サイズのパディングを結合して均等化された入力を得ます。
```

結果は以下の通りです：

![image](assets/image/section1/4.JPG)

### 処理

#### 理解のための前提条件

##### 定数と初期化ベクトル
現在、私たちはSHA-256関数の処理の最初のステップに向けて準備をしています。良いレシピのように、私たちはいくつかの基本的な要素が必要です。これらは定数と初期化ベクトルと呼ばれます。
初期化ベクトルAからHは、最初の8つの素数の平方根の小数部の最初の32ビットです。これらは処理の最初のステップでの基本的な値として使用されます。これらの値は16進数形式です。

定数Kは、0から63までの値で、最初の64個の素数の立方根の小数部の最初の32ビットを表します。これらは圧縮関数の各ラウンドで使用されます。これらの値も16進数形式です。

##### 使用される演算子

圧縮関数では、XOR、AND、NOTなどの特定の演算子が使用されます。ビットごとにランクに従って処理を行い、XOR演算子と真理値表を使用します。AND演算子は、両方のオペランドが1と等しい場合にのみ1を返し、NOT演算子はオペランドの反対の値を返します。また、指定した数だけビットを右にシフトするためにSHR演算も使用します。

真理値表：

![image](assets/image/section1/6.JPG)

ビットシフト演算：

![image](assets/image/section1/7.JPG)

#### 圧縮関数

圧縮関数を適用する前に、入力を512ビットのブロックに分割します。各ブロックは独立して処理されます。

各512ビットのブロックは、32ビットのWピースに再分割されます。つまり、W(0)は512ビットブロックの最初の32ビットを表し、W(1)は次の32ビットを表し、以降、ブロックの512ビットに到達するまで続きます。

すべての定数KとWピースが定義されたら、各Wピースに対して以下の計算を各ラウンドで行います。

圧縮関数では64回の計算ラウンドが行われます。最後のラウンドでは、「関数の出力」で圧縮関数の初期状態に加算される中間状態が得られます。

その後、次の512ビットブロックに対して圧縮関数のすべてのステップを繰り返し、最後のブロックまで処理します。

圧縮関数内のすべての加算は、32ビットの合計を常に保つために2^32で割った余りを使用します。

![image](assets/image/section1/9.JPG)

![image](assets/image/section1/8.JPG)

##### 圧縮関数の1ラウンド

![image](assets/image/section1/11.JPG)

![image](assets/image/section1/10.JPG)
圧縮関数のラウンドは64回行われます。入力には、以前に定義されたブロックWと定数Kが含まれます。
赤い四角/クロスは、2^32ビットのモジュロ加算を示しています。

A、B、C、D、E、F、G、Hの入力は、合計で32 * 8 = 256ビットの値に関連付けられます。
また、新しいA、B、C、D、E、F、G、Hのシーケンスも出力されます。この出力は次のラウンドの入力として使用され、64番目のラウンドまで続きます。

圧縮関数の最初のラウンドの入力シーケンスの値は、前述の初期化ベクトルに対応します。
初期化ベクトルは、最初の8つの素数の平方根の小数部の32ビットを表します。

以下は、1つのラウンドの例です。

![image](assets/image/section1/12.1.png)

##### 中間状態

メッセージは512ビットのブロックに分割され、それぞれのブロックは32ビットの部分に分割されます。512ビットのブロックごとに、圧縮関数の64ラウンドを適用します。
中間状態は、1つのブロックの64ラウンドの終わりに対応します。この64番目のラウンドの出力シーケンスの値は、次のブロックの最初のラウンドの初期値として使用されます。

![image](assets/image/section1/12.2.png)

#### ハッシュ関数の全体像

![image](assets/image/section1/13.JPG)

512ビットの最初のメッセージの出力は、次の512ビットのメッセージの入力として使用されます。

最後のラウンド、最後の部分の出力は、SHA256関数の最終結果に対応します。

最後に、CH、MAJ、σ0、およびσ1ボックスで行われる計算の重要性を強調したいと思います。これらの操作は、SHA256ハッシュ関数の耐攻撃性を確保するガードとなっており、多くのデジタルシステムのセキュリティ確保において、特にBitcoinプロトコル内での選択肢となっています。したがって、SHA256の複雑さにもかかわらず、その美しさは、ハッシュから入力を復元する堅牢性にありますが、特定の入力のハッシュの検証は機械的に簡単な操作です。

## 派生に使用されるアルゴリズム

![Les algorithmes utilisés pour la dérivation](https://youtu.be/ZF1_BMsOJXc)

HMACおよびPBKDF2の派生アルゴリズムは、Bitcoinプロトコルのセキュリティメカニズムにおける重要な要素です。これらはさまざまな攻撃を防ぎ、Bitcoinウォレットの完全性を保証します。
HMACとPBKDF2は、Bitcoinでさまざまなタスクに使用される暗号ツールです。HMACは、階層的に決定されたウォレットの派生時に長さ拡張攻撃に対抗するために主に使用されます。一方、PBKDF2はニーモニックフレーズをシードに変換するために使用されます。
#### HMAC-SHA512

HMAC-SHA512は、2つの入力、メッセージm（入力1）とユーザーが任意に選択したキーK（入力2）を持つ特徴を持ちます。
また、固定サイズの出力（512ビット）もあります。

```
以下のように定義します：
- m：ユーザーが任意に選択した任意のサイズのメッセージ（入力1）
- K：ユーザーが任意に選択した任意のキー（入力2）
- K'：Kを調整したキー。これはブロックのサイズBに合わせて調整されました。
- ||：連結操作
- opad：0x5cバイトをB回繰り返した定数
- ipad：0x36バイトをB回繰り返した定数
- B：使用されるハッシュ関数のブロックサイズ
```

![image](assets/image/section1/14.JPG)

HMAC-SHA512は、メッセージとキーを入力として受け取り、固定サイズの出力を生成します。一貫性を確保するために、キーはハッシュ関数で使用されるブロックのサイズに合わせて調整されます。HDウォレットの派生においては、HMAC-SHA-512が使用されます。このアルゴリズムは1024ビット（128バイト）のブロックを使用し、キーを適切に調整します。セキュリティを強化するために、OPAD（0x5c）とIPAD（0x36）の定数を必要な回数繰り返します。

HMAC-SHA-512のプロセスは、キーXOR OPADとキーXOR IPADにSHA-512を適用した結果をメッセージと連結することを含みます。1024ビット（128バイト）のブロックを使用する場合、入力キーは必要に応じてゼロで埋められ、次にIPADとOPADとXORされます。変更されたキーは、その後、メッセージと連結されます。

![image](assets/image/section1/15.JPG)

追加のエントロピー源を組み込んだチェーンコードは、派生キーのセキュリティを向上させます。これがないと、攻撃者はウォレット全体を侵害し、すべてのビットコインを盗む可能性があります。

PBKDF2は、ニーモニックフレーズをシードに変換するために使用されます。このアルゴリズムは、HMAC SHA512を使用して2048回のラウンドを実行します。これらの派生アルゴリズムにより、異なる入力でも一意かつ固定の出力が生成され、SHA-2ファミリの関数における長さ拡張攻撃の問題が解決されます。
長さ拡張攻撃は、特定の暗号ハッシュ関数の特性を利用した攻撃です。この攻撃では、既知のメッセージのハッシュを持つ攻撃者が、元のメッセージの拡張であるより長いメッセージのハッシュを計算することができます。これは、通常、元のメッセージの内容を知らなくても可能であり、整合性の検証などのタスクにこのようなハッシュ関数が使用されている場合、重大なセキュリティ上の脆弱性につながる可能性があります。

結論として、HMACとPBKDF2アルゴリズムは、BitcoinプロトコルのHDウォレットのセキュリティにおいて重要な役割を果たしています。HMAC-SHA-512は、長さ拡張攻撃からの保護に使用され、PBKDF2はニーモニックフレーズをシードに変換します。チェーンコードは、キーの派生に追加のエントロピー源を提供し、システムの堅牢性を確保します。

デジタル署名

デジタル署名と楕円曲線

これらの有名なビットコインはどこに保存されているのでしょうか？ビットコインウォレットには保存されていません。実際には、ビットコインウォレットにはビットコインの所有を証明するために必要な秘密鍵が保存されています。ビットコイン自体は、すべてのトランザクションをアーカイブする分散型データベースであるブロックチェーンに記録されています。

ビットコインシステムでは、ビットコイン（小文字の「b」に注意）が通貨単位です。ビットコインは8桁まで分割でき、最小単位はサトシです。UTXO（未使用トランザクション出力）は、トランザクションの出力であり、数学的に秘密鍵に関連付けられた公開鍵に属する未使用のトランザクション出力を表します。これらのビットコインを使用するには、トランザクションの支出条件を満たす必要があります。典型的な支出条件は、ネットワークの他のユーザーに対して、UTXOに関連付けられた公開鍵の正当な所有者であることを証明することです。これを行うために、ユーザーはUTXOに関連付けられた公開鍵に対応する秘密鍵を所有していることを証明しなければなりませんが、秘密鍵自体は公開してはなりません。

これがデジタル署名の役割です。デジタル署名は、特定の公開鍵に関連付けられた秘密鍵の所有を数学的に証明するための数学的な証拠となります。このデータ保護技術は、楕円曲線暗号学と呼ばれる魅力的な暗号学の分野に基づいています。

デジタル署名は、ビットコインネットワークの他の参加者によって数学的に検証することができます。
ビットコインのトランザクションのセキュリティを確保するために、ビットコインは2つのデジタル署名プロトコル、ECDSA（楕円曲線デジタル署名アルゴリズム）とSchnorrを使用しています。ECDSAは2009年のビットコインの開始以来、ビットコインに組み込まれた署名プロトコルであり、Schnorrの署名は2021年11月に追加されました。これら2つのプロトコルは楕円曲線暗号学に基づいており、数学的なメカニズムも似ていますが、主に署名の構造の違いがあります。
このコースでは、ECDSAアルゴリズムについて説明します。

### 楕円曲線とは何ですか？

楕円曲線暗号学は、楕円曲線の異なる幾何学的および数学的な特性を暗号目的で利用する一連のアルゴリズムであり、その安全性は離散対数の計算の困難さに基づいています。

楕円曲線は、ビットコインプロトコルにおける鍵交換、非対称暗号化、デジタル署名など、さまざまな暗号アプリケーションで役立ちます。

楕円曲線には興味深い特性があります：

- 対称性：楕円曲線上の2つの点を結ぶ垂直でない直線は、曲線上の3番目の点で交差します。
- 曲線上の点で接線となる垂直でない直線は、常に曲線上の2番目の一意の点で交差します。

ビットコインプロトコルでは、特定の楕円曲線であるSecp256k1を使用して暗号操作を行います。

これらの署名メカニズムにより深く理解する前に、楕円曲線の定義を理解することが重要です。楕円曲線は、方程式y² = x³ + ax + bによって定義されます。この曲線上のすべての点には、暗号学での有用性の鍵となる特異な対称性があります。

![image](assets/image/section2/1.JPG)

最終的に、さまざまな楕円曲線が暗号目的で安全と認識されています。もっともよく知られているのは、secp256r1という曲線かもしれません。しかし、ビットコインでは、Satoshi Nakamotoは別の曲線、secp256k1を選択しました。

この曲線は、a=0、b=7のパラメータで定義され、その方程式はy² = x³ + 7 modulo nです。ここで、nは曲線の次数を決定する素数です。

![image](assets/image/section2/2.JPG)

最初の画像は、実数体上のsecp256k1曲線とその方程式を表しています。
2番目の画像は、ZP体（非負の自然数体）上のsecp256k1曲線の表現であり、pは素数であり、点の集合を表しています。これは点の雲のように見えます。近似を避けるために、非負の自然数体を使用しています。
pは素数であり、曲線の次数として使用されます。
最終的に、Bitcoinプロトコルで使用される方程式は次のようになります：
$$
y^2 = (x^3 + 7) mod(p)
$$
Bitcoinの楕円曲線の方程式は、前の画像の最後の方程式に対応しています。

このコースの次のセクションでは、理解を容易にするために、実数体上にある曲線を使用します。

### 秘密鍵から公開鍵を計算する

![秘密鍵から公開鍵を計算する](https://youtu.be/NJENwFU889Y)

まず、楕円曲線デジタル署名アルゴリズム（ECDSA）の世界に入りましょう。Bitcoinは、このデジタル署名アルゴリズムを使用して、秘密鍵と公開鍵を関連付けます。このシステムでは、秘密鍵は256ビットのランダムまたは擬似ランダムな数値です。秘密鍵の可能性の総数は理論的には2^256ですが、実際にはそれよりもわずかに少なくなります。正確には、256ビットの一部の秘密鍵はBitcoinには有効ではありません。

Bitcoinと互換性を持つために、秘密鍵は1からn-1の範囲にある必要があります。ここで、nは楕円曲線の次数を表します。したがって、Bitcoinの秘密鍵の可能性の総数は、おおよそ1.158 x 10^77です。これを考えると、それはおおよそ観測可能な宇宙に存在する原子の数と同じです。

![image](assets/image/section2/3.JPG)

一意の秘密鍵であるkは、次に公開鍵を決定するために使用されます。

公開鍵であるKは、ECDSAなどの不可逆なアルゴリズムを使用して、秘密鍵から派生した楕円曲線上の点です。秘密鍵がわかっている場合、公開鍵を見つけることは非常に簡単ですが、公開鍵のみがわかっている場合、秘密鍵を見つけることは不可能です。この不可逆性は、Bitcoinウォレットのセキュリティの基盤です。

公開鍵は512ビットであり、256ビットのx座標と256ビットのy座標で表される曲線上の点に対応しています。ただし、264ビットの数値に圧縮することもできます。

![image](assets/image/section2/4.JPG)

生成点（G）は、Bitcoinプロトコル上ですべての公開鍵が生成される曲線上の点です。それは特定のx座標とy座標を持ち、通常は16進数で表されます。secp256k1の場合、Gの座標は次のようになります：

- `Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798`
- `Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8`
このポイントは、すべての公開鍵を派生させるために役立ちます。公開鍵Kを計算するには、ポイントGを秘密鍵kで乗算するだけです。K = k.G

次に、楕円曲線上のポイントの加算と乗算について説明します。

#### 楕円曲線上のポイントの加算と倍化

##### 2つのポイントM + Lの加算

楕円曲線の特性の1つは、垂直でない直線が曲線上の2つのポイントで交差する場合、その直線は3番目のポイントであるOとも交差するということです。この特性を利用して、ポイントUを決定します。UはポイントOの反対です。

M + L = U

![image](assets/image/section2/5.JPG)

##### ポイントの自己加算= ポイントの倍化

ポイントGを自身に加算するには、そのポイントで曲線の接線を引きます。この接線は、楕円曲線の特性により、曲線と必ず2番目のユニークなポイント-Jで交差します。このポイントの反対であるJは、ポイントGを自身に加算した結果です。
G + G = J

実際、ポイントGは、Bitcoinシステムのユーザーのすべての公開鍵を計算するための出発点です。

![image](assets/image/section2/6.JPG)

#### 楕円曲線上のスカラー積

ポイントのスカラー積は、そのポイントを自身にn回加算することを意味します。

ポイントGの2倍化と同様に、ポイントGのn倍のスカラー積は、ポイントGで曲線の接線を引くことで行われます。この接線は、楕円曲線の特性により、曲線と必ず2番目のユニークなポイント-2Gで交差します。このポイントの反対である2Gは、ポイントGを自身に加算した結果です。

n = 4の場合、4Gに到達するまで操作を繰り返します。

![image](assets/image/section2/7.JPG)

以下は、3Gの計算例です。

![image](assets/image/section2/8.JPG)

これらの楕円曲線上のポイント操作は、公開鍵の計算の基礎です。秘密鍵を知っている場合、公開鍵の派生は非常に簡単です。
公開鍵は楕円曲線上のポイントであり、ポイントGをk回加算および倍化した結果です。ここで、kは秘密鍵です。

この例では：

- 秘密鍵k = 4
- 公開鍵K = kG = 4G

![image](assets/image/section2/9.JPG)
秘密鍵kを知っている場合、公開鍵Kを計算することは容易です。一方、公開鍵から秘密鍵を復元することは不可能です。これは、点の加算または倍加による結果ですか？
次のレッスンでは、ビットコインを使用してECDSAアルゴリズムを使ってデジタル署名を行う方法について説明します。

## 秘密鍵で署名する

![秘密鍵で署名する](https://youtu.be/h2hIyGgPqkM)

デジタル署名のプロセスは、秘密鍵の所有者であることを証明するための重要な手段であり、秘密鍵を明かさずに行われます。これはECDSAアルゴリズムを使用して行われ、一意のノンスの決定、特定の数値Vの計算、および2つの部分S1とS2からなるデジタル署名の作成を含みます。
セキュリティ攻撃を回避するためには常に一意のノンスを使用することが重要です。このルールを守らなかった場合に起こり得る有名な例は、PlayStation 3のハッキング事件です。これはノンスの再利用によって侵害されました。

![](assets/image/section2/10.JPG)

手順：

- ノンスvを決定する。つまり、一意のランダムな数値です。
  ノンス = Number Only Use Once（一度だけ使用する数値）。
  署名を行う人が決定します。
- 楕円曲線上の点Gから加算と倍加の計算を行い、Vの楕円曲線上の位置を求めます。
  V = v.G
  xとyは平面上のVの座標です。
- S1を計算します。
  S1 = x mod n（nは曲線の次数であり、xは平面上のVの座標です）。
  注：公開鍵の可能性の数は、ビットコインで使用される正の整数の有限体上の楕円曲線上の点の数よりも大きいです。
  曲線の次数は、公開鍵が取る可能性のある値に対応しています。
- S2を計算します。
  H(Tx) = トランザクションのハッシュ
  k = 秘密鍵
- 署名を計算します：S1 + S2の連結。
- 検証のための計算Pを行います。
  K = 公開鍵

例えば、公開鍵3Gを取得するには、点Gに接線を引き、-Gの反対を計算して2Gを得た後、Gと2Gを加算します。トランザクションを行うためには、公開鍵3Gに関連付けられたビットコインをロック解除するために、数値3を知っていることを証明する必要があります。
3Gと関連する秘密鍵を知っていることを証明し、デジタル署名を作成するために、まずnonceを計算し、そのnonceに関連する点V（この例では4G）を計算します。次に、公開鍵3Gと点Vを加算して点Tを計算し、結果は7Gです。

デジタル署名プロセスを簡単に説明します。
前の画像では、秘密鍵k = 3です。
この秘密鍵に関連する公開鍵Kを簡単に計算できます：K = 3G
次に、疑似乱数のnonceを生成します：v = 4。
このnonceから、Vを以下のように計算できます：V = v.G = 4G。

この点Vから、以下のように点Tを計算します：
T = t.G = 7G（ただし、t = 7）

デジタル署名の検証を行う時が来ました。

デジタル署名の検証は、送信者の秘密鍵を必要とせずに、署名されたメッセージの真正性を確認するためのECDSAアルゴリズムの重要なステップです。以下に、詳細な手順を示します：

この例では、tとVという2つの重要な値があります。
tは数値（この例では7）であり、Vは楕円曲線上の点（ここでは4Gで表される）です。これらの値はデジタル署名の作成時に生成され、メッセージと共に送信されます。

検証者がメッセージを受け取ると、tとVの2つの値も受け取ります。

検証者が署名を検証するために以下の手順を実行します：

1. まず、メッセージのハッシュ値であるHを計算します。
2. 次に、u1とu2を計算します。以下の式を使用します：
   - u1 = H /\* (S2)^-1 mod n
   - u2 = T /\* (S2)^-1 mod n
     ここで、S2はデジタル署名の2番目の部分、nは楕円曲線の位数、(S2)^-1はS2の逆数mod nです。
3. 次に、検証者は以下の式を使用して楕円曲線上の点P'を計算します：P' = u1 _ G + u2 _ K
   - Gは楕円曲線の生成点です。
   - Kは送信者の公開鍵です。
4. 検証者は、単純に点P'のx座標をnで割った余りであるI'を計算します。
5. 最後に、検証者はI'がtと等しいかどうかを確認します。等しい場合、署名は有効と見なされます。そうでない場合、署名は無効です。
この手順により、対応する秘密鍵を持つ送信者のみが、この検証プロセスをパスする署名を生成できることが保証されます。
![image](assets/image/section2/12.JPG)

簡単に言うと、署名を生成する人は、検証する人にt（この例ではt = 7）と点Vを提供します。

数字7と数字Vから公開鍵または秘密鍵を特定することは不可能です。

デジタル署名の検証手順は次のとおりです：

- 曲線上で、公開鍵の点と点Vを加算して点T'を求めます。
- 数字t.Gを計算します。
- t.Gの結果が数字T'と等しいかどうかを確認します。

結論として、デジタル署名の検証はビットコイン取引において重要な手順です。これにより、署名されたメッセージが送信中に変更されていないこと、送信者が秘密鍵の所有者であることが保証されます。このデジタル認証技術は、楕円曲線算術などの複雑な数学的原理に基づいており、秘密鍵の機密性を維持しながら、暗号取引の堅固なセキュリティ基盤を提供します。

ただし、これらの鍵の管理と生成は、ビットコインにおいて別の重要な問題です。新しい鍵ペアを生成する方法は？多数の鍵を安全かつ効率的に管理する方法は？必要な場合にこれらの鍵を回復する方法は？

これらの質問に答え、暗号セキュリティの理解を深めるために、次のコースでは階層的決定的ウォレット（HDウォレット）の概念とニーモニックフレーズの使用に焦点を当てます。これらのメカニズムは、暗号通貨の鍵を効率的に管理するための優れた手段を提供し、セキュリティを強化します。

# ニーモニックフレーズ

## ビットコインウォレットの進化

![ビットコインウォレットの進化](https://youtu.be/6tmu1R9cXyk)

階層的決定的ウォレット（HDウォレット）は、暗号通貨のエコシステムにおいて重要な役割を果たしています。"ウォレット"という用語は、この分野に初めて触れる人にとっては誤解を招くかもしれませんが、お金や通貨を保持することを意味しません。それはむしろ、暗号鍵のコレクションを指します。

最初のウォレットは、疑似乱数的に決定されたプライベートキーをまとめたソフトウェアでしたが、それらのキーには何の関連性もありませんでした。これらのウォレットは"Just a Bunch Of Keys"（JBOK）と呼ばれています。

キーには関連性がないため、新しいキーペアが生成されるたびに新しいバックアップを作成する必要があります。
ユーザーは、常に同じキーペアを使用して機密性を失うか、ランダムに新しいキーペアを生成し、そのキーの新しいバックアップを作成する必要があります。

ただし、これらのキーの管理の複雑さは、Bitcoin Improvement Proposals（BIP）と呼ばれる一連のプロトコルによって補われています。これらのアップグレード提案は、HDウォレットの機能とセキュリティの中心に位置しています。たとえば、2012年に発表された[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)は、これらのキーの生成と保存方法を革新し、決定論的かつ階層的に派生するキーの概念を導入しました。アイデアは、すべてのキーを一意の情報であるシードから決定論的かつ階層的に派生させることです。これにより、これらのキーのバックアッププロセスが大幅に簡素化され、同時にセキュリティレベルが維持されます。

その後、[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)は、24語のニーモニックフレーズという画期的なイノベーションを導入しました。このシステムにより、複雑で覚えにくい数字のシーケンスを、より簡単に覚えて保存できる一連の普通の単語に変換することができました。さらに、[BIP38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki)では、個々のキーのセキュリティを強化するために追加のパスフレーズを提案しました。これらの連続的な改善により、BIP43とBIP44の標準化が実現され、HDウォレットの構造と階層化が統一され、一般のユーザーにとってよりアクセスしやすく、使いやすくなりました。

次のセクションでは、HDウォレットの動作について詳しく説明します。キーの派生の原則について取り上げ、ポートフォリオのセキュリティを確保するために不可欠なエントロピーと乱数生成の基本的な概念を検討します。

まとめとして、BIP32とBIP39の役割を強調することは重要です。これらのプロトコルは、ランダムまたは擬似ランダムなシードから複数のキーを生成することを可能にします。これらの規格は、現在、単一の暗号通貨に特化したウォレットや複数の通貨タイプをサポートするウォレットの大部分で採用されています。
ビットコインのエコシステムにおける秘密鍵のセキュリティの重要性は否定できません。実際、これらの鍵はビットコインのトランザクションのセキュリティを保証する基盤です。予測可能性に関連する脆弱性を回避するために、これらの鍵は真にランダムに生成する必要がありますが、これは容易な作業ではありません。コンピュータ上では、真にランダムな数値を生成することは不可能です。なぜなら、それは必ず決定論的なプロセス、つまりコードから派生しているからです。そのため、さまざまなランダム数値生成器（RNG）についての情報を得ることが重要です。RNGの種類は、疑似乱数生成器（PRNG）から真の乱数生成器（TRNG）やエントロピー源を組み込んだPRNGまでさまざまです。

エントロピーは、システムの「乱雑さ」を指します。外部エントロピー、つまり外部情報源を使用して、ランダム数値生成器を使用してランダムな数値を取得することができます。

![image](assets/image/section3/2.JPG)

では、疑似乱数生成器（PRNG）の動作を見てみましょう。

PRNGは、内部状態0に対応するシード、つまり情報を入力として受け取ります。
この内部状態に対して変換関数が適用され、結果である疑似乱数が内部状態1に対応します。
内部状態1に対しても再び変換関数が適用され、新しいランダムな数値=内部状態2が得られます。
そして、これが続きます。

主な欠点は、同じシードは常に同じ結果を出力するということです。また、変換関数の結果を知っていれば、プロセスの出力のランダムな数値を復元することができます。

変換関数の例として、PBKDF2関数があります。

**要約すると、暗号的に安全なPRNGは次の条件を満たす必要があります：**

- 統計的にランダムであること
- 予測不可能であること
- 結果が公開されても耐性があること
- 十分に長い周期を持つこと

![image](assets/image/section3/3.JPG)

ビットコインの場合、秘密鍵はウォレットの基礎となる単一の情報から生成されます。この情報により、子鍵の決定論的かつ階層的な派生が可能となります。エントロピーは、すべてのHDウォレットの基盤ですが、このランダムな数値の生成には標準が存在しないため、ビットコインのトランザクションのセキュリティを確保するためにランダム数値の生成は重要な課題です。

## ニーモニックフレーズ

![ニーモニックフレーズ](https://youtu.be/uJERqH9Xp7I)
ビットコインウォレットのセキュリティは、すべてのユーザーにとって重要な問題です。ウォレットのバックアップを確保するための重要な方法は、エントロピーとチェックサムに基づいたニーモニックフレーズを生成することです。
![image](assets/image/section3/5.JPG)

エントロピーからニーモニックフレーズに変換するには、エントロピーのチェックサムを計算し、エントロピーとチェックサムを連結するだけです。

エントロピーが生成されたら、エントロピーに対してSHA256関数を使用してハッシュを作成します。
ハッシュの最初の8ビットを取得し、それがチェックサムです。
ニーモニックフレーズは、エントロピーにチェックサムを加えた結果です。

チェックサムは、回復フレーズの正確性を確認するためのものです。このチェックサムがないと、フレーズの誤りにより異なるウォレットが作成され、資金が失われる可能性があります。エントロピーをSHA256関数に通し、ハッシュの最初の8ビットを取得することでチェックサムを取得します。

![image](assets/image/section3/6.JPG)

エントロピーのサイズに応じて、ニーモニックフレーズの異なる標準が存在します。24ワードの回復フレーズのために最も一般的に使用される標準は、256ビットのエントロピーです。チェックサムのサイズは、エントロピーのサイズを32で割ることで決定されます。

例えば、256ビットのエントロピーは8ビットのチェックサムを生成します。エントロピーとチェックサムの連結により、それぞれ128ビット、160ビットなどのサイズが得られます。エントロピーのサイズに応じて、回復フレーズは128ビットの場合には12ワード、160ビットの場合には15ワード、256ビットの場合には24ワードとなります。

**ニーモニックフレーズのエンコーディング：**

![image](assets/image/section3/7.JPG)

最後の8ビットはチェックサムに対応します。
11ビットのセグメントごとに10進数に変換されます。
各10進数は、BIP39の2048語のリストから取得される単語に対応します。なお、同じ順序で最初の4文字を持つ単語は存在しません。

24ワードの回復フレーズをバックアップすることは、ビットコインウォレットの完全性を保護するために重要です。最も一般的に使用される2つの標準は、128ビットまたは256ビットのエントロピーと12または24ワードの連結です。パスフレーズの追加は、ウォレットのセキュリティを強化するための追加オプションです。

結論として、ビットコインウォレットのセキュリティを確保するためには、ニーモニックフレーズの生成は重要なプロセスです。エントロピーのサイズに応じて、ニーモニックフレーズの標準を遵守することが重要です。24ワードの回復フレーズのバックアップは、資金の損失を防ぐために不可欠です。

## パスフレーズ
![パスフレーズ](https://youtu.be/dZkOYO7MXwc)
パスフレーズは、ビットコインウォレットに追加できる追加のパスワードであり、セキュリティを強化するために使用されます。その使用は任意であり、ユーザーの裁量に委ねられます。パスフレーズは、メモニックフレーズと組み合わせてウォレットのシードを計算するための任意の情報を追加することで、そのセキュリティを強化します。

![画像](assets/image/section3/8.JPG)

パスフレーズは、ユーザーが選択したサイズのオプションの暗号化ソルトです。これにより、メモニックフレーズに結合される任意の情報を追加することで、HDウォレットのセキュリティを向上させることができます。

ウォレットの作成時に設定された場合、パスフレーズはウォレットのすべてのキーの派生に必要です。パスフレーズからシードを生成するためには、pbkdf2関数が使用されます。このシードを使用して、ウォレットのすべての子キーペアを派生させることができます。パスフレーズが変更されると、ビットコインウォレットは完全に異なるものになります。

パスフレーズは、ビットコインウォレットのセキュリティを強化するための重要なツールです。さまざまなセキュリティ戦略を適用することができます。たとえば、メモニックフレーズのバックアップを作成しやすくするために、重複を作成するために使用することができます。また、メモニックフレーズのランダム生成に関連するリスクを軽減することで、ウォレットのセキュリティを向上させることもできます。

効果的なパスフレーズは、長さ（20〜40文字）と多様性（大文字、小文字、数字、記号の使用）があります。ユーザーや環境に直接関連付けられていないほうが安全です。パスフレーズとして単純な単語ではなく、ランダムな文字列を使用する方が安全です。

![画像](assets/image/section3/9.JPG)

パスフレーズは、単純なパスワードよりも安全です。理想的なパスフレーズは、長く、多様で、ランダムです。ウォレットやホットウォレットのセキュリティを強化することができます。また、冗長で安全なバックアップを作成するためにも使用することができます。

ウォレットへのアクセスを失わないように、パスフレーズのバックアップに注意することが重要です。パスフレーズはHDウォレットのオプションです。サイコロや他の擬似乱数生成器を使用してランダムに生成することができます。パスフレーズやメモニックフレーズを記憶することはお勧めしません。

次のレッスンでは、シードの動作とそれから生成される最初のキーペアについて詳しく説明します。学習を続けるために、このレッスンをフォローしてください。お会いできるのを楽しみにしています。

# ビットコインウォレットの作成

## シードとマスターキーの作成
![シードとマスターキーの作成](https://youtu.be/56yAt_JDWhY)
このコースのこの部分では、階層的決定ウォレット（HDウォレット）の派生手順について説明します。HDウォレットは、階層的かつ決定論的にプライベートキーとパブリックキーを作成および管理することができます。

![画像](assets/image/section4/0.JPG)

HDウォレットの基礎は、ニーモニックフレーズとパスフレーズ（オプションの追加パスワード）の2つの要素に基づいています。これらはシードを構成し、ウォレットのキーを派生するための基盤となる512ビットのアルファベット数字のシーケンスです。このシードから、ビットコインウォレットのすべての子キーペアを派生することができます。シードは、パスフレーズの使用の有無に関係なく、ウォレットに関連するビットコイン全体にアクセスするためのキーです。

![画像](assets/image/section4/1.JPG)

シードを取得するために、ニーモニックフレーズとパスフレーズを使用してpbkdf2（Password-Based Key Derivation Function 2）関数を使用します。pbkdf2の出力は512ビットのシードです。

シードから、HMAC SHA-512（Hash-based Message Authentication Code Secure Hash Algorithm 512）アルゴリズムを使用してマスタープライベートキーとチェーンコードを決定することができます。このアルゴリズムは、結果を生成するためにメッセージとキーを入力として必要とします。マスタープライベートキーは、シードと「Bitcoin SEED」というフレーズから計算されます。このフレーズは、すべてのHDウォレットのすべての派生において同じであり、ウォレット間の一貫性を保証します。

元々、SHA-512関数はBitcoinプロトコルに実装されていませんでしたので、HMAC SHA-512を使用しています。HMAC SHA-512を「Bitcoin SEED」というフレーズとともに使用することで、ユーザーはBitcoinに特化したウォレットを生成するよう制約されます。HMAC SHA-512の結果は、512ビットの数値であり、左側の256ビットがマスタープライベートキーを表し、右側の256ビットがマスターチェーンコードを表します。

![画像](assets/image/section4/2.JPG)

マスタープライベートキーは、ウォレットの将来のすべてのキーの親キーであり、マスターチェーンコードは子キーの派生に関与します。親ペアの対応するチェーンコードを知らないと、子キーペアを派生することはできません。

ウォレット内のキーペアには、プライベートキー、パブリックキー、およびチェーンコードが含まれます。チェーンコードは、子キーの派生にランダム性を導入し、情報の漏洩を防ぐために各キーペアを分離するためのものです。
マスタープライベートキーは、シードから派生した最初のプライベートキーであり、ウォレットの拡張キーとは何の関係もありません。次のレッスンでは、xPub、xPRV、zPubなどの拡張キーについて詳しく説明し、なぜそれらが使用されるのか、どのように構築されるのかを理解します。

## 拡張キー

![拡張キー](https://youtu.be/TRz760E_zUY)

このコースのこの部分では、拡張キー（xPub、zPub、yPub）とそのプレフィックスについて学びます。これらはヒエラルキカルディターミニスティックウォレット（HDウォレット）内で子キーの派生に重要な役割を果たします。

![画像](assets/image/section4/3.JPG)

拡張キーはマスターキーとは異なります。HDウォレットはニーモニックフレーズとシードを生成し、マスターキーとマスターチェーンコードを取得します。拡張キーは子キーの派生に使用され、親キーと対応するチェーンコードの両方が必要です。拡張キーはこれらの2つの情報を組み合わせて派生プロセスを簡素化します。

![画像](assets/image/section4/4.JPG)

拡張公開キーは通常の子公開キーからのみ派生できますが、拡張プライベートキーは通常またはハードニングの派生において、子公開キーと子プライベートキーの両方を派生させることができます。ハードニング派生は親プライベートキーからの派生であり、通常の派生は親公開キーからの派生に対応します。

XPUBプレフィックスを使用した拡張キーの使用により、対応するプライベートキーまで遡ることなく新しいアドレスを派生させることができ、より高いセキュリティを提供します。拡張キーに関連するメタデータは、キーの階層内での役割と位置に関する重要な情報を提供します。

拡張キーは、特定のプレフィックス（XPRV、XPUB、YPUB、ZPUB）で識別されます。これにより、それが拡張プライベートキーまたは拡張公開キーであるか、およびその特定の目的が示されます。拡張キーに関連するメタデータには、バージョン（プレフィックス）、深さ、親公開キーのフィンガープリント、インデックス、ペイロード（チェーンコードと親キー）が含まれます。

![画像](assets/image/section4/5.JPG)

バージョンはキータイプを示します：xpub、xprv、...

深さは、マスターキーからの派生の数を表します。

親のフィンガープリントは、親キーのハッシュ160の最初の4バイトです。
インデックスは、その兄弟姉妹の中で拡張キーを生成するために使用されるペアの番号です。（兄弟姉妹 = 同じ深さのキー）例：3番目のアカウントのxpubを派生させたい場合、そのインデックスは2になります（インデックスは0から始まるため）。

ペイロードは、チェーンコード（32バイト）と親キー（33バイト）で構成されています。

圧縮された公開鍵は33バイトのサイズであり、生の公開鍵は512ビットです。圧縮された公開鍵は、生の公開鍵と同じ情報を持ちながら、サイズが小さくなっています。拡張キーは82バイトのサイズであり、そのプレフィックスは16進数に変換されたものを基数58で表現しています。チェックサムは、HASH256ハッシュ関数を使用して計算されます。

![image](assets/image/section4/6.JPG)

強化派生は、2のべき乗（2^31）から始まります。一般的に使用されるプレフィックスは、xpubとzpubであり、それぞれレガシーおよびsegwit v1およびsegwit v0の標準に対応しています。

次のレッスンでは、拡張キーとウォレットのマスターキーを使用した子キーペアの派生について学びます。

## 子キーペアの派生

![子キーペアの派生](https://youtu.be/FXhI-GmE9Aw)

思い出に、シードとマスターキーの計算について説明しました。これらはHDウォレット（階層的決定ウォレット）の階層化と派生において重要な最初の要素です。シードは、128ビットから256ビットの長さで、ランダムに生成されるか秘密のフレーズから生成されます。他のすべてのキーの派生において決定論的な役割を果たします。マスターキーは、シードから派生した最初のキーであり、他のすべての子キーペアの派生に使用されます。

マスターコードは、シードからウォレットの復元に重要な役割を果たします。同じシードから派生したすべてのキーは、同じマスターコードを持つことに注意してください。

![image](assets/image/section4/7.JPG)

HDウォレットの階層化と派生により、キーとウォレットの構造の効率的な管理が可能になります。拡張キーは、数学的な計算と特定のアルゴリズムを使用して、親キーから子キーペアを派生させることができます。
子鍵ペアには、強化キーと通常のキーの2種類があります。拡張公開鍵は通常の子公開鍵の派生のみを許可し、拡張秘密鍵は通常モードまたは強化モードの両方の子公開鍵および子秘密鍵の派生を許可します。各鍵ペアには、それらを区別するためのインデックスがあります。
![image](assets/image/section4/8.JPG)

子鍵の派生には、親鍵とインデックス、および鍵ペアに関連するチェーンコードを連結したHMAC-SHA512関数が使用されます。通常の子鍵のインデックスは0から2の31乗-1までであり、強化子鍵のインデックスは2の31乗から2の32乗-1までです。

![image](assets/image/section4/9.JPG)

![image](assets/image/section4/10.JPG)

子鍵ペアには、強化ペアと通常のペアの2種類があります。子鍵の派生プロセスでは、公開鍵が支出条件の生成に使用され、秘密鍵が署名に使用されます。拡張公開鍵は通常の子公開鍵の派生のみを許可し、拡張秘密鍵は通常モードまたは強化モードの両方の子公開鍵および子秘密鍵の派生を許可します。

![image](assets/image/section4/11.JPG)
![image](assets/image/section4/12.JPG)

強化派生では親秘密鍵が使用され、通常の派生では親公開鍵が使用されます。強化派生にはHMAC-SHA512関数が使用され、通常の派生には512ビットのハッシュが使用されます。子公開鍵は楕円曲線の生成器に子秘密鍵を乗算することで得られます。

![image](assets/image/section4/13.JPG)
![image](assets/image/section4/14.JPG)

多数の鍵ペアを決定論的に階層化および派生することにより、階層的派生のためのツリースキームを作成することができます。このトレーニングの次のコースでは、HDウォレットの構造と派生パスについて詳しく説明し、特に派生パスの表記に重点を置いて学習します。

## ウォレットの構造と派生パス

![ウォレットの構造と派生パス](https://youtu.be/etO9UxwyE2I)
この章では、HDウォレット（階層的決定ウォレット）内の派生木の構造を学びます。すでにシードの計算、マスターキー、および子キーペアの派生について調査しました。今度は、ウォレット内のキーの組織に焦点を当てます。
HDウォレットでは、キーを組織するために深さのレイヤーを使用します。親キーから子キーへの派生ごとに、深さのレイヤーが対応します。

![image](assets/image/section4/15.JPG)

- 深さ0はマスターキーとマスターチェーンコードに対応します。

- 深さ1は、特定の目的に基づいて子キーを派生させるために使用されます。目的は、BIP 84およびSegwit v0/v1の標準に準拠しています。

- 深さ2は、異なる暗号通貨やネットワークのアカウントを区別するために使用されます。これにより、異なる資金源に基づいてウォレットを組織することができます。Bitcoinの場合、インデックスは0になります。

- 深さ3は、ウォレットを異なるアカウントに組織するために使用され、より明確で組織化された構造を提供します。

- 深さ4は、公に通信されるアドレスに使用される内部および外部チェーンに対応します。インデックス0は外部チェーンに関連付けられ、インデックス1は内部チェーンに関連付けられます。各アカウントには、外部チェーン（0）と内部チェーン（1）の2つのチェーンがあります。深さ4は、マルチシグウォレットの場合にスクリプトのタイプを管理するためにも使用されます。

- 深さ5は、通常のウォレット上の受信アドレスに使用されます。次のセクションでは、子キーペアの派生について詳しく調べます。

![image](assets/image/section4/16.JPG)

各深さのレイヤーごとに、子キーペアを区別するためにインデックスを使用します。

アポストロフなしのインデックスは実際に使用されるインデックスに対応し、アポストロフ付きのインデックスは実際のインデックス+2^31に対応します。強化派生では、インデックスは2^31から2^32-1まで使用されます。たとえば、インデックス44'は実際のインデックス2^31 + 44に対応します。

特定の受信アドレスを生成するために、マスターキーとマスターチェーンコードから子キーペアを派生させます。その後、インデックスを使用して同じ深さの異なる子キーペアを区別します。
拡張キー（XPUB）などの拡張キーは、複数の人とウォレットを共有するために使用されます。派生パスは、外部チェーン（共有するためのアドレス）と内部チェーン（取引所のアドレス）を区別するために使用されます。
次の章では、受信アドレス、その使用の利点、および構築手順について説明します。

# ビットコインアドレスとは何ですか？

## ビットコインアドレス

![ビットコインアドレス](https://youtu.be/nqGBMjPtFNI)

この章では、ビットコインシステムで重要な役割を果たす受信アドレスについて探求します。これらはコインの受け取りに使用され、秘密鍵と公開鍵のペアから生成されます。Pay2PublicKeyと呼ばれるスクリプトタイプがあり、ビットコインを公開鍵にロックすることができますが、一般的には受信アドレスを使用することが好まれます。

![画像](assets/image/section5/0.JPG)

受信者がビットコインを受け取りたい場合、公開鍵ではなく受信アドレスを送信者に提供します。アドレスは実際には公開鍵のハッシュであり、特定の形式を持っています。公開鍵は、楕円曲線上の点の加算や倍加などの数学的操作を使用して、子秘密鍵から派生します。

![画像](assets/image/section5/1.JPG)

アドレスから公開鍵に逆算することや、公開鍵から秘密鍵に逆算することはできないことに注意してください。アドレスの使用により、元々512ビットの公開鍵情報のサイズが削減されます。

ビットコインアドレスは使用の容易さのためにサイズが縮小されました。アドレスにはチェックサムがあり、タイプミスを検出し、ビットコインの損失リスクを減らすことができます。一方、公開鍵にはチェックサムがないため、タイプミスにより対応する資金が失われる可能性があります。

アドレスは、公開情報と秘密情報の間に第二のセキュリティレイヤーを提供し、秘密鍵の乗っ取りを困難にします。

各アドレスは一度だけ使用することが重要です。同じアドレスを再利用すると、プライバシーの問題が発生し、避けるべきです。

ビットコインアドレスにはさまざまなプレフィックスが使用されます。たとえば、BC1QはSegwit V0アドレス、BC1PはTaproot/Segwit V1アドレス、プレフィックス1と3はPay2PublicKeyH/Pay2ScriptH（レガシー）アドレスに関連付けられています。次のレッスンでは、公開鍵からアドレスの派生をステップバイステップで説明します。

## ビットコインアドレスの作成方法
![ビットコインアドレスの作成方法](https://youtu.be/ewMGTN8dKjI)
この章では、ビットコインのトランザクションのための受信アドレスの作成について説明します。受信アドレスは、圧縮された公開鍵のアルファベットと数字の文字列表現です。公開鍵から受信アドレスへの変換には、いくつかのステップが必要です。

### ステップ1：公開鍵の圧縮

![image](assets/image/section5/14.png)

アドレスは、子公開鍵から派生します。

公開鍵は楕円曲線上の点です。楕円曲線の対称性により、楕円曲線上の点はx座標に対して2つの可能なy値（正または負）のみを持ちます。
しかし、ビットコインプロトコルでは、実数の代わりに有限の正の整数体で作業しています。2つのy値の区別をするために、yが偶数か奇数かを示すだけで十分です。

公開鍵の圧縮により、そのサイズを520ビットから264ビットに減らすことができます。

yが偶数の場合は0x02、yが奇数の場合は0x03のプレフィックスを使用します。これが公開鍵の圧縮形式です。

### ステップ2：圧縮された公開鍵のハッシュ

![image](assets/image/section5/3.JPG)

圧縮された公開鍵のハッシュはSHA256関数で行われます。その後、RIPEMD160関数がハッシュに適用されます。

### ステップ3：ペイロード=アドレスのペイロード

![image](assets/image/section5/4.JPG)

RIPEMD160(SHA256(K))のバイナリハッシュは、5ビットのグループに分割されます。各グループは16進数（ヘキサデシマル）および/または10進数に変換されます。

### ステップ4：BCHプログラムを使用したチェックサムのメタデータの追加

![image](assets/image/section5/5.JPG)

レガシーアドレスの場合、アドレスのチェックサムを生成するためにダブルハッシュSHA256が使用されます。ただし、Segwit V0およびV1アドレスの場合、エラーの検出を確実にするためにBCHのチェックサム技術が使用されます。BCHプログラムは、非常に低いエラー確率でエラーを検出および修正することができます。現在、BCHプログラムは変更を提案および修正するために使用されますが、ユーザーの代わりに自動的に変更は行いません。
BCHプログラムは、拡張が必要なHRP（Human Readable Part）を含む複数の入力情報を必要とします。 HRPの拡張は、各文字をASCIIコードに基づいて2進数でエンコードすることです。次に、各文字の結果の最初の3ビットを10進数に変換します（画像の青色部分）。セパレーター0を挿入します。次に、各文字の事前に10進数に変換された最後の5ビットを連結します（画像の黄色部分）。
HRPの10進数拡張により、各文字の最後の5ビットが分離され、チェックサムが強化されます。

Segwit V0バージョンは、コード00で表され、"payload"は黒で、10進数で表されます。これには、チェックサム用に予約された6つの文字が続きます。

### ステップ5：BCHプログラムを使用してチェックサムを計算する

![image](assets/image/section5/6.JPG)

メタデータを含む入力は、次にBCHプログラムに提出され、10進数のチェックサムを取得します。

ここにチェックサムがあります。

### ステップ6：アドレスの構築とBech32への変換

![image](assets/image/section5/7.JPG)

バージョン、ペイロード、およびチェックサムの連結により、アドレスが構築されます。次に、10進数の文字は、対応表を使用してBech32文字に変換されます。Bech32アルファベットには、1、b、i、およびoを除くすべての英数字が含まれており、混乱を避けるためです。

### ステップ7：HRPとセパレーターの追加

![image](assets/image/section5/8.JPG)

ピンク色がチェックサムです。
黒色がペイロード=公開鍵のハッシュです。
青色がバージョンです。

すべてをBech32に変換し、ビットコインの場合は 'bc' を追加し、セパレーターとして '1' を追加して、アドレスが完成します。

# より進んでいく

## 128回のダイスロールからシードの作成！

![Création d’une seed depuis 128 lancés de dés !](https://youtu.be/lUw-1kk75Ok)

ニーモニックフレーズの作成は、暗号通貨ウォレットのセキュリティ確保における重要なステップです。ニーモニックフレーズを生成するためのいくつかの方法がありますが、ここではダイスを使用した手動生成方法に焦点を当てます。ただし、この方法は高額なウォレットには適していません。ニーモニックフレーズを生成するためには、オープンソースのソフトウェアまたはハードウェアウォレットを使用することをお勧めします。ニーモニックフレーズを作成するために、ダイスを使用してバイナリ情報を生成します。目的は、ニーモニックフレーズの作成プロセスを理解することです。

**ステップ1 - 準備：**
セキュリティのために、Tails OSなどのメモリレスのLinuxディストリビューションをUSBキーにインストールしてください。このチュートリアルはメインウォレットを作成するために使用しないでください。
**ステップ2 - ランダムバイナリ数の生成：**
バイナリ情報を生成するためにダイスを使用します。128回ダイスを振り、結果を記録します（奇数の場合は1、偶数の場合は0）。

**ステップ3 - バイナリ数の整理：**
得られたバイナリ数を11桁の行に整理して、後の計算を容易にします。12行目は7桁のみである必要があります。

**ステップ4 - チェックサムの計算：**
12行目の最後の4桁はチェックサムに対応します。このチェックサムを計算するには、Linuxディストリビューションのターミナルを使用する必要があります。[TailOs](https://tails.boum.org/index.fr.html)を使用することをお勧めします。これはUSBキーからブート可能なメモリレスディストリビューションです。ターミナルに入り、`echo <binary number> | shasum -a 254 -0`というコマンドを入力します。`<binary number>`を128個の0と1のリストに置き換えます。出力は16進数のハッシュです。このハッシュの最初の文字を取得し、バイナリに変換します。[この表](https://www.educative.io/answers/decimal-binary-and-hex-conversion-table)を参考にしてください。バイナリのチェックサム（4桁）を12行目に追加します。

**ステップ5 - 10進数への変換：**
各行に関連付けられた単語を見つけるには、まず11ビットのシリーズを10進数に変換する必要があります。オンラインの変換ツールは使用できません。これらのビットはニーモニックフレーズを表しているためです。計算機と以下のトリックを使用して変換する必要があります。各ビットは2のべき乗に関連付けられており、左から右に11のランクがあります。それぞれ1024、512、256、128、64、32、16、8、4、2、1に対応しています。11ビットのシリーズを10進数に変換するには、1を含むランクのみを加算します。たとえば、シリーズ00110111011の場合、次のような加算になります：256 + 128 + 32 + 16 + 8 + 2 + 1 = 443。各行を10進数に変換できます。単語のエンコードに進む前に、すべての行に+1を追加する必要があります。なぜなら、BIP39の単語リストのインデックスは0ではなく1から始まるためです。

**ステップ8 - ニーモニックフレーズの生成：**
まず、[2048ワードリスト](https://seedxor.com/files/wordlist.pdf)を印刷して、10進数とBIP39の単語の変換を行います。このリストの特徴は、この辞書の他のすべての単語と共通して最初の4文字を持たないことです。次に、各行に関連する10進数の単語を検索します。
**ステップ9 - ニーモニックフレーズのテスト：**
Sparrow Walletでニーモニックフレーズをすぐにテストし、それを使用してウォレットを作成します。無効なチェックサムエラーが表示された場合、計算ミスをした可能性があります。このエラーを修正するには、ステップ4からやり直して、再度Sparrow Walletでテストしてください。これで、128回のダイスロールから新しいBitcoinウォレットが作成されました。

ニーモニックフレーズを生成することは、暗号通貨ウォレットを保護するための重要なプロセスです。ソフトウェアのオープンソースやハードウェアウォレットの使用など、より安全な方法を使用することが推奨されます。ただし、このワークショップを行うことで、ランダムな数値からBitcoinウォレットを作成する方法をより理解することができます。

## ボーナス：Théo Pantamisへのインタビュー

Bitcoinプロトコルで広く使用されている別の暗号化メソッドは、デジタル署名のメソッドです。

## 結論と最後

### 感謝とウサギの穴を掘り続ける

Crypto 301のトレーニングにご参加いただき、心から感謝申し上げます。この経験が有益で学びになったことを願っています。数学、暗号化、Bitcoinプロトコルの動作など、多くの興味深いトピックを取り上げました。

さらに学習を深めたい場合、追加のリソースを提供しています。Théo PantamisとLoïc Morelとのインタビューを実施しました。これらの専門家は暗号化の分野で高名です。このインタビューでは、さまざまな側面を詳しく探求し、興味深い視点を提供しています。

暗号化の魅力的な領域をさらに探求するために、ぜひこのインタビューをご覧ください。あなたの旅に役立ち、インスピレーションを与えることを願っています。改めて、このトレーニングに参加していただき、ご協力いただきありがとうございました。

### サポートしてください

このコースおよびこの大学のすべてのコンテンツは、私たちのコミュニティによって無料で提供されています。私たちをサポートするために、周りで共有したり、大学のメンバーになったり、GitHubを通じて開発に貢献したりすることができます。チーム全員を代表して、ありがとうございます！

### コースの評価

この新しいE-learningプラットフォームには、コースの評価システムが近日中に統合される予定です！それまでの間、このコースを受講していただき、お楽しみいただけた場合は、周りで共有することをお考えください。